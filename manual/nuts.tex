\usemodule[art-01,abr-01]

\starttext

\section{Two access models}

After doing lots of tests with \LUATEX\ and \LUAJITTEX\, with and without just in
time compilation enabled, and with and without using ffi, we came to the
conclusion that userdata prevents a speedup. We also found that the checking of
metatables as well as assignment comes with overhead that can't be neglected.
This is normally not really a problem but when processing fonts for more complex
scripts it could have quite some overhead.

Because the userdata approach has some benefits, this remains the recommended way
to access nodes. We did several experiments with faster access using this model,
but eventually settled for the \quote {direct} approach. For code that is proven
to be okay, one can use this access model that operates on nodes more directly.

Deep down in \TEX\ a node has a number which is an entry in a memory table. In
fact, this model, where \TEX\ manages memory is real fast and one of the reasons
why plugging in callbacks that operate on nodes is quite fast. No matter what
future memory model \LUATEX\ has, an internal reference will always be a simple data
type (like a number or light userdata in \LUA\ speak). So, if you use the direct
model, even if you know that you currently deal with numbers, you should not depend
on that property but treat it an abstraction just like traditional nodes. In fact,
the fact that we use a simple basic datatype has the penalty that less checking can
be done, but less checking is also the reason why it's somewhat faster. An
important aspect is that one cannot mix both methods, but you can cast both
models.

So our advice is: use the indexed approach when possible and investigate the
direct one when speed might be an issue. For that reason we also provide the
\type {get*} and \type {set*} functions in the top level node namespace. There is
a limited set of getters. When implementing this direct approach the regular
index by key variant was also optimized, so direct access only makes sense when
we're accessing nodes millions of times (which happens in some font processing
for instance).

We're talking mostly of getters because setters are less important. Documents
have not that many content related nodes and setting many thousands of properties
is hardly a burden contrary to millions of consultations.

Normally you will access nodes like this:

\starttyping
local next = current.next
if next then
    -- do something
end
\stoptyping

Here \type {next} is not a real field, but a virtual one. Accessing it results in
a metatable method being called. In practice it boils down to looking up the
node type and based on the node type checking for the field name. In a worst case
you have a node type that sits at the end of the lookup list and a field that is
last in the lookup chain. However, in successive versions of \LUATEX\ these lookups
have been optimized and the most frequently accessed nodes and fields have a higher
priority.

Because in practice the \type {next} accessor results in a function call, there
is some overhead involved. The next code does the same and performs a tiny bit
faster (but not that much because it is still a function call but one that
knows what to look up).

\starttyping
local next = node.next(current)
if next then
    -- do something
end
\stoptyping

There are several such function based accessors now:

\starttabulate[|T|p|]
\NC getnext    \NC parsing nodelist always involves this one \NC \NR
\NC getprev    \NC used less but is logical companion to getnext \NC \NR
\NC getid      \NC consulted a lot \NC \NR
\NC getsubtype \NC consulted less but also a topper \NC \NR
\NC getfont    \NC used a lot in otf handling (glyph nodes are consulted a lot) \NC \NR
\NC getchar    \NC idem and also in other places \NC \NR
\NC getlist    \NC we often parse nested lists so this is a convenient one too
                   (only works for hlist and vlist!) \NC \NR
\NC getleader  \NC comparable to list, seldom used in \TEX\ (but needs frequent consulting
                   like lists; leaders could have been made a dedicated node type) \NC \NR
\NC getfield   \NC generic getter, sufficient for the rest (other field names are
                   often shared so a specific getter makes no sense then) \NC \NR
\stoptabulate

It doesn't make sense to add more. Profiling demonstrated that these fields can
get accesses way more times than other fields. Even in complex documents, many
node and fields types never get seen, or seen only a few times. Most functions in the
\type {node} namespace have a companion in \type {node.direct}, but of course not the
ones that don't deal with nodes themselves. The following table summarized this:

\start \def\yes{$+$} \def\nop{$-$}

\starttabulate[|T|c|c|]
\HL
\NC \bf function        \NC \bf node \NC \bf direct \NC \NR
\HL
\NC copy                 \NC \yes \NC \yes   \NC \NR
\NC copy_list            \NC \yes \NC \yes   \NC \NR
\NC count                \NC \yes \NC \yes   \NC \NR
\NC current_attr         \NC \yes \NC \yes   \NC \NR
\NC dimensions           \NC \yes \NC \yes   \NC \NR
\NC do_ligature_n        \NC \yes \NC \yes   \NC \NR
\NC end_of_math          \NC \yes \NC \yes   \NC \NR
\NC family_font          \NC \yes \NC \nop   \NC \NR
\NC fields               \NC \yes \NC \nop   \NC \NR
\NC first_character      \NC \yes \NC \nop   \NC \NR
\NC first_glyph          \NC \yes \NC \yes   \NC \NR
\NC flush_list           \NC \yes \NC \yes   \NC \NR
\NC flush_node           \NC \yes \NC \yes   \NC \NR
\NC free                 \NC \yes \NC \yes   \NC \NR
\NC getbox               \NC \nop \NC \yes   \NC \NR
\NC getchar              \NC \yes \NC \yes   \NC \NR
\NC getfield             \NC \yes \NC \yes   \NC \NR
\NC getfont              \NC \yes \NC \yes   \NC \NR
\NC getid                \NC \yes \NC \yes   \NC \NR
\NC getnext              \NC \yes \NC \yes   \NC \NR
\NC getprev              \NC \yes \NC \yes   \NC \NR
\NC getlist              \NC \yes \NC \yes   \NC \NR
\NC getleader            \NC \yes \NC \yes   \NC \NR
\NC getsubtype           \NC \yes \NC \yes   \NC \NR
\NC has_glyph            \NC \yes \NC \yes   \NC \NR
\NC has_attribute        \NC \yes \NC \yes   \NC \NR
\NC has_field            \NC \yes \NC \yes   \NC \NR
\NC hpack                \NC \yes \NC \yes   \NC \NR
\NC id                   \NC \yes \NC \nop   \NC \NR
\NC insert_after         \NC \yes \NC \yes   \NC \NR
\NC insert_before        \NC \yes \NC \yes   \NC \NR
\NC is_direct            \NC \nop \NC \yes   \NC \NR
\NC is_node              \NC \yes \NC \yes   \NC \NR
\NC kerning              \NC \yes \NC \nop   \NC \NR
\NC last_node            \NC \yes \NC \yes   \NC \NR
\NC length               \NC \yes \NC \yes   \NC \NR
\NC ligaturing           \NC \yes \NC \nop   \NC \NR
\NC mlist_to_hlist       \NC \yes \NC \nop   \NC \NR
\NC new                  \NC \yes \NC \yes   \NC \NR
\NC next                 \NC \yes \NC \nop   \NC \NR
\NC prev                 \NC \yes \NC \nop   \NC \NR
\NC tostring             \NC \yes \NC \yes   \NC \NR
\NC protect_glyphs       \NC \yes \NC \yes   \NC \NR
\NC protrusion_skippable \NC \yes \NC \yes   \NC \NR
\NC remove               \NC \yes \NC \yes   \NC \NR
\NC set_attribute        \NC \yes \NC \yes   \NC \NR
\NC setbox               \NC \yes \NC \yes   \NC \NR
\NC setfield             \NC \yes \NC \yes   \NC \NR
\NC slide                \NC \yes \NC \yes   \NC \NR
\NC subtype              \NC \yes \NC \nop   \NC \NR
\NC tail                 \NC \yes \NC \yes   \NC \NR
\NC todirect             \NC \yes \NC \yes   \NC \NR
\NC tonode               \NC \yes \NC \yes   \NC \NR
\NC traverse             \NC \yes \NC \yes   \NC \NR
\NC traverse_id          \NC \yes \NC \yes   \NC \NR
\NC type                 \NC \yes \NC \nop   \NC \NR
\NC types                \NC \yes \NC \nop   \NC \NR
\NC unprotect_glyphs     \NC \yes \NC \yes   \NC \NR
\NC unset_attribute      \NC \yes \NC \yes   \NC \NR
\NC usedlist             \NC \yes \NC \yes   \NC \NR
\NC vpack                \NC \yes \NC \yes   \NC \NR
\NC whatsits             \NC \yes \NC \nop   \NC \NR
\NC write                \NC \yes \NC \yes   \NC \NR
\stoptabulate

\stop

The \type {node.next} and \type {node.prev} functions will stay but for
consistency there are variants called \type {getnext}  and \type {getprev}.
We had to use \type{get} because \type {node.id} and \type {node.subtype} are
already taken for providing meta information about nodes.

\stoptext
