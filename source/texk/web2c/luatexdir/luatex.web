%  luatex.web
%
%  Copyright 2006-2009 Taco Hoekwater <taco@@luatex.org>
%  Copyright 2006-2009 Hartmut Henkel <hartmut@@luatex.org>
%
%  This file is part of LuaTeX.
%
%  LuaTeX is free software; you can redistribute it and/or modify it under
%  the terms of the GNU General Public License as published by the Free
%  Software Foundation; either version 2 of the License, or (at your
%  option) any later version.
%
%  LuaTeX is distributed in the hope that it will be useful, but WITHOUT
%  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
%  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
%  License for more details.
%
%  You should have received a copy of the GNU General Public License along
%  with LuaTeX; if not, see <http://www.gnu.org/licenses/>.
%
% $Id$

% pdfTeX is copyright (C) 1996-2006 Han The Thanh, <thanh@@pdftex.org>.
% e-TeX is copyright (C) 1994,98 by Peter Breitenlohner.

% This program is directly derived from Donald E. Knuth's TeX;
% the change history which follows and the reward offered for finders of
% bugs refer specifically to TeX; they should not be taken as referring
% to e-TeX, although the change history is relevant in that it
% demonstrates the evolutionary path followed.  This program is not TeX;
% that name is reserved strictly for the program which is the creation
% and sole responsibility of Professor Knuth.

% Version 0 was released in September 1982 after it passed a variety of tests.
% Version 1 was released in November 1983 after thorough testing.
% Version 1.1 fixed ``disappearing font identifiers'' et alia (July 1984).
% Version 1.2 allowed `0' in response to an error, et alia (October 1984).
% Version 1.3 made memory allocation more flexible and local (November 1984).
% Version 1.4 fixed accents right after line breaks, et alia (April 1985).
% Version 1.5 fixed \the\toks after other expansion in \edefs (August 1985).
% Version 2.0 (almost identical to 1.5) corresponds to "Volume B" (April 1986).
% Version 2.1 corrected anomalies in discretionary breaks (January 1987).
% Version 2.2 corrected "(Please type...)" with null \endlinechar (April 1987).
% Version 2.3 avoided incomplete page in premature termination (August 1987).
% Version 2.4 fixed \noaligned rules in indented displays (August 1987).
% Version 2.5 saved cur_order when expanding tokens (September 1987).
% Version 2.6 added 10sp slop when shipping leaders (November 1987).
% Version 2.7 improved rounding of negative-width characters (November 1987).
% Version 2.8 fixed weird bug if no \patterns are used (December 1987).
% Version 2.9 made \csname\endcsname's "relax" local (December 1987).
% Version 2.91 fixed \outer\def\a0{}\a\a bug (April 1988).
% Version 2.92 fixed \patterns, also file names with complex macros (May 1988).
% Version 2.93 fixed negative halving in allocator when mem_min<0 (June 1988).
% Version 2.94 kept open_log_file from calling fatal_error (November 1988).
% Version 2.95 solved that problem a better way (December 1988).
% Version 2.96 corrected bug in "Infinite shrinkage" recovery (January 1989).
% Version 2.97 corrected blunder in creating 2.95 (February 1989).
% Version 2.98 omitted save_for_after at outer level (March 1989).
% Version 2.99 caught $$\begingroup\halign..$$ (June 1989).
% Version 2.991 caught .5\ifdim.6... (June 1989).
% Version 2.992 introduced major changes for 8-bit extensions (September 1989).
% Version 2.993 fixed a save_stack synchronization bug et alia (December 1989).
% Version 3.0 fixed unusual displays; was more \output robust (March 1990).
% Version 3.1 fixed nullfont, disabled \write{\the\prevgraf} (September 1990).
% Version 3.14 fixed unprintable font names and corrected typos (March 1991).
% Version 3.141 more of same; reconstituted ligatures better (March 1992).
% Version 3.1415 preserved nonexplicit kerns, tidied up (February 1993).
% Version 3.14159 allowed fontmemsize to change; bulletproofing (March 1995).
% Version 3.141592 fixed \xleaders, glueset, weird alignments (December 2002).
% Version 3.1415926 was a general cleanup with minor fixes (February 2008).


% Although considerable effort has been expended to make the LuaTeX program
% correct and reliable, no warranty is implied; the authors disclaim any
% obligation or liability for damages, including but not limited to
% special, indirect, or consequential damages arising out of or in
% connection with the use or performance of this software. This work has
% been a ``labor of love'' and the authors hope that users enjoy it.

% Here is TeX material that gets inserted after \input webmac
\def\hang{\hangindent 3em\noindent\ignorespaces}
\def\hangg#1 {\hang\hbox{#1 }}
\def\textindent#1{\hangindent2.5em\noindent\hbox to2.5em{\hss#1 }\ignorespaces}
\font\ninerm=cmr9
\let\mc=\ninerm % medium caps for names like SAIL
\def\PASCAL{Pascal}
\def\pdfTeX{pdf\TeX}
\def\pdfeTeX{pdf\eTeX}
\def\PDF{PDF}
\def\Aleph{Aleph}
\def\eTeX{e\TeX}
\def\LuaTeX{Lua\TeX}
\def\THANH{H\`an Th\^e\llap{\raise 0.5ex\hbox{\'{}}} Th\`anh}
\def\ph{\hbox{Pascal-H}}
\def\pct!{{\char`\%}} % percent sign in ordinary text
\def\grp{\.{\char'173...\char'175}}
\font\logo=logo10 % font used for the METAFONT logo
\def\MF{{\logo META}\-{\logo FONT}}
\def\<#1>{$\langle#1\rangle$}
\def\section{\mathhexbox278}

\def\(#1){} % this is used to make section names sort themselves better
\def\9#1{} % this is used for sort keys in the index via @@:sort key}{entry@@>

\outer\def\N#1. \[#2]#3.{\MN#1.\vfil\eject % begin starred section
  \def\rhead{PART #2:\uppercase{#3}} % define running headline
  \message{*\modno} % progress report
  \edef\next{\write\cont{\Z{\?#2]#3}{\modno}{\the\pageno}}}\next
  \ifon\startsection{\bf\ignorespaces#3.\quad}\ignorespaces}
\let\?=\relax % we want to be able to \write a \?

\def\title{LuaTeX}
\let\maybe=\iffalse % print only changed modules
\def\topofcontents{\hsize 5.5in
  \vglue 0pt plus 1fil minus 1.5in
  \def\?##1]{\hbox to 1in{\hfil##1.\ }}
  }
\def\botofcontents{\vskip 0pt plus 1fil minus 1.5in}
\pageno=3
\def\glob{13} % this should be the section number of "<Global...>"
\def\gglob{20, 26} % this should be the next two sections of "<Global...>"

@* \[1] Introduction.

This is LuaTeX, a continuation of $\pdfTeX$ and $\Aleph$.  LuaTeX is a
document compiler intended to simplify high-quality typesetting for
many of the world's languages.  It is an extension of D. E. Knuth's
\TeX, which was designed essentially for the typesetting of languages
using the Latin alphabet.

The $\Aleph$ subsystem loosens many of the restrictions imposed by~\TeX:
register numbers are no longer limited to 8~bits;  fonts may have more
than 256~characters;  more than 256~fonts may be used;  etc.

The \PASCAL\ program that follows is the definition of \TeX82, a standard
@:PASCAL}{\PASCAL@>
@!@:TeX82}{\TeX82@>
version of \TeX\ that is designed to be highly portable so that
identical output will be obtainable on a great variety of computers.

The main purpose of the following program is to explain the algorithms of \TeX\
as clearly as possible. As a result, the program will not necessarily be very
efficient when a particular \PASCAL\ compiler has translated it into a
particular machine language. However, the program has been written so that it
can be tuned to run efficiently in a wide variety of operating environments
by making comparatively few changes. Such flexibility is possible because
the documentation that follows is written in the \.{WEB} language, which is
at a higher level than \PASCAL; the preprocessing step that converts \.{WEB}
to \PASCAL\ is able to introduce most of the necessary refinements.
Semi-automatic translation to other languages is also feasible, because the
program below does not make extensive use of features that are peculiar to
\PASCAL.

A large piece of software like \TeX\ has inherent complexity that cannot
be reduced below a certain level of difficulty, although each individual
part is fairly simple by itself. The \.{WEB} language is intended to make
the algorithms as readable as possible, by reflecting the way the
individual program pieces fit together and by providing the
cross-references that connect different parts. Detailed comments about
what is going on, and about why things were done in certain ways, have
been liberally sprinkled throughout the program.  These comments explain
features of the implementation, but they rarely attempt to explain the
\TeX\ language itself, since the reader is supposed to be familiar with
{\sl The \TeX book}.
@.WEB@>
@:TeXbook}{\sl The \TeX book@>

@ The present implementation has a long ancestry, beginning in the summer
of~1977, when Michael~F. Plass and Frank~M. Liang designed and coded
a prototype
@^Plass, Michael Frederick@>
@^Liang, Franklin Mark@>
@^Knuth, Donald Ervin@>
based on some specifications that the author had made in May of that year.
This original proto\TeX\ included macro definitions and elementary
manipulations on boxes and glue, but it did not have line-breaking,
page-breaking, mathematical formulas, alignment routines, error recovery,
or the present semantic nest; furthermore,
it used character lists instead of token lists, so that a control sequence
like \.{\\halign} was represented by a list of seven characters. A
complete version of \TeX\ was designed and coded by the author in late
1977 and early 1978; that program, like its prototype, was written in the
{\mc SAIL} language, for which an excellent debugging system was
available. Preliminary plans to convert the {\mc SAIL} code into a form
somewhat like the present ``web'' were developed by Luis Trabb~Pardo and
@^Trabb Pardo, Luis Isidoro@>
the author at the beginning of 1979, and a complete implementation was
created by Ignacio~A. Zabala in 1979 and 1980. The \TeX82 program, which
@^Zabala Salelles, Ignacio Andr\'es@>
was written by the author during the latter part of 1981 and the early
part of 1982, also incorporates ideas from the 1979 implementation of
@^Guibas, Leonidas Ioannis@>
@^Sedgewick, Robert@>
@^Wyatt, Douglas Kirk@>
\TeX\ in {\mc MESA} that was written by Leonidas Guibas, Robert Sedgewick,
and Douglas Wyatt at the Xerox Palo Alto Research Center.  Several hundred
refinements were introduced into \TeX82 based on the experiences gained with
the original implementations, so that essentially every part of the system
has been substantially improved. After the appearance of ``Version 0'' in
September 1982, this program benefited greatly from the comments of
many other people, notably David~R. Fuchs and Howard~W. Trickey.
A final revision in September 1989 extended the input character set to
eight-bit codes and introduced the ability to hyphenate words from
different languages, based on some ideas of Michael~J. Ferguson.
@^Fuchs, David Raymond@>
@^Trickey, Howard Wellington@>
@^Ferguson, Michael John@>

No doubt there still is plenty of room for improvement, but the author
is firmly committed to keeping \TeX82 ``frozen'' from now on; stability
and reliability are to be its main virtues.

On the other hand, the \.{WEB} description can be extended without changing
the core of \TeX82 itself, and the program has been designed so that such
extensions are not extremely difficult to make.
The |banner| string defined here should be changed whenever \TeX\
undergoes any modifications, so that it will be clear which version of
\TeX\ might be the guilty party when a problem arises.
@^extensions to \TeX@>
@^system dependencies@>

This program contains code for various features extending \TeX,
therefore this program is called `\eTeX' and not
`\TeX'; the official name `\TeX' by itself is reserved
for software systems that are fully compatible with each other.
A special test suite called the ``\.{TRIP} test'' is available for
helping to determine whether a particular implementation deserves to be
known as `\TeX' [cf.~Stanford Computer Science report CS1027,
November 1984].

A similar test suite called the ``\.{e-TRIP} test'' is available for
helping to determine whether a particular implementation deserves to be
known as `\eTeX'.

@d eTeX_version_string=="2.2" {current \eTeX\ version}
@d Omega_version_string=="1.15" { \.{\\OmegaVersion} }
@d Aleph_version_string=="0.0" { \.{\\AlephVersion} }
@d eTeX_version=2 { \.{\\eTeXversion} }
@d Omega_version=1 { \.{\\Omegaversion} }
@d Aleph_version=0 { \.{\\Alephversion} }
@d eTeX_minor_version=1 { \.{\\eTeXminorversion} }
@d Omega_minor_version=15 { \.{\\Omegaminorversion} }
@d Aleph_minor_version=0 { \.{\\Alephminorversion} }
@d eTeX_revision==".2" { \.{\\eTeXrevision} }
@d Omega_revision==".15" { \.{\\Omegarevision} }
@d Aleph_revision==".0" { \.{\\Alephrevision} }
@#
@d pdftex_version==200 { \.{\\pdftexversion} }
@d pdftex_revision=="0" { \.{\\pdftexrevision} }
@d pdftex_version_string=='-2.00.0' {current \pdfTeX\ version}
@#
@d luatex_version==41 { \.{\\luatexversion} }
@d luatex_revision=="0" { \.{\\luatexrevision} }
@d luatex_date_info==-extra_version_info { the compile date is negated }

@ Different \PASCAL s have slightly different conventions, and the present
@!@:PASCAL H}{\ph@>
program expresses \TeX\ in terms of the \PASCAL\ that was
available to the author in 1982. Constructions that apply to
this particular compiler, which we shall call \ph, should help the
reader see how to make an appropriate interface for other systems
if necessary. (\ph\ is Charles Hedrick's modification of a compiler
@^Hedrick, Charles Locke@>
for the DECsystem-10 that was originally developed at the University of
Hamburg; cf.\ {\sl SOFTWARE---Practice \AM\ Experience \bf6} (1976),
29--42. The \TeX\ program below is intended to be adaptable, without
extensive changes, to most other versions of \PASCAL, so it does not fully
use the admirable features of \ph. Indeed, a conscious effort has been
made here to avoid using several idiosyncratic features of standard
\PASCAL\ itself, so that most of the code can be translated mechanically
into other high-level languages. For example, the `\&{with}' and `\\{new}'
features are not used, nor are pointer types, set types, or enumerated
scalar types; there are no `\&{var}' parameters, except in the case of files
--- \eTeX, however, does use `\&{var}' parameters for the |reverse| function;
there are no tag fields on variant records; there are no assignments
|real:=integer|; no procedures are declared local to other procedures.)

The portions of this program that involve system-dependent code, where
changes might be necessary because of differences between \PASCAL\ compilers
and/or differences between
operating systems, can be identified by looking at the sections whose
numbers are listed under `system dependencies' in the index. Furthermore,
the index entries for `dirty \PASCAL' list all places where the restrictions
of \PASCAL\ have not been followed perfectly, for one reason or another.
@!@^system dependencies@>
@!@^dirty \PASCAL@>

Incidentally, \PASCAL's standard |round| function can be problematical,
because it disagrees with the IEEE floating-point standard.
Many implementors have
therefore chosen to substitute their own home-grown rounding procedure.

@ The program begins with a normal \PASCAL\ program heading, whose
components will be filled in later, using the conventions of \.{WEB}.
@.WEB@>
For example, the portion of the program called `\X\glob:Global
variables\X' below will be replaced by a sequence of variable declarations
that starts in $\section\glob$ of this documentation. In this way, we are able
to define each individual global variable when we are prepared to
understand what it means; we do not have to define all of the globals at
once.  Cross references in $\section\glob$, where it says ``See also
sections \gglob, \dots,'' also make it possible to look at the set of
all global variables, if desired.  Similar remarks apply to the other
portions of the program heading.

Actually the heading shown here is not quite normal: The |program| line
does not mention any |output| file, because \ph\ would ask the \TeX\ user
to specify a file name if |output| were specified here.
@:PASCAL H}{\ph@>
@^system dependencies@>

@d mtype==t@&y@&p@&e {this is a \.{WEB} coding trick:}
@f mtype==type {`\&{mtype}' will be equivalent to `\&{type}'}
@f type==true {but `|type|' will not be treated as a reserved word}

@p @t\4@>@<Compiler directives@>@/
program TEX; {all file names are defined dynamically}
label @<Labels in the outer block@>@/
const @<Constants in the outer block@>@/
mtype @<Types in the outer block@>@/
var @<Global variables@>@/
@#
procedure initialize; {this procedure gets things started properly}
  var @<Local variables for initialization@>@/
  begin @<Initialize whatever \TeX\ might access@>@;
  end;@#
@t\4@>@<Basic printing procedures@>@/

@ Here is a workaround for the unfortunate limitation of WEB2C that
doesn't know how to deal with symbolic case labels.

@d hlist_node_case==0
@d vlist_node_case==1
@d rule_node_case==2
@d ins_node_case==3
@d mark_node_case==4
@d adjust_node_case==5
@d disc_node_case==7
@d whatsit_node_case==8
@d math_node_case==9
@d glue_node_case==10
@d kern_node_case==11
@d penalty_node_case==12
@d unset_node_case==13
@d margin_kern_node_case==36

@<Initialize whatever \TeX\ might access@>=
pdfassert(hlist_node_case=hlist_node);
pdfassert(vlist_node_case=vlist_node);
pdfassert(rule_node_case=rule_node);
pdfassert(ins_node_case=ins_node);
pdfassert(mark_node_case=mark_node);
pdfassert(adjust_node_case=adjust_node);
pdfassert(disc_node_case=disc_node);
pdfassert(whatsit_node_case=whatsit_node);
pdfassert(math_node_case=math_node);
pdfassert(glue_node_case=glue_node);
pdfassert(kern_node_case=kern_node);
pdfassert(penalty_node_case=penalty_node);
pdfassert(unset_node_case=unset_node);
pdfassert(margin_kern_node_case=margin_kern_node);





@ The overall \TeX\ program begins with the heading just shown, after which
comes a bunch of procedure declarations and function declarations.
Finally we will get to the main program, which begins with the
comment `|start_here|'. If you want to skip down to the
main program now, you can look up `|start_here|' in the index.
But the author suggests that the best way to understand this program
is to follow pretty much the order of \TeX's components as they appear in the
\.{WEB} description you are now reading, since the present ordering is
intended to combine the advantages of the ``bottom up'' and ``top down''
approaches to the problem of understanding a somewhat complicated system.

@ Three labels must be declared in the main program, so we give them
symbolic names.

@d start_of_TEX=1 {go here when \TeX's variables are initialized}
@d end_of_TEX=9998 {go here to close files and terminate gracefully}
@d final_end=9999 {this label marks the ending of the program}

@<Labels in the out...@>=
start_of_TEX@t\hskip-2pt@>, end_of_TEX@t\hskip-2pt@>,@,final_end;
  {key control points}

@ Some of the code below is intended to be used only when diagnosing the
strange behavior that sometimes occurs when \TeX\ is being installed or
when system wizards are fooling around with \TeX\ without quite knowing
what they are doing. Such code will not normally be compiled; it is
delimited by the codewords `$|debug|\ldots|gubed|$', with apologies
to people who wish to preserve the purity of English.

Similarly, there is some conditional code delimited by
`$|stat|\ldots|tats|$' that is intended for use when statistics are to be
kept about \TeX's memory usage.  The |stat| $\ldots$ |tats| code also
implements diagnostic information for \.{\\tracingparagraphs} and
\.{\\tracingpages}.
@^debugging@>

@d debug==@{ {change this to `$\\{debug}\equiv\null$' when debugging}
@d gubed==@t@>@} {change this to `$\\{gubed}\equiv\null$' when debugging}
@f debug==begin
@f gubed==end
@#
@d stat==@{ {change this to `$\\{stat}\equiv\null$' when gathering
  usage statistics}
@d tats==@t@>@} {change this to `$\\{tats}\equiv\null$' when gathering
  usage statistics}
@f stat==begin
@f tats==end

@ This program has two important variations: (1) There is a long and slow
version called \.{INITEX}, which does the extra calculations needed to
@.INITEX@>
initialize \TeX's internal tables; and (2)~there is a shorter and faster
production version, which cuts the initialization to a bare minimum.
Parts of the program that are needed in (1) but not in (2) are delimited by
the codewords `$|init|\ldots|tini|$'.

@d init== {change this to `$\\{init}\equiv\.{@@\{}$' in the production version}
@d tini== {change this to `$\\{tini}\equiv\.{@@\}}$' in the production version}
@f init==begin
@f tini==end

@<Initialize whatever...@>=
@<Set initial values of key variables@>@/
@!init @<Initialize table entries (done by \.{INITEX} only)@>@;@+tini

@ If the first character of a \PASCAL\ comment is a dollar sign,
\ph\ treats the comment as a list of ``compiler directives'' that will
affect the translation of this program into machine language.  The
directives shown below specify full checking and inclusion of the \PASCAL\
debugger when \TeX\ is being debugged, but they cause range checking and other
redundant code to be eliminated when the production system is being generated.
Arithmetic overflow will be detected in all cases.
@:PASCAL H}{\ph@>
@^system dependencies@>
@^overflow in arithmetic@>

@<Compiler directives@>=
@{@&$C-,A+,D-@} {no range check, catch arithmetic overflow, no debug overhead}
@!debug @{@&$C+,D+@}@+ gubed {but turn everything on when debugging}

@ This \TeX\ implementation conforms to the rules of the {\sl Pascal User
@:PASCAL}{\PASCAL@>
@^system dependencies@>
Manual} published by Jensen and Wirth in 1975, except where system-dependent
@^Wirth, Niklaus@>
@^Jensen, Kathleen@>
code is necessary to make a useful system program, and except in another
respect where such conformity would unnecessarily obscure the meaning
and clutter up the code: We assume that |case| statements may include a
default case that applies if no matching label is found. Thus, we shall use
constructions like
$$\vbox{\halign{\ignorespaces#\hfil\cr
|case x of|\cr
1: $\langle\,$code for $x=1\,\rangle$;\cr
3: $\langle\,$code for $x=3\,\rangle$;\cr
|othercases| $\langle\,$code for |x<>1| and |x<>3|$\,\rangle$\cr
|endcases|\cr}}$$
since most \PASCAL\ compilers have plugged this hole in the language by
incorporating some sort of default mechanism. For example, the \ph\
compiler allows `|others|:' as a default label, and other \PASCAL s allow
syntaxes like `\&{else}' or `\&{otherwise}' or `\\{otherwise}:', etc. The
definitions of |othercases| and |endcases| should be changed to agree with
local conventions.  Note that no semicolon appears before |endcases| in
this program, so the definition of |endcases| should include a semicolon
if the compiler wants one. (Of course, if no default mechanism is
available, the |case| statements of \TeX\ will have to be laboriously
extended by listing all remaining cases. People who are stuck with such
\PASCAL s have, in fact, done this, successfully but not happily!)
@:PASCAL H}{\ph@>

@d othercases == others: {default for cases not listed explicitly}
@d endcases == @+end {follows the default case in an extended |case| statement}
@f othercases == else
@f endcases == end

@ The following parameters can be changed at compile time to extend or
reduce \TeX's capacity. They may have different values in \.{INITEX} and
in production versions of \TeX.
@.INITEX@>
@^system dependencies@>

@<Constants...@>=
@!buf_size=500; {maximum number of characters simultaneously present in
  current lines of open files and in control sequences between
  \.{\\csname} and \.{\\endcsname}; must not exceed |max_halfword|}
@!error_line=72; {width of context lines on terminal error messages}
@!half_error_line=42; {width of first lines of contexts in terminal
  error messages; should be between 30 and |error_line-15|}
@!max_print_line=79; {width of longest text lines output; should be at least 60}
@!stack_size=200; {maximum number of simultaneous input sources}
@!max_in_open=6; {maximum number of input files and error insertions that
  can be going on simultaneously}
@!param_size=60; {maximum number of simultaneous macro parameters}
@!nest_size=40; {maximum number of semantic levels simultaneously active}
@!max_strings=3000; {maximum number of strings; must not exceed |max_halfword|}
@!string_vacancies=8000; {the minimum number of characters that should be
  available for the user's control sequences and font names,
  after \TeX's own error messages are stored}
@!pool_size=32000; {maximum number of characters in strings, including all
  error messages and help texts, and the names of all fonts and
  control sequences; must exceed |string_vacancies| by the total
  length of \TeX's own strings, which is currently about 23000}
@!save_size=600; {space for saving values outside of current group; must be
  at most |max_halfword|}
@!dvi_buf_size=800; {size of the output buffer; must be a multiple of 8}
@!expand_depth=10000; {limits recursive calls of the |expand| procedure}
@!pool_name='TeXformats:TEX.POOL                     ';
  {string of length |file_name_size|; tells where the string pool appears}
@.TeXformats@>
@!luatex_version_string='beta-0.41.0';


@ Like the preceding parameters, the following quantities can be changed
at compile time to extend or reduce \TeX's capacity. But if they are changed,
it is necessary to rerun the initialization program \.{INITEX}
@.INITEX@>
to generate new tables for the production \TeX\ program.
One can't simply make helter-skelter changes to the following constants,
since certain rather complex initialization
numbers are computed from them. They are defined here using
\.{WEB} macros, instead of being put into \PASCAL's |const| list, in order to
emphasize this distinction.

@d font_base=0 {smallest internal font number; must not be less
  than |min_quarterword|}
@d hash_size=65536 {maximum number of control sequences; it should be at most
  about |(fix_mem_max-fix_mem_min)/10|}
@d ocp_base=0 
@d number_ocps=32768
@d ocp_list_base=0
@d number_ocp_lists=32768
@d max_active_ocp_lists=32768
@d biggest_reg=65535 {the largest allowed register number; must be |<=max_quarterword|}
@d number_regs=65536 {|biggest_reg+1|}
@d number_attrs=65536 {total numbeer of attributes}
@d biggest_char=1114111 {2097151} {the largest allowed character number; must be |<=max_halfword|}
@d too_big_char=1114112 {2097152} {|biggest_char+1|}
@d special_char=1114113 {2097153} {|biggest_char+2|}
@d number_chars=1114112 {2097152} {|biggest_char+1|}
@d string_offset=2097152
@d number_fonts=5535-font_base+1
@d biggest_lang=32767
@d too_big_lang=32768
@d text_size=0 {size code for the largest size in a family}
@d script_size=1 {size code for the medium size in a family}
@d script_script_size=2 {size code for the smallest size in a family}


@ In case somebody has inadvertently made bad settings of the ``constants,''
\TeX\ checks them using a global variable called |bad|.

This is the first of many sections of \TeX\ where global variables are
defined.

@<Glob...@>=
@!bad:integer; {is some ``constant'' wrong?}
@!luainit:boolean; {are we using lua for initializations }
@!tracefilenames:boolean; { print file open-close  info? }

@ Later on we will say `\ignorespaces|if X>=max_halfword then bad:=14|',
or something similar. (We can't do that until |max_halfword| has been defined.)

@<Check the ``constant'' values for consistency@>=
bad:=0;
if not luainit then  tracefilenames:=true;
if (half_error_line<30)or(half_error_line>error_line-15) then bad:=1;
if max_print_line<60 then bad:=2;
if dvi_buf_size mod 8<>0 then bad:=3;
if hash_prime>hash_size then bad:=5;
if max_in_open>=128 then bad:=6;
{ |if null_list<256 then bad:=7;| } {we will want |null_list>255|}

@ Labels are given symbolic names by the following definitions, so that
occasional |goto| statements will be meaningful. We insert the label
`|exit|' just before the `\ignorespaces|end|\unskip' of a procedure in
which we have used the `|return|' statement defined below; the label
`|restart|' is occasionally used at the very beginning of a procedure; and
the label `|reswitch|' is occasionally used just prior to a |case|
statement in which some cases change the conditions and we wish to branch
to the newly applicable case.  Loops that are set up with the |loop|
construction defined below are commonly exited by going to `|done|' or to
`|found|' or to `|not_found|', and they are sometimes repeated by going to
`|continue|'.  If two or more parts of a subroutine start differently but
end up the same, the shared code may be gathered together at
`|common_ending|'.

Incidentally, this program never declares a label that isn't actually used,
because some fussy \PASCAL\ compilers will complain about redundant labels.

@d exit=10 {go here to leave a procedure}
@d restart=20 {go here to start a procedure again}
@d reswitch=21 {go here to start a case statement again}
@d continue=22 {go here to resume a loop}
@d done=30 {go here to exit a loop}
@d done1=31 {like |done|, when there is more than one loop}
@d done2=32 {for exiting the second loop in a long block}
@d done3=33 {for exiting the third loop in a very long block}
@d done4=34 {for exiting the fourth loop in an extremely long block}
@d done5=35 {for exiting the fifth loop in an immense block}
@d done6=36 {for exiting the sixth loop in a block}
@d found=40 {go here when you've found it}
@d found1=41 {like |found|, when there's more than one per routine}
@d found2=42 {like |found|, when there's more than two per routine}
@d not_found=45 {go here when you've found nothing}
@d not_found1=46 {like |not_found|, when there's more than one}
@d not_found2=47 {like |not_found|, when there's more than two}
@d not_found3=48 {like |not_found|, when there's more than three}
@d not_found4=49 {like |not_found|, when there's more than four}
@d common_ending=50 {go here when you want to merge with another branch}

@ Here are some macros for common programming idioms.

@d loop == @+ while true do@+ {repeat over and over until a |goto| happens}
@f loop == xclause
  {\.{WEB}'s |xclause| acts like `\ignorespaces|while true do|\unskip'}
@d do_nothing == pdfassert(1) {empty statement}
@d return == goto exit {terminate a procedure call}
@f return == nil
@d empty=0 {symbolic name for a null constant}

@* \[2] The character set.
In order to make \TeX\ readily portable to a wide variety of
computers, all of its input text is converted to an internal
twenty-one-bit code that covers all of unicode, including ASCII, the
``American Standard Code for Information Interchange.''  This
conversion is done immediately when each character is read
in. Conversely, characters are converted from ASCII to the user's
external representation just before they are output to a text file.

Such an internal code is relevant to users of \TeX\ primarily because it
governs the positions of characters in the fonts. For example, the
character `\.A' has ASCII code $65=@'101$, and when \TeX\ typesets
this letter it specifies character number 65 in the current font.
If that font actually has `\.A' in a different position, \TeX\ doesn't
know what the real position is; the program that does the actual printing from
\TeX's device-independent files is responsible for converting from ASCII to
a particular font encoding.
@^ASCII code@>

\TeX's internal code also defines the value of constants
that begin with a reverse apostrophe; and it provides an index to the
\.{\\catcode}, \.{\\mathcode}, \.{\\uccode}, \.{\\lccode}, and \.{\\delcode}
tables.

@ Characters of text that have been converted to \TeX's internal form
are said to be of type |ASCII_code|, which is a subrange of the integers.

@<Types...@>=
@!ASCII_code=0..biggest_char; {eight-bit numbers}

@ The original \PASCAL\ compiler was designed in the late 60s, when six-bit
character sets were common, so it did not make provision for lowercase
letters. Nowadays, of course, we need to deal with both capital and small
letters in a convenient way, especially in a program for typesetting;
so the present specification of \TeX\ has been written under the assumption
that the \PASCAL\ compiler and run-time system permit the use of text files
with more than 64 distinguishable characters. More precisely, we assume that
the character set contains at least the letters and symbols associated
with ASCII codes @'40 through @'176; all of these characters are now
available on most computer terminals.

Since we are dealing with more characters than were present in the first
\PASCAL\ compilers, we have to decide what to call the associated data
type. Some \PASCAL s use the original name |char| for the
characters in text files, even though there now are more than 64 such
characters, while other \PASCAL s consider |char| to be a 64-element
subrange of a larger data type that has some other name.

In order to accommodate this difference, we shall use the name |text_char|
to stand for the data type of the characters that are converted to and
from |ASCII_code| when they are input and output. We shall also assume
that |text_char| consists of the elements |chr(first_text_char)| through
|chr(last_text_char)|, inclusive. The following definitions should be
adjusted if necessary.
@^system dependencies@>

@d text_char == char {the data type of characters in text files}
@d first_text_char=0 {ordinal number of the smallest element of |text_char|}
@d last_text_char=255 {ordinal number of the largest element of |text_char|}

@ We are assuming that our runtime system is able to read and write UTF-8. 

@ Some of the ASCII codes without visible characters have been given symbolic
names in this program because they are used with a special meaning.

@d null_code=@'0 {ASCII code that might disappear}
@d carriage_return=@'15 {ASCII code used at end of line}
@d invalid_code=@'177 {ASCII code that many systems prohibit in text files}

@ The ASCII code is ``standard'' only to a certain extent, since many
computer installations have found it advantageous to have ready access
to more than 94 printing characters. Appendix~C of {\sl The \TeX book\/}
gives a complete specification of the intended correspondence between
characters and \TeX's internal representation.
@:TeXbook}{\sl The \TeX book@>

@* \[3] Input and output.

@ Typedefs have to be here to avoid errors after tangling

@<Types...@>=
@!eight_bits=0..255; {unsigned one-byte quantity}
@!alpha_file=packed file of text_char; {files that contain textual data}
@!byte_file=packed file of eight_bits; {files that contain binary data}

@ @<Glob...@>=
@!init
@!ini_version:boolean; {are we \.{INITEX}?}
@!dump_option:boolean; {was the dump name option used?}
@!dump_line:boolean; {was a \.{\%\AM format} line seen?}
tini@/
@#
@!bound_default:integer; {temporary for setup}
@!bound_name:^char; {temporary for setup}
@#
@!error_line:integer; {width of context lines on terminal error messages}
@!half_error_line:integer; {width of first lines of contexts in terminal
  error messages; should be between 30 and |error_line-15|}
@!max_print_line:integer;
  {width of longest text lines output; should be at least 60}
@!ocp_list_size:integer;
@!ocp_buf_size:integer;
@!ocp_stack_size:integer;
@!max_strings:integer; {maximum number of strings; must not exceed |max_halfword|}
@!strings_free:integer; {strings available after format loaded}
@!string_vacancies:integer; {the minimum number of characters that should be
  available for the user's control sequences and font names,
  after \TeX's own error messages are stored}
@!pool_size:integer; {maximum number of characters in strings, including all
  error messages and help texts, and the names of all fonts and
  control sequences; must exceed |string_vacancies| by the total
  length of \TeX's own strings, which is currently about 23000}
@!pool_free:integer;{pool space free after format loaded}
@!font_k:integer; {loop variable for initialization}
@!buf_size:integer; {maximum number of characters simultaneously present in
  current lines of open files and in control sequences between
  \.{\\csname} and \.{\\endcsname}; must not exceed |max_halfword|}
@!stack_size:integer; {maximum number of simultaneous input sources}
@!max_in_open:integer; {maximum number of input files and error insertions that
  can be going on simultaneously}
@!param_size:integer; {maximum number of simultaneous macro parameters}
@!nest_size:integer; {maximum number of semantic levels simultaneously active}
@!save_size:integer; {space for saving values outside of current group; must be
  at most |max_halfword|}
@!expand_depth:integer; {limits recursive calls of the |expand| procedure}
@!parsefirstlinep:cinttype; {parse the first line for options}
@!filelineerrorstylep:cinttype; {format messages as file:line:error}
@!haltonerrorp:cinttype; {stop at first error}
@!quoted_filename:boolean; {current filename is quoted}

@* \[4] String handling.

The string processing is in C, but the typedefs have to be here
because they are used by function arguments.

@d length == str_length

@<Types...@>=
str_number = integer; 
pool_pointer = integer; 
packed_ASCII_code = 0..255;


@* \[5] On-line and off-line printing.


@* \[6] Reporting errors.

@ @<Set init...@>=
initialize_errors;

@ @<Global...@>=
@!static_int_base:integer; {C version of |int_base|}
@!static_glue_base:integer; {C version of |glue_base|}
@!static_dimen_base:integer; {C version of |dimen_base|}
@!static_local_base:integer; {C version of |local_base|}

@* \[7] Arithmetic with scaled dimensions.

@ As before, somes types have to remain here in the pascal for now.

@<Types...@>=
@!scaled = integer; {this type is used for scaled integers}
@!small_number=0..63; {this type is self-explanatory}

@ @<Types...@>=
@!glue_ratio=real; {one-word representation of a glue expansion factor}

@* \[7b] Random numbers.

@ @<Set init...@>=
initialize_arithmetic;


@* \[8] Packed data.
In order to make efficient use of storage space, \TeX\ bases its major data
structures on a |memory_word|, which contains either a (signed) integer,
possibly scaled, or a (signed) |glue_ratio|, or a small number of
fields that are one half or one quarter of the size used for storing
integers.

If |x| is a variable of type |memory_word|, it contains up to four
fields that can be referred to as follows:
$$\vbox{\halign{\hfil#&#\hfil&#\hfil\cr
|x|&.|int|&(an |integer|)\cr
|x|&.|sc|\qquad&(a |scaled| integer)\cr
|x|&.|gr|&(a |glue_ratio|)\cr
|x.hh.lh|, |x.hh|&.|rh|&(two halfword fields)\cr
|x.hh.b0|, |x.hh.b1|, |x.hh|&.|rh|&(two quarterword fields, one halfword
  field)\cr
|x.qqqq.b0|, |x.qqqq.b1|, |x.qqqq|&.|b2|, |x.qqqq.b3|\hskip-100pt
  &\qquad\qquad\qquad(four quarterword fields)\cr}}$$
This is somewhat cumbersome to write, and not very readable either, but
macros will be used to make the notation shorter and more transparent.
The \PASCAL\ code below gives a formal definition of |memory_word| and
its subsidiary types, using packed variant records. \TeX\ makes no
assumptions about the relative positions of the fields within a word.

We are assuming 32-bit integers, a halfword must contain at least
32 bits, and a quarterword must contain at least 16 bits.
@^system dependencies@>

N.B.: Valuable memory space will be dreadfully wasted unless \TeX\ is compiled
by a \PASCAL\ that packs all of the |memory_word| variants into
the space of a single integer. This means, for example, that |glue_ratio|
words should be |short_real| instead of |real| on some computers. Some
\PASCAL\ compilers will pack an integer whose subrange is `|0..255|' into
an eight-bit field, but others insist on allocating space for an additional
sign bit; on such systems you can get 256 values into a quarterword only
if the subrange is `|-128..127|'.

The present implementation tries to accommodate as many variations as possible,
so it makes few assumptions. If integers having the subrange
`|min_quarterword..max_quarterword|' can be packed into a quarterword,
and if integers having the subrange `|min_halfword..max_halfword|'
can be packed into a halfword, everything should work satisfactorily.

It is usually most efficient to have |min_quarterword=min_halfword=0|,
so one should try to achieve this unless it causes a severe problem.
The values defined here are recommended for most 32-bit computers.

We cannot use the full range of 32 bits in a halfword, because we have
to allow negative values for potential backend tricks like web2c's
dynamic allocation, and parshapes pointers have to be able to store at
least twice the value |max_halfword| (see below). Therefore,
|max_halfword| is $2^{30}-1$

@d min_quarterword=0 {smallest allowable value in a |quarterword|}
@d max_quarterword=65535 {largest allowable value in a |quarterword|}
@d min_halfword==-@"3FFFFFFF {smallest allowable value in a |halfword|}
@d max_halfword==@"3FFFFFFF {largest allowable value in a |halfword|}

@ Here are the inequalities that the quarterword and halfword values
must satisfy (or rather, the inequalities that they mustn't satisfy):

@<Check the ``constant''...@>=
if (min_quarterword>0)or(max_quarterword<@"7FFF) then bad:=11;
if (min_halfword>0)or(max_halfword<@"3FFFFFFF) then bad:=12;
if (min_quarterword<min_halfword)or@|
  (max_quarterword>max_halfword) then bad:=13;
if font_base<min_quarterword then bad:=15;
if (save_size>max_halfword)or(max_strings>max_halfword) then bad:=17;
if buf_size>max_halfword then bad:=18;
if max_quarterword-min_quarterword<@"FFFF then bad:=19;

@ The operation of adding or subtracting |min_quarterword| occurs quite
frequently in \TeX, so it is convenient to abbreviate this operation
by using the macros |qi| and |qo| for input and output to and from
quarterword format.

The inner loop of \TeX\ will run faster with respect to compilers
that don't optimize expressions like `|x+0|' and `|x-0|', if these
macros are simplified in the obvious way when |min_quarterword=0|.
So they have been simplified here in the obvious way.
@^inner loop@>@^system dependencies@>

@d qi(#)==# {to put an |eight_bits| item into a quarterword}
@d qo(#)==# {to take an |eight_bits| item from a quarterword}
@d hi(#)==# {to put a sixteen-bit item into a halfword}
@d ho(#)==# {to take a sixteen-bit item from a halfword}

@ The reader should study the following definitions closely:
@^system dependencies@>

@d sc==int {|scaled| data is equivalent to |integer|}

@<Types...@>=
@!quarterword = min_quarterword..max_quarterword;
@!halfword = min_halfword..max_halfword;
@=#include "tex/memoryword.h";@>

@* \[9] Dynamic memory allocation.

@ 
@d pointer==halfword {a flag or a location in |mem| or |eqtb|}
@d null==0 {the null pointer}
@d link == token_link {the |link| field of a memory word}
@d info == token_info {the |info| field of a memory word}

@ The available-space list that keeps track of the variable-size portion
of |mem| is a nonempty, doubly-linked circular list of empty nodes,
pointed to by the roving pointer |rover|.

@d vmem(#) == varmem[#]
@d vlink(#) == vmem(#).hh.rh {the |link| field of a memory word}
@d vinfo(#) == vmem(#).hh.lh {the |info| field of a memory word}
@d alink(#) == vlink(#+1) {backlink in doubly-linked list of empty nodes}

@ @<Glob...@>=
var_used:halfword;
temp_ptr:pointer; {a pointer variable for occasional emergency use}

@* \[10] Data structures for boxes and their friends.
From the computer's standpoint, \TeX's chief mission is to create
horizontal and vertical lists. We shall now investigate how the elements
of these lists are represented internally as nodes in the dynamic memory.

A horizontal or vertical list is linked together by |link| fields in
the first word of each node. Individual nodes represent boxes, glue,
penalties, or special things like discretionary hyphens; because of this
variety, some nodes are longer than others, and we must distinguish different
kinds of nodes. We do this by putting a `|type|' field in the first word,
together with the link and an optional `|subtype|'.

@d type(#)    == vmem(#).hh.b0  {identifies what kind of node this is}
@d subtype(#) == vmem(#).hh.b1 {secondary identification in some cases}

@ TH: This module section is superceded.

A |@!char_node|, which represents a single character, is the most important
kind of node because it accounts for the vast majority of all boxes.
Special precautions are therefore taken to ensure that a |char_node| does
not take up much memory space. Every such node is one word long, and in fact
it is identifiable by this property, since other kinds of nodes have at least
two words, and they appear in |mem| locations less than |hi_mem_min|.
This makes it possible to omit the |type| field in a |char_node|, leaving
us room for two bytes that identify a |font| and a |character| within
that font.

Note that the format of a |char_node| allows for up to 256 different
fonts and up to 256 characters per font; but most implementations will
probably limit the total number of fonts to fewer than 75 per job,
and most fonts will stick to characters whose codes are
less than 128 (since higher codes
are more difficult to access on most keyboards).

Extensions of \TeX\ intended for oriental languages will need even more
than $256\times256$ possible characters, when we consider different sizes
@^oriental characters@>@^Chinese characters@>@^Japanese characters@>
and styles of type.  It is suggested that Chinese and Japanese fonts be
handled by representing such characters in two consecutive |char_node|
entries: The first of these has |font=font_base|, and its |link| points
to the second;
the second identifies the font and the character dimensions.
The saving feature about oriental characters is that most of them have
the same box dimensions. The |character| field of the first |char_node|
is a ``\\{charext}'' that distinguishes between graphic symbols whose
dimensions are identical for typesetting purposes. (See the \MF\ manual.)
Such an extension of \TeX\ would not be difficult; further details are
left to the reader.

In order to make sure that the |character| code fits in a quarterword,
\TeX\ adds the quantity |min_quarterword| to the actual code.

Character nodes appear only in horizontal lists, never in vertical lists.

@ Attribute lists need two extra globals to increase processing efficiency.
|max_used_attr| limits the test loop that checks for set attributes, and
|attr_list_cache| contains a pointer to an already created attribute list.  It is
set to the special value |cache_disabled| when the current value can no longer be
trusted: after an assignment to an attribute register, and after a group has
ended.

@d cache_disabled==max_halfword

@<Glob...@>=
max_used_attr:integer; { maximum assigned attribute id }
attr_list_cache:pointer;

@ @<Set init...@>=
max_used_attr:=-1; attr_list_cache:=cache_disabled;

@ Attribute lists are maintained in C, but they need access to the current
attributes in eqtb.

@p function get_attribute(i:halfword):halfword;
begin
  get_attribute := attribute(i);
end;


@ An |hlist_node| stands for a box that was made from a horizontal list.
Each |hlist_node| is seven words long, and contains the following fields
(in addition to the mandatory |type| and |link|, which we shall not
mention explicitly when discussing the other node types): The |height| and
|width| and |depth| are scaled integers denoting the dimensions of the
box.  There is also a |shift_amount| field, a scaled integer indicating
how much this box should be lowered (if it appears in a horizontal list),
or how much it should be moved to the right (if it appears in a vertical
list). There is a |list_ptr| field, which points to the beginning of the
list from which this box was fabricated; if |list_ptr| is |null|, the box
is empty. Finally, there are three fields that represent the setting of
the glue:  |glue_set(p)| is a word of type |glue_ratio| that represents
the proportionality constant for glue setting; |glue_sign(p)| is
|stretching| or |shrinking| or |normal| depending on whether or not the
glue should stretch or shrink or remain rigid; and |glue_order(p)|
specifies the order of infinity to which glue setting applies (|normal|,
|sfi|, |fil|, |fill|, or |filll|). The |subtype| field is not used.

@d width_offset=2 {position of |width| field in a box node}
@d depth_offset=3 {position of |depth| field in a box node}
@d height_offset=4 {position of |height| field in a box node}
@d width(#) == vmem(#+width_offset).sc {width of the box, in sp}
@d depth(#) == vmem(#+depth_offset).sc {depth of the box, in sp}
@d height(#) == vmem(#+height_offset).sc {height of the box, in sp}
@d shift_amount(#) == vlink(#+5) {repositioning distance, in sp}
@d box_dir(#) == vinfo(#+5) {position of |box_dir| in a box node}
@d list_offset=6 {position of |list_ptr| field in a box node}
@d list_ptr(#) == vlink(#+list_offset) {beginning of the list inside the box}
@d glue_order(#) == subtype(#+list_offset) {applicable order of infinity}
@d glue_sign(#) == type(#+list_offset) {stretching or shrinking}
@d normal=0 {the most common case when several cases are named}
@d stretching = 1 {glue setting applies to the stretch components}
@d shrinking = 2 {glue setting applies to the shrink components}
@d glue_set(#) == vmem(#+7).gr {a word of type |glue_ratio| for glue setting}

@ The |new_null_box| function returns a pointer to an |hlist_node| in
which all subfields have the values corresponding to `\.{\\hbox\{\}}'.
The |subtype| field is set to |min_quarterword|, since that's the desired
|span_count| value if this |hlist_node| is changed to an |unset_node|.

@p function new_null_box:pointer; {creates a new box node}
var p:pointer; {the new node}
begin p:=new_node(hlist_node,min_quarterword);
box_dir(p):=text_direction;
new_null_box:=p;
end;

@ A |vlist_node| is like an |hlist_node| in all respects except that it
contains a vertical list.

@ A |rule_node| stands for a solid black rectangle; it has |width|,
|depth|, and |height| fields just as in an |hlist_node|. However, if
any of these dimensions is $-2^{30}$, the actual value will be determined
by running the rule up to the boundary of the innermost enclosing box.
This is called a ``running dimension.'' The |width| is never running in
an hlist; the |height| and |depth| are never running in a~vlist.

@d null_flag==-@'10000000000 {$-2^{30}$, signifies a missing item}
@d is_running(#) == (#=null_flag) {tests for a running dimension}
@d rule_dir(#)==vlink(#+5)

@ A new rule node is delivered by the |new_rule| function. It
makes all the dimensions ``running,'' so you have to change the
ones that are not allowed to run.

@p
function new_rule:pointer;
var p:pointer; {the new node}
begin p:=new_node(rule_node,0); {the |subtype| is not used}
new_rule:=p;
end;


@ Insertions are represented by |ins_node| records, where the |subtype|
indicates the corresponding box number. For example, `\.{\\insert 250}'
leads to an |ins_node| whose |subtype| is |250+min_quarterword|.
The |height| field of an |ins_node| is slightly misnamed; it actually holds
the natural height plus depth of the vertical list being inserted.
The |depth| field holds the |split_max_depth| to be used in case this
insertion is split, and the |split_top_ptr| points to the corresponding
|split_top_skip|. The |float_cost| field holds the |floating_penalty| that
will be used if this insertion floats to a subsequent page after a
split insertion of the same class.  There is one more field, the
|ins_ptr|, which points to the beginning of the vlist for the insertion.

@d float_cost(#)==vmem(#+2).int {the |floating_penalty| to be used}
@d ins_ptr(#)==vinfo(#+5) {the vertical list to be inserted}
@d split_top_ptr(#)==vlink(#+5) {the |split_top_skip| to be used}

@ A |mark_node| has a |mark_ptr| field that points to the reference count
of a token list that contains the user's \.{\\mark} text.
In addition there is a |mark_class| field that contains the mark class.

@d mark_ptr(#)==vlink(#+2) {head of the token list for a mark}
@d mark_class(#)==vinfo(#+2) {the mark class}

@ An |adjust_node|, which occurs only in horizontal lists,
specifies material that will be moved out into the surrounding
vertical list; i.e., it is used to implement \TeX's `\.{\\vadjust}'
operation.  The |adjust_ptr| field points to the vlist containing this
material.

@d adjust_pre == subtype  {pre-adjustment?}
@d adjust_ptr(#)==vlink(#+2) {vertical list to be moved out of horizontal list}
@#{|append_list| is used to append a list to |tail|}
@d append_list(#) == begin vlink(tail) := vlink(#); append_list_end
@d append_list_end(#) == tail := #; end

@ A |glyph_node|, which occurs only in horizontal lists, specifies a
glyph in a particular font, along with its attribute list. Older
versions of \TeX\ could use token memory for characters, because the
font,char combination would fit in a single word (both values were
required to be strictly less than $2^{16}$). In \LuaTeX, room is
needed for characters that are larger than that, as well as a pointer
to a potential attribute list, and the two displacement values.

In turn, that made the node so large that it made sense to merge
ligature glyphs as well, as that requires only one extra pointer.  A
few extra classes of glyph nodes will be introduced later.  The
unification of all those types makes it easier to manipulate lists of
glyphs. The subtype differentiates various glyph kinds.

First, here is a function that returns a pointer to a glyph node for a given
glyph in a given font. If that glyph doesn't exist, |null| is returned
instead.  Nodes of this subtype are directly created only for accents
and their base (through |make_accent|), and math nucleus items (in the
conversion from |mlist| to |hlist|).


@d is_char_node(#) == ((#<>null)and(type(#)=glyph_node))
@d font(#)==vlink(#+2) {the font code in a |glyph_node|}
@d character(#)==vinfo(#+2) {the character code in a |glyph_node|}
@d lig_ptr(#)==vlink(#+3) {the list of characters for ligature replacements }
@d lang_data(#)==vinfo(#+3) {language information }
@d x_displace(#)==vinfo(#+4) { horizontal displacement }
@d y_displace(#)==vlink(#+4) { vertical displacement  }

@p function new_glyph(@!f,@!c:integer):pointer;
var p:pointer; {the new node}
begin p:=null;
if (f=0) or (char_exists(f,c)) then begin
  p:=new_glyph_node;
  set_to_glyph(p); font(p):=f;  character(p):=c;
  end;
new_glyph:=p;
end;


@ A subset of the glyphs nodes represent ligatures: characters
fabricated from the interaction of two or more actual characters.  The
characters that generated the ligature have not been forgotten, since
they are needed for diagnostic messages; the |lig_ptr| field points to
a linked list of character nodes for all original characters that have
been deleted. (This list might be empty if the characters that
generated the ligature were retained in other nodes.)

The |subtype| field of these |glyph_node|s is 1, plus 2 and/or 1 if
the original source of the ligature included implicit left and/or
right boundaries. These nodes are created by the C function |new_ligkern|.

@ A third general type of glyphs could be called a character, as it
only appears in lists that are not yet processed by the ligaturing and
kerning steps of the program.

|main_control| inserts these, and they are later converted to
|subtype_normal| by |new_ligkern|.

@p function norm_min(@!h:integer):quarterword;
begin if h<=0 then norm_min:=1@+else if h>=255 then norm_min:=255@+
else norm_min:=h;
end;
@#
function new_char(@!f,@!c:integer):pointer;
var p:pointer; {the new node}
begin p:=new_glyph_node;
set_to_character(p); font(p):=f;  character(p):=c;
lang_data(p):=make_lang_data(uc_hyph,cur_lang,left_hyphen_min,right_hyphen_min);
new_char:=p;
end;

@ Left and right ghost glyph nodes are the result of \.{\\leftghost}
and \.{\\rightghost}, respectively. They are going to be removed by
|new_ligkern|, at the end of which they are no longer needed.

@ Here are a few handy helpers used by the list output routines.

@p
function glyph_width(@!p:halfword):pointer;
var w:integer;
begin
  w := char_width(font(p),character(p)); { |+ x_displace(p);| }
  glyph_width := w;
end;
@#
function glyph_height(@!p:halfword):pointer;
var w:integer;
begin
  w := char_height(font(p),character(p)) + y_displace(p);
  if w<0 then w:=0;
  glyph_height := w;
end;
@#
function glyph_depth(@!p:halfword):pointer;
var w:integer;
begin
  w := char_depth(font(p),character(p));
  if y_displace(p)>0 then w := w - y_displace(p);
  if w<0 then w:=0;
  glyph_depth := w;
end;


@ A |disc_node|, which occurs only in horizontal lists, specifies a
``dis\-cretion\-ary'' line break. If such a break occurs at node |p|, the text
that starts at |pre_break(p)| will precede the break, the text that starts at
|post_break(p)| will follow the break, and text that appears in
|no_break(p)| nodes will be ignored. For example, an ordinary
discretionary hyphen, indicated by `\.{\\-}', yields a |disc_node| with
|pre_break| pointing to a |char_node| containing a hyphen, |post_break=null|,
and |no_break=null|.

{TODO: Knuth said: All three of the discretionary texts must be lists
that consist entirely of character, kern, box and rule nodes.}

If |subtype(p)=automatic_disc|, the |ex_hyphen_penalty| will be charged for this
break.  Otherwise the |hyphen_penalty| will be charged.  The texts will
actually be substituted into the list by the line-breaking algorithm if it
decides to make the break, and the discretionary node will disappear at
that time; thus, the output routine sees only discretionaries that were
not chosen.

@d automatic_disc=2
@d syllable_disc=3
@d disc_type==subtype {the kind of discretionary}
@d pre_break(#)==vinfo(#+2) {text that precedes a discretionary break}
@d post_break(#)==vlink(#+2) {text that follows a discretionary break}
@d no_break(#)==vlink(#+3) {text this discretionary break replaces}
@d pre_break_head(#)==(#+4)
@d post_break_head(#)==(#+6)
@d no_break_head(#)==(#+8)
@d tlink(#)==vinfo(#+1)

@p function new_disc:pointer; {creates an empty |disc_node|}
var p:pointer; {the new node}
begin p:=new_node(disc_node,0);
new_disc:=p;
end;

@ A |whatsit_node| is a wild card reserved for extensions to \TeX. The
|subtype| field in its first word says what `\\{whatsit}' it is, and
implicitly determines the node size (which must be 2 or more) and the
format of the remaining words. When a |whatsit_node| is encountered
in a list, special actions are invoked; knowledgeable people who are
careful not to mess up the rest of \TeX\ are able to make \TeX\ do new
things by adding code at the end of the program. For example, there
might be a `\TeX nicolor' extension to specify different colors of ink,
@^extensions to \TeX@>
and the whatsit node might contain the desired parameters.

The present implementation of \TeX\ treats the features associated with
`\.{\\write}' and `\.{\\special}' as if they were extensions, in order to
illustrate how such routines might be coded. We shall defer further
discussion of extensions until the end of this program.

@ A |math_node|, which occurs only in horizontal lists, appears before and
after mathematical formulas. The |subtype| field is |before| before the
formula and |after| after it. There is a |surround| field, which represents
the amount of surrounding space inserted by \.{\\mathsurround}.

@d surround(#)==vlink(#+2)
@d before=0 {|subtype| for math node that introduces a formula}
@d after=1 {|subtype| for math node that winds up a formula}

@p function new_math(@!w:scaled;@!s:small_number):pointer;
var p:pointer; {the new node}
begin p:=new_node(math_node,s);
surround(p):=w; new_math:=p;
end;

@ \TeX\ makes use of the fact that |hlist_node|, |vlist_node|,
|rule_node|, |ins_node|, |mark_node|, |adjust_node|,
|disc_node|, |whatsit_node|, and |math_node| are at the low end of the
type codes, by permitting a break at glue in a list if and only if the
|type| of the previous node is less than |math_node|. Furthermore, a
node is discarded after a break if its type is |math_node| or~more.

@d precedes_break(#)==(type(#)<math_node)
@d non_discardable(#)==(type(#)<math_node)

@ A |glue_node| represents glue in a list. However, it is really only
a pointer to a separate glue specification, since \TeX\ makes use of the
fact that many essentially identical nodes of glue are usually present.
If |p| points to a |glue_node|, |glue_ptr(p)| points to
another packet of words that specify the stretch and shrink components, etc.

Glue nodes also serve to represent leaders; the |subtype| is used to
distinguish between ordinary glue (which is called |normal|) and the three
kinds of leaders (which are called |a_leaders|, |c_leaders|, and |x_leaders|).
The |leader_ptr| field points to a rule node or to a box node containing the
leaders; it is set to |null| in ordinary glue nodes.

Many kinds of glue are computed from \TeX's ``skip'' parameters, and
it is helpful to know which parameter has led to a particular glue node.
Therefore the |subtype| is set to indicate the source of glue, whenever
it originated as a parameter. We will be defining symbolic names for the
parameter numbers later (e.g., |line_skip_code=0|, |baseline_skip_code=1|,
etc.); it suffices for now to say that the |subtype| of parametric glue
will be the same as the parameter number, plus~one.

In math formulas there are two more possibilities for the |subtype| in a
glue node: |mu_glue| denotes an \.{\\mskip} (where the units are scaled \.{mu}
instead of scaled \.{pt}); and |cond_math_glue| denotes the `\.{\\nonscript}'
feature that cancels the glue node immediately following if it appears
in a subscript.

@d cond_math_glue=98 {special |subtype| to suppress glue in the next node}
@d mu_glue=99 {|subtype| for math glue}
@d a_leaders=100 {|subtype| for aligned leaders}
@d c_leaders=101 {|subtype| for centered leaders}
@d x_leaders=102 {|subtype| for expanded leaders}
@d glue_ptr(#)==vinfo(#+2) {pointer to a glue specification}
@d leader_ptr(#)==vlink(#+2) {pointer to box or rule node for leaders}

@ A glue specification has a halfword reference count in its first word,
@^reference counts@>
representing |null| plus the number of glue nodes that point to it (less one).
Note that the reference count appears in the same position as
the |link| field in list nodes; this is the field that is initialized
to |null| when a node is allocated, and it is also the field that is flagged
by |empty_flag| in empty nodes.

Glue specifications also contain three |scaled| fields, for the |width|,
|stretch|, and |shrink| dimensions. Finally, there are two one-byte
fields called |stretch_order| and |shrink_order|; these contain the
orders of infinity (|normal|, |sfi|, |fil|, |fill|, or |filll|)
corresponding to the stretch and shrink values.

@d glue_ref_count(#) == vlink(#+3) {reference count of a glue specification}
@d stretch(#) == vlink(#+1) {the stretchability of this glob of glue}
@d shrink(#) == vinfo(#+1) {the shrinkability of this glob of glue}
@d stretch_order(#) == type(#+3) {order of infinity for stretching}
@d shrink_order(#) == subtype(#+3) {order of infinity for shrinking}
@d sfi=1 {first-order infinity}
@d fil=2 {second-order infinity}
@d fill=3 {third-order infinity}
@d filll=4 {fourth-order infinity}

@<Types...@>=
@!glue_ord=normal..filll; {infinity to the 0, 1, 2, 3, or 4 power}

@ Here is a function that returns a pointer to a copy of a glue spec.
The reference count in the copy is |null|, because there is assumed
to be exactly one reference to the new specification.

@p function new_spec(@!p:pointer):pointer; {duplicates a glue specification}
var q:pointer; {the new spec}
begin q:=copy_node(p);
glue_ref_count(q):=null;
new_spec:=q;
end;

@ And here's a function that creates a glue node for a given parameter
identified by its code number; for example,
|new_param_glue(line_skip_code)| returns a pointer to a glue node for the
current \.{\\lineskip}.

@p function new_param_glue(@!n:small_number):pointer;
var p:pointer; {the new node}
@!q:pointer; {the glue specification}
begin p:=new_node(glue_node,n+1);
q:=@<Current |mem| equivalent of glue parameter number |n|@>@t@>;
glue_ptr(p):=q; incr(glue_ref_count(q));
new_param_glue:=p;
end;

@ Glue nodes that are more or less anonymous are created by |new_glue|,
whose argument points to a glue specification.

@p function new_glue(@!q:pointer):pointer;
var p:pointer; {the new node}
begin p:=new_node(glue_node,normal);
glue_ptr(p):=q; incr(glue_ref_count(q));
new_glue:=p;
end;

@ Still another subroutine is needed: This one is sort of a combination
of |new_param_glue| and |new_glue|. It creates a glue node for one of
the current glue parameters, but it makes a fresh copy of the glue
specification, since that specification will probably be subject to change,
while the parameter will stay put. The global variable |temp_ptr| is
set to the address of the new spec.

@p function new_skip_param(@!n:small_number):pointer;
var p:pointer; {the new node}
begin temp_ptr:=new_spec(@<Current |mem| equivalent of glue parameter...@>);
p:=new_glue(temp_ptr); glue_ref_count(temp_ptr):=null; subtype(p):=n+1;
new_skip_param:=p;
end;

@ A |kern_node| has a |width| field to specify a (normally negative)
amount of spacing. This spacing correction appears in horizontal lists
between letters like A and V when the font designer said that it looks
better to move them closer together or further apart. A kern node can
also appear in a vertical list, when its `|width|' denotes additional
spacing in the vertical direction. The |subtype| is either |normal| (for
kerns inserted from font information or math mode calculations) or |explicit|
(for kerns inserted from \.{\\kern} and \.{\\/} commands) or |acc_kern|
(for kerns inserted from non-math accents) or |mu_glue| (for kerns
inserted from \.{\\mkern} specifications in math formulas).

@d explicit=1 {|subtype| of kern nodes from \.{\\kern} and \.{\\/}}
@d acc_kern=2 {|subtype| of kern nodes from accents}

@# {memory structure for marginal kerns}
@d margin_char(#) == vlink(#+3)

@# {|subtype| of marginal kerns}
@d left_side == 0
@d right_side == 1

@# {base for lp/rp/ef codes starts from 2:
    0 for |hyphen_char|,
    1 for |skew_char|}
@d lp_code_base == 2
@d rp_code_base == 3
@d ef_code_base == 4
@d tag_code == 5

@d auto_kern == explicit
@d no_lig_code == 6

@ The |new_kern| function creates a kern node having a given width.

@p function new_kern(@!w:scaled):pointer;
var p:pointer; {the new node}
begin p:=new_node(kern_node,normal);
width(p):=w;
new_kern:=p;
end;

@ A |penalty_node| specifies the penalty associated with line or page
breaking, in its |penalty| field. This field is a fullword integer, but
the full range of integer values is not used: Any penalty |>=10000| is
treated as infinity, and no break will be allowed for such high values.
Similarly, any penalty |<=-10000| is treated as negative infinity, and a
break will be forced.

@d inf_penalty==inf_bad {``infinite'' penalty value}
@d eject_penalty==-inf_penalty {``negatively infinite'' penalty value}
@d penalty(#) == vlink(#+2) {the added cost of breaking a list here}

@ Anyone who has been reading the last few sections of the program will
be able to guess what comes next.

@p function new_penalty(@!m:integer):pointer;
var p:pointer; {the new node}
begin p:=new_node(penalty_node,0); {the |subtype| is not used}
penalty(p):=m; new_penalty:=p;
end;

@ You might think that we have introduced enough node types by now. Well,
almost, but there is one more: An |unset_node| has nearly the same format
as an |hlist_node| or |vlist_node|; it is used for entries in \.{\\halign}
or \.{\\valign} that are not yet in their final form, since the box
dimensions are their ``natural'' sizes before any glue adjustment has been
made. The |glue_set| word is not present; instead, we have a |glue_stretch|
field, which contains the total stretch of order |glue_order| that is
present in the hlist or vlist being boxed.
Similarly, the |shift_amount| field is replaced by a |glue_shrink| field,
containing the total shrink of order |glue_sign| that is present.
The |subtype| field is called |span_count|; an unset box typically
contains the data for |qo(span_count)+1| columns.
Unset nodes will be changed to box nodes when alignment is completed.

@d glue_stretch(#)==vmem(#+7).sc {total stretch in an unset node}
@d glue_shrink==shift_amount {total shrink in an unset node}
@d span_count==subtype {indicates the number of spanned columns}

@ In fact, there are still more types coming. When we get to math formula
processing we will see that a |style_node| has |type=14|; and a number
of larger type codes will also be defined, for use in math mode only.

@ Warning: If any changes are made to these data structure layouts, such as
changing any of the node sizes or even reordering the words of nodes,
the |copy_node_list| procedure and the memory initialization code
below may have to be changed. Such potentially dangerous parts of the
program are listed in the index under `data structure assumptions'.
@!@^data structure assumptions@>
However, other references to the nodes are made symbolically in terms of
the \.{WEB} macro definitions above, so that format changes will leave
\TeX's other algorithms intact.
@^system dependencies@>

@* \[11] Memory layout.

Some areas of |mem| are dedicated to fixed usage, since static
allocation is more efficient than dynamic allocation when we can get
away with it. For example, |zero_glue| used for glue that is `\.{0pt
plus 0pt minus 0pt}'.  A few C macro definitions accomplish the static
allocation of node memory locations by giving symbolic names to fixed
positions. The list of imported constant identifiers is: |zero_glue|,
|sfi_glue|, |fil_glue|, |fill_glue|, |ss_glue|, |fil_neg_glue| (all
glue specs), |page_ins_head| (list of insertion data for current
page), |contrib_head| (list of insertion data for current page),
|page_head| (list for current page), |temp_head| and |hold_head|
(temporary lists), |adjust_head| (head of adjustment list returned by
|hpack|), |pre_adjust_head| (head of pre-adjustment list returned by
|hpack|), |align_head| (head of alignment preamble), and
|end_span| (tail of spanned-width lists).


@ The following code gets |mem| off to a good start, when \TeX\ is
initializing itself the slow~way.

@<Local variables for init...@>=
@!k:integer; {index into |mem|, |eqtb|, etc.}

@ @<Initialize table entries...@>=
init_node_mem(500);
initialize_tokens;
@<Initialize the special list heads and constant nodes@>;
initialize_active;

@ @p
@<Declare procedures that need to be declared forward for \pdfTeX@>

@* \[12] Displaying boxes.
We can reinforce our knowledge of the data structures just introduced
by considering two procedures that display a list in symbolic form.
The first of these, called |short_display|, is used in ``overfull box''
messages to give the top-level description of a list. The other one,
called |show_node_list|, prints a detailed description of exactly what
is in the data structure.

The philosophy of |short_display| is to ignore the fine points about exactly
what is inside boxes, except that ligatures and discretionary breaks are
expanded. As a result, |short_display| is a recursive procedure, but the
recursion is never more than one level deep.
@^recursion@>

A global variable |font_in_short_display| keeps track of the font code that
is assumed to be present when |short_display| begins; deviations from this
font will be printed.

@<Glob...@>=
@!font_in_short_display:integer; {an internal font number}

@ Boxes, rules, inserts, whatsits, marks, and things in general that are
sort of ``complicated'' are indicated only by printing `\.{[]}'.

@p
procedure print_font_identifier(f: internal_font_number);
var fonttext:str_number;
begin
    if pdf_font_blink(f) = null_font then
        fonttext := font_id_text(f)
    else
        fonttext := font_id_text(pdf_font_blink(f));
    if fonttext>0 then
        print_esc(fonttext)
    else begin
        print_esc("FONT");
        if pdf_font_blink(f) = null_font then
            print_int(f)
        else
            print_int(pdf_font_blink(f));
        end;
    if pdf_tracing_fonts > 0 then begin
        print(" (");
        print_font_name(f);
        if font_size(f) <> font_dsize(f) then begin
            print("@@");
            print_scaled(font_size(f));
            print("pt");
        end;
        print(")");
    end else
        if pdf_font_expand_ratio(f) <> 0 then begin
            print(" (");
            if pdf_font_expand_ratio(f) > 0 then
                print("+");
            print_int(pdf_font_expand_ratio(f));
            print(")");
        end;
end;

procedure short_display(@!p:integer); {prints highlights of list |p|}
begin while p<>null do
  begin if is_char_node(p) then
      begin if lig_ptr(p)<>null then
           short_display(lig_ptr(p))
        else begin
          if font(p)<>font_in_short_display then
          begin if not is_valid_font(font(p)) then
            print_char("*")
@.*\relax@>
          else print_font_identifier(font(p));
          print_char(" "); font_in_short_display:=font(p);
          end;
        print(qo(character(p)));
      end;
    end
  else @<Print a short indication of the contents of node |p|@>;
  p:=vlink(p);
  end;
end;

@ @<Print a short indication of the contents of node |p|@>=
print_short_node_contents(p)

@ The |show_node_list| routine requires some auxiliary subroutines: one to
print a font-and-character combination, one to print a token list without
its reference count, and one to print a rule dimension.

@p procedure print_font_and_char(@!p:integer); {prints |char_node| data}
begin if not is_valid_font(font(p)) then print_char("*")
@.*\relax@>
  else print_font_identifier(font(p));
  print_char(" "); print(character(p));
end;
@#
procedure print_mark(@!p:integer); {prints token list data in braces}
begin print_char("{");
if (p<fix_mem_min)or(p>fix_mem_end) then print_esc("CLOBBERED.")
else show_token_list(link(p),null,max_print_line-10);
print_char("}");
end;
@#
procedure print_rule_dimen(@!d:scaled); {prints dimension in rule node}
begin if is_running(d) then print_char("*") else print_scaled(d);
@.*\relax@>
end;
@#


@ We also need to declare some procedures that appear later in this
documentation.

@p @<Declare the procedure called |print_skip_param|@>

@ Since boxes can be inside of boxes, |show_node_list| is inherently recursive,
@^recursion@>
up to a given maximum number of levels.  The history of nesting is indicated
by the current string, which will be printed at the beginning of each line;
the length of this string, namely |cur_length|, is the depth of nesting.

@ A global variable called |depth_threshold| is used to record the maximum
depth of nesting for which |show_node_list| will show information.  If we
have |depth_threshold=0|, for example, only the top level information will
be given and no sublists will be traversed. Another global variable, called
|breadth_max|, tells the maximum number of items to show at each level;
|breadth_max| had better be positive, or you won't see anything.

@<Glob...@>=
@!depth_threshold : integer; {maximum nesting depth in box displays}
@!breadth_max : integer; {maximum number of items shown at the same list level}


@ The recursive machinery is started by calling |show_box|.
@^recursion@>

@p procedure show_box(@!p:pointer);
begin @<Assign the values |depth_threshold:=show_box_depth| and
  |breadth_max:=show_box_breadth|@>;
if breadth_max<=0 then breadth_max:=5;
if pool_ptr+depth_threshold>=pool_size then
  depth_threshold:=pool_size-pool_ptr-1;
  {now there's enough room for prefix string}
show_node_list(p); {the show starts at |p|}
print_ln;
end;

@* \[13] Destroying boxes.
When we are done with a node list, we are obliged to return it to free
storage, including all of its sublists. The recursive procedure
|flush_node_list| does this for us.

@ First, however, we shall consider two non-recursive procedures that do
simpler tasks. |delete_glue_ref| is called when a pointer to a glue
specification is being withdrawn.
@^reference counts@>
@d fast_delete_glue_ref(#)==@t@>@;@/
  begin if glue_ref_count(#)=null then begin
    flush_node(#);
    end
  else decr(glue_ref_count(#));
  end

@p procedure delete_glue_ref(@!p:pointer); {|p| points to a glue specification}
begin
  pdfassert(type(p)=glue_spec_node);
  fast_delete_glue_ref(p);
end;

@ Now we are ready to delete any node list, recursively.
In practice, the nodes deleted are usually charnodes (about 2/3 of the time),
and they are glue nodes in about half of the remaining cases.
@^recursion@>


@* \[14] Copying boxes.
Another recursive operation that acts on boxes is sometimes needed: The
procedure |copy_node_list| returns a pointer to another node list that has
the same structure and meaning as the original. Note that since glue
specifications and token lists have reference counts, we need not make
copies of them. Reference counts can never get too large to fit in a
halfword, since each pointer to a node is in a different memory address,
and the total number of memory addresses fits in a halfword.
@^recursion@>
@^reference counts@>

(Well, there actually are also references from outside |mem|; if the
|save_stack| is made arbitrarily large, it would theoretically be possible
to break \TeX\ by overflowing a reference count. But who would want to do that?)

@d add_glue_ref(#)==incr(glue_ref_count(#)) {new reference to a glue spec}

@p function tail_of_list (@!p:pointer):pointer;
var q:pointer;
begin
  q:=p;
  while vlink(q)<>null do q:=vlink(q);
  tail_of_list:=q;
end;

@* \[15] The command codes.
Before we can go any further, we need to define symbolic names for the internal
code numbers that represent the various commands obeyed by \TeX. These codes
are somewhat arbitrary, but not completely so. For example, the command
codes for character types are fixed by the language, since a user says,
e.g., `\.{\\catcode \`\\\${} = 3}' to make \.{\char'44} a math delimiter,
and the command code |math_shift| is equal to~3. Some other codes have
been made adjacent so that |case| statements in the program need not consider
cases that are widely spaced, or so that |case| statements can be replaced
by |if| statements.

At any rate, here is the list, for future reference. First come the
``catcode'' commands, several of which share their numeric codes with
ordinary commands when the catcode cannot emerge from \TeX's scanning routine.

@d escape=0 {escape delimiter (called \.\\ in {\sl The \TeX book\/})}
@:TeXbook}{\sl The \TeX book@>
@d relax=0 {do nothing ( \.{\\relax} )}
@d left_brace=1 {beginning of a group ( \.\{ )}
@d right_brace=2 {ending of a group ( \.\} )}
@d math_shift=3 {mathematics shift character ( \.\$ )}
@d tab_mark=4 {alignment delimiter ( \.\&, \.{\\span} )}
@d car_ret=5 {end of line ( |carriage_return|, \.{\\cr}, \.{\\crcr} )}
@d out_param=5 {output a macro parameter}
@d mac_param=6 {macro parameter symbol ( \.\# )}
@d sup_mark=7 {superscript ( \.{\char'136} )}
@d sub_mark=8 {subscript ( \.{\char'137} )}
@d ignore=9 {characters to ignore ( \.{\^\^@@} )}
@d endv=9 {end of \<v_j> list in alignment template}
@d spacer=10 {characters equivalent to blank space ( \.{\ } )}
@d letter=11 {characters regarded as letters ( \.{A..Z}, \.{a..z} )}
@d other_char=12 {none of the special character types}
@d active_char=13 {characters that invoke macros ( \.{\char`\~} )}
@d par_end=13 {end of paragraph ( \.{\\par} )}
@d match=13 {match a macro parameter}
@d comment=14 {characters that introduce comments ( \.\% )}
@d end_match=14 {end of parameters to macro}
@d stop=14 {end of job ( \.{\\end}, \.{\\dump} )}
@d invalid_char=15 {characters that shouldn't appear ( \.{\^\^?} )}
@d delim_num=15 {specify delimiter numerically ( \.{\\delimiter} )}
@d max_char_code=15 {largest catcode for individual characters}

@ Next are the ordinary run-of-the-mill command codes.  Codes that are
|min_internal| or more represent internal quantities that might be
expanded by `\.{\\the}'.

@d char_num=16 {character specified numerically ( \.{\\char} )}
@d math_char_num=17 {explicit math code ( \.{\\mathchar} )}
@d mark=18 {mark definition ( \.{\\mark} )}
@d xray=19 {peek inside of \TeX\ ( \.{\\show}, \.{\\showbox}, etc.~)}
@d make_box=20 {make a box ( \.{\\box}, \.{\\copy}, \.{\\hbox}, etc.~)}
@d hmove=21 {horizontal motion ( \.{\\moveleft}, \.{\\moveright} )}
@d vmove=22 {vertical motion ( \.{\\raise}, \.{\\lower} )}
@d un_hbox=23 {unglue a box ( \.{\\unhbox}, \.{\\unhcopy} )}
@d un_vbox=24 {unglue a box ( \.{\\unvbox}, \.{\\unvcopy} )}
  {( or \.{\\pagediscards}, \.{\\splitdiscards} )}
@d remove_item=25 {nullify last item ( \.{\\unpenalty},
  \.{\\unkern}, \.{\\unskip} )}
@d hskip=26 {horizontal glue ( \.{\\hskip}, \.{\\hfil}, etc.~)}
@d vskip=27 {vertical glue ( \.{\\vskip}, \.{\\vfil}, etc.~)}
@d mskip=28 {math glue ( \.{\\mskip} )}
@d kern=29 {fixed space ( \.{\\kern})}
@d mkern=30 {math kern ( \.{\\mkern} )}
@d leader_ship=31 {use a box ( \.{\\shipout}, \.{\\leaders}, etc.~)}
@d halign=32 {horizontal table alignment ( \.{\\halign} )}
@d valign=33 {vertical table alignment ( \.{\\valign} )}
@d no_align=34 {temporary escape from alignment ( \.{\\noalign} )}
@d vrule=35 {vertical rule ( \.{\\vrule} )}
@d hrule=36 {horizontal rule ( \.{\\hrule} )}
@d insert=37 {vlist inserted in box ( \.{\\insert} )}
@d vadjust=38 {vlist inserted in enclosing paragraph ( \.{\\vadjust} )}
@d ignore_spaces=39 {gobble |spacer| tokens ( \.{\\ignorespaces} )}
@d after_assignment=40 {save till assignment is done ( \.{\\afterassignment} )}
@d after_group=41 {save till group is done ( \.{\\aftergroup} )}
@d break_penalty=42 {additional badness ( \.{\\penalty} )}
@d start_par=43 {begin paragraph ( \.{\\indent}, \.{\\noindent} )}
@d ital_corr=44 {italic correction ( \.{\\/} )}
@d accent=45 {attach accent in text ( \.{\\accent} )}
@d math_accent=46 {attach accent in math ( \.{\\mathaccent} )}
@d discretionary=47 {discretionary texts ( \.{\\-}, \.{\\discretionary} )}
@d eq_no=48 {equation number ( \.{\\eqno}, \.{\\leqno} )}
@d left_right=49 {variable delimiter ( \.{\\left}, \.{\\right} )}
  {( or \.{\\middle} )}
@d math_comp=50 {component of formula ( \.{\\mathbin}, etc.~)}
@d limit_switch=51 {diddle limit conventions ( \.{\\displaylimits}, etc.~)}
@d above=52 {generalized fraction ( \.{\\above}, \.{\\atop}, etc.~)}
@d math_style=53 {style specification ( \.{\\displaystyle}, etc.~)}
@d math_choice=54 {choice specification ( \.{\\mathchoice}, \.{\\Ustack} )}
@d non_script=55 {conditional math glue ( \.{\\nonscript} )}
@d vcenter=56 {vertically center a vbox ( \.{\\vcenter} )}
@d case_shift=57 {force specific case ( \.{\\lowercase}, \.{\\uppercase}~)}
@d message=58 {send to user ( \.{\\message}, \.{\\errmessage} )}
@d extension=59 {extensions to \TeX\ ( \.{\\write}, \.{\\special}, etc.~)}
@d in_stream=60 {files for reading ( \.{\\openin}, \.{\\closein} )}
@d begin_group=61 {begin local grouping ( \.{\\begingroup} )}
@d end_group=62 {end local grouping ( \.{\\endgroup} )}
@d omit=63 {omit alignment template ( \.{\\omit} )}
@d ex_space=64 {explicit space ( \.{\\\ } )}
@d no_boundary=65 {suppress boundary ligatures ( \.{\\noboundary} )}
@d radical=66 {square root and similar signs ( \.{\\radical} )}
@d super_sub_script=67 {explicit super ( \.{\\Usuperscript} ) or subscript ( \.{\\Usubscript} )}
@d math_shift_cs=68 {explicit math switch ( \.{\\Ustartmath}, etc.~)}
@d end_cs_name=69 {end control sequence ( \.{\\endcsname} )}
@d char_ghost=end_cs_name+1
   {\.{\\ghostleft}, \.{\\ghostright} character for kerning}
@d assign_local_box=char_ghost+1
   {box for guillemets \.{\\localleftbox} or \.{\\localrightbox}}
@d min_internal=assign_local_box+1 {the smallest code that can follow \.{\\the}}
@d char_given=min_internal {character code defined by \.{\\chardef}}
@d math_given=char_given+1 {math code defined by \.{\\mathchardef}}
@d omath_given=math_given+1 {math code defined by \.{\\omathchardef}}
@d xmath_given=omath_given+1 {math code defined by \.{\\Umathchardef}}
@d last_item=xmath_given+1 {most recent item ( \.{\\lastpenalty},
  \.{\\lastkern}, \.{\\lastskip} )}
@d max_non_prefixed_command=last_item
   {largest command code that can't be \.{\\global}}

@ The next codes are special; they all relate to mode-independent
assignment of values to \TeX's internal registers or tables.
Codes that are |max_internal| or less represent internal quantities
that might be expanded by `\.{\\the}'.

There is no matching primitive to go with |assign_attr|, but even if
there was no \.{\\attributedef}, a reserved number would still be
needed because there is an implied correspondence between the
|assign_xxx| commands and |xxx_val| expression values. That would
break down otherwise.

@d toks_register=max_non_prefixed_command+1
   {token list register ( \.{\\toks} )}
@d assign_toks=toks_register+1
   {special token list ( \.{\\output}, \.{\\everypar}, etc.~)}
@d assign_int=assign_toks+1
   {user-defined integer ( \.{\\tolerance}, \.{\\day}, etc.~)}
@d assign_attr=assign_int+1 { user-defined attributes }
@d assign_dimen=assign_attr+1
   {user-defined length ( \.{\\hsize}, etc.~)}
@d assign_glue=assign_dimen+1
   {user-defined glue ( \.{\\baselineskip}, etc.~)}
@d assign_mu_glue=assign_glue+1
   {user-defined muglue ( \.{\\thinmuskip}, etc.~)}
@d assign_font_dimen=assign_mu_glue+1
   {user-defined font dimension ( \.{\\fontdimen} )}
@d assign_font_int=assign_font_dimen+1
   {user-defined font integer ( \.{\\hyphenchar}, \.{\\skewchar} )}
@d set_aux=assign_font_int+1
   {specify state info ( \.{\\spacefactor}, \.{\\prevdepth} )}
@d set_prev_graf=set_aux+1
   {specify state info ( \.{\\prevgraf} )}
@d set_page_dimen=set_prev_graf+1
   {specify state info ( \.{\\pagegoal}, etc.~)}
@d set_page_int=set_page_dimen+1
   {specify state info ( \.{\\deadcycles},
  \.{\\insertpenalties} )}
@d set_box_dimen=set_page_int+1
   {change dimension of box ( \.{\\wd}, \.{\\ht}, \.{\\dp} )}
@d set_tex_shape=set_box_dimen+1
   {specify fancy paragraph shape ( \.{\\parshape} )}
@d set_etex_shape=set_tex_shape+1
   {specify etex specials ( \.{\\interlinepenalties}, etc.~)}
@d def_char_code=set_etex_shape+1
   {define a character code ( \.{\\catcode}, etc.~)}
@d def_del_code=def_char_code+1
   {define a delimiter code ( \.{\\delcode})}
@d extdef_math_code=def_del_code+1
   {define an extended character code ( \.{\\omathcode}, etc.~)}
@d extdef_del_code=extdef_math_code+1
   {define an extended delimiter code ( \.{\\odelcode}, etc.~)}
@d def_family=extdef_del_code+1
   {declare math fonts ( \.{\\textfont}, etc.~)}
@d set_math_param=def_family+1
   {declare math parameters ( \.{\\Umathquad}, etc.~)}
@d set_font=set_math_param+1
   {set current font ( font identifiers )}
@d def_font=set_font+1
   {define a font file ( \.{\\font} )}
@d register=def_font+1
   {internal register ( \.{\\count}, \.{\\dimen}, etc.~)}
@d assign_box_dir=register+1 {(\.{\\boxdir})}
@d assign_dir=register+2 {(\.{\\pagedir}, \.{\\bodydir}, \.{\\pardir}, \.{\\textdir}), \.{\\mathdir}}
@d max_internal=assign_dir
   {the largest code that can follow \.{\\the}}
@d advance=max_internal+1
   {advance a register or parameter ( \.{\\advance} )}
@d multiply=advance+1
   {multiply a register or parameter ( \.{\\multiply} )}
@d divide=multiply+1
   {divide a register or parameter ( \.{\\divide} )}
@d prefix=divide+1
   {qualify a definition ( \.{\\global}, \.{\\long}, \.{\\outer} )}
@d let=prefix+1
   {assign a command code ( \.{\\let}, \.{\\futurelet} )}
@d shorthand_def=let+1
   {code definition ( \.{\\chardef}, \.{\\countdef}, etc.~)}
@d read_to_cs=shorthand_def+1
   {read into a control sequence ( \.{\\read} )}
@d def=read_to_cs+1
   {macro definition ( \.{\\def}, \.{\\gdef}, \.{\\xdef}, \.{\\edef} )}
@d set_box=def+1
   {set a box ( \.{\\setbox} )}
@d hyph_data=set_box+1
   {hyphenation data ( \.{\\hyphenation}, \.{\\patterns} )}
@d set_interaction=hyph_data+1
   {define level of interaction ( \.{\\batchmode}, etc.~)}
@d letterspace_font=set_interaction+1
   {letterspace a font ( \.{\\letterspacefont} )}
@d pdf_copy_font=letterspace_font+1
   {create a new font instance ( \.{\\pdfcopyfont} )}
@d set_ocp=pdf_copy_font+1
   {Place a translation process in the stream}
@d def_ocp=set_ocp+1
   {Define and load a translation process}
@d set_ocp_list=def_ocp+1
   {Place a list of OCPs in the stream}
@d def_ocp_list=set_ocp_list+1
   {Define a list of OCPs}
@d clear_ocp_lists=def_ocp_list+1
   {Remove all active OCP lists}
@d push_ocp_list=clear_ocp_lists+1
   {Add to the sequence of active OCP lists}
@d pop_ocp_list=push_ocp_list+1
   {Remove from the sequence of active OCP lists}
@d ocp_list_op=pop_ocp_list+1
   {Operations for building a list of OCPs}
@d ocp_trace_level=ocp_list_op+1
   {Tracing of active OCPs, either 0 or 1}
@d max_command=ocp_trace_level
  {the largest command code seen at |big_switch|}

@ The remaining command codes are extra special, since they cannot get through
\TeX's scanner to the main control routine. They have been given values higher
than |max_command| so that their special nature is easily discernible.
The ``expandable'' commands come first.

@d undefined_cs=max_command+1 {initial state of most |eq_type| fields}
@d expand_after=max_command+2 {special expansion ( \.{\\expandafter} )}
@d no_expand=max_command+3 {special nonexpansion ( \.{\\noexpand} )}
@d input=max_command+4 {input a source file ( \.{\\input}, \.{\\endinput} )}
  {( or \.{\\scantokens} or \.{\\scantextokens} )}
@d if_test=max_command+5 {conditional text ( \.{\\if}, \.{\\ifcase}, etc.~)}
@d fi_or_else=max_command+6 {delimiters for conditionals ( \.{\\else}, etc.~)}
@d cs_name=max_command+7 {make a control sequence from tokens ( \.{\\csname} )}
@d convert=max_command+8 {convert to text ( \.{\\number}, \.{\\string}, etc.~)}
@d the=max_command+9 {expand an internal quantity ( \.{\\the} )}
  {( or \.{\\unexpanded}, \.{\\detokenize} )}
@d top_bot_mark=max_command+10 {inserted mark ( \.{\\topmark}, etc.~)}
@d call=max_command+11 {non-long, non-outer control sequence}
@d long_call=max_command+12 {long, non-outer control sequence}
@d outer_call=max_command+13 {non-long, outer control sequence}
@d long_outer_call=max_command+14 {long, outer control sequence}
@d end_template=max_command+15 {end of an alignment template}
@d dont_expand=max_command+16 {the following token was marked by \.{\\noexpand}}
@d glue_ref=max_command+17 {the equivalent points to a glue specification}
@d shape_ref=max_command+18 {the equivalent points to a parshape specification}
@d box_ref=max_command+19 {the equivalent points to a box node, or is |null|}
@d data=max_command+20 {the equivalent is simply a halfword number}

@* \[16] The semantic nest.

@  These need to stay here because of web2c problems in main_control's
case labels.

@d vmode=1
@d hmode=vmode+max_command+1
@d mmode=hmode+max_command+1

@ Let's not have the next definitions in the C code, only here:

@d mode==cur_list.mode_field {current mode}
@d head==cur_list.head_field {header node of current list}
@d tail==cur_list.tail_field {final node on current list}
@d eTeX_aux==cur_list.eTeX_aux_field {auxiliary data for \eTeX}
@d prev_graf==cur_list.pg_field {number of paragraph lines accumulated}
@d aux==cur_list.aux_field {auxiliary data about the current list}
@d prev_depth==aux.sc {the name of |aux| in vertical mode}
@d space_factor==aux.hh.lh {part of |aux| in horizontal mode}
@d mode_line==cur_list.ml_field {source file line number at beginning of list}
@d dir_save==cur_list.dirs_field {dir stack when a paragraph is interrupted}


@ @<Set init...@>=
initialize_nesting;
@<Start a new current page@>;

@ @p @<LOCAL: Declare |make_local_par_node|@>;

@* \[17] The table of equivalents.
Now that we have studied the data structures for \TeX's semantic routines,
we ought to consider the data structures used by its syntactic routines. In
other words, our next concern will be
the tables that \TeX\ looks at when it is scanning
what the user has written.

The biggest and most important such table is called |eqtb|. It holds the
current ``equivalents'' of things; i.e., it explains what things mean
or what their current values are, for all quantities that are subject to
the nesting structure provided by \TeX's grouping mechanism. There are six
parts to |eqtb|:

\yskip\hangg 1) |eqtb[null_cs]| holds the current equivalent of the
zero-length control sequence.

\yskip\hangg 2) |eqtb[hash_base..(glue_base-1)]| holds the current
equivalents of single- and multiletter control sequences.

\yskip\hangg 3) |eqtb[glue_base..(local_base-1)]| holds the current
equivalents of glue parameters like the current baselineskip.

\yskip\hangg 4) |eqtb[local_base..(int_base-1)]| holds the current
equivalents of local halfword quantities like the current box registers,
the current ``catcodes,'' the current font, and a pointer to the current
paragraph shape.

\yskip\hangg 5) |eqtb[int_base..(dimen_base-1)]| holds the current
equivalents of fullword integer parameters like the current hyphenation
penalty.

\yskip\hangg 6) |eqtb[dimen_base..eqtb_size]| holds the current equivalents
of fullword dimension parameters like the current hsize or amount of
hanging indentation.

\yskip\noindent Note that, for example, the current amount of
baselineskip glue is determined by the setting of a particular location
in region~3 of |eqtb|, while the current meaning of the control sequence
`\.{\\baselineskip}' (which might have been changed by \.{\\def} or
\.{\\let}) appears in region~2.

@ Each entry in |eqtb| is a |memory_word|. Most of these words are of type
|two_halves|, and subdivided into three fields:

\yskip\hangg 1) The |eq_level| (a quarterword) is the level of grouping at
which this equivalent was defined. If the level is |level_zero|, the
equivalent has never been defined; |level_one| refers to the outer level
(outside of all groups), and this level is also used for global
definitions that never go away. Higher levels are for equivalents that
will disappear at the end of their group.  @^global definitions@>

\yskip\hangg 2) The |eq_type| (another quarterword) specifies what kind of
entry this is. There are many types, since each \TeX\ primitive like
\.{\\hbox}, \.{\\def}, etc., has its own special code. The list of
command codes above includes all possible settings of the |eq_type| field.

\yskip\hangg 3) The |equiv| (a halfword) is the current equivalent value.
This may be a font number, a pointer into |mem|, or a variety of other
things.

@d eq_level_field(#)==#.hh.b1
@d eq_type_field(#)==#.hh.b0
@d equiv_field(#)==#.hh.rh
@d eq_level(#)==eq_level_field(eqtb[#]) {level of definition}
@d eq_type(#)==eq_type_field(eqtb[#]) {command code for equivalent}
@d equiv(#)==equiv_field(eqtb[#]) {equivalent value}
@d level_zero=min_quarterword {level for undefined quantities}
@d level_one=level_zero+1 {outermost level for defined quantities}

@ Many locations in |eqtb| have symbolic names. The purpose of the next
paragraphs is to define these names, and to set up the initial values of the
equivalents.

In the first region we have a single entry for the `null csname' of
length zero. In luatex, the active characters and and single-letter
control sequence names are part of the next region.

Then comes region~2, which corresponds to the hash table that we will
define later.  The maximum address in this region is used for a dummy
control sequence that is perpetually undefined. There also are several
locations for control sequences that are perpetually defined
(since they are used in error recovery).

@d null_cs=1 {equivalent of \.{\\csname\\endcsname}}
@d hash_base=null_cs+1 {beginning of region 2, for the hash table}
@d frozen_control_sequence=hash_base+hash_size {for error recovery}
@d frozen_protection=frozen_control_sequence {inaccessible but definable}
@d frozen_cr=frozen_control_sequence+1 {permanent `\.{\\cr}'}
@d frozen_end_group=frozen_control_sequence+2 {permanent `\.{\\endgroup}'}
@d frozen_right=frozen_control_sequence+3 {permanent `\.{\\right}'}
@d frozen_fi=frozen_control_sequence+4 {permanent `\.{\\fi}'}
@d frozen_end_template=frozen_control_sequence+5 {permanent `\.{\\endtemplate}'}
@d frozen_endv=frozen_control_sequence+6 {second permanent `\.{\\endtemplate}'}
@d frozen_relax=frozen_control_sequence+7 {permanent `\.{\\relax}'}
@d end_write=frozen_control_sequence+8 {permanent `\.{\\endwrite}'}
@d frozen_dont_expand=frozen_control_sequence+9
  {permanent `\.{\\notexpanded:}'}
@d frozen_primitive=frozen_control_sequence+11
  {permanent `\.{\\pdfprimitive}'}
@d frozen_special=frozen_control_sequence+12
  {permanent `\.{\\special}'}
@d frozen_null_font=frozen_control_sequence+13
  {permanent `\.{\\nullfont}'}
@d font_id_base=frozen_null_font-font_base
  {begins table of |number_fonts| permanent font identifiers}
@d frozen_null_ocp=frozen_null_font+number_fonts
  {permanent `\.{\\nullocp}'}
@d ocp_id_base=frozen_null_ocp-ocp_base
  {begins table of |number_ocps| permanent ocp identifiers}
@d frozen_null_ocp_list=frozen_null_ocp+number_ocps
  {permanent `\.{\\nullocplist}'}
@d ocp_list_id_base=frozen_null_ocp_list-ocp_list_base
  {begins table of |number_ocp_lists| permanent ocp list identifiers}
@d undefined_control_sequence=frozen_null_ocp_list+number_ocp_lists
@d glue_base=undefined_control_sequence+1 {beginning of region 3}

@<Initialize table entries...@>=
eq_type(undefined_control_sequence):=undefined_cs;
equiv(undefined_control_sequence):=null;
eq_level(undefined_control_sequence):=level_zero;
for k:=null_cs to undefined_control_sequence-1 do
  eqtb[k]:=eqtb[undefined_control_sequence];

@ Create a C version of |undefined_control_sequence|.

@<Global...@>=
@!static_undefined_control_sequence:integer;

@ @<Set init...@>=
static_undefined_control_sequence:=undefined_control_sequence;

@ Here is a routine that displays the current meaning of an |eqtb| entry
in region 1 or~2. (Similar routines for the other regions will appear
below.)

@<Show equivalent |n|, in region 1 or 2@>=
begin sprint_cs(n); print_char("="); print_cmd_chr(eq_type(n),equiv(n));
if eq_type(n)>=call then
  begin print_char(":"); show_token_list(link(equiv(n)),null,32);
  end;
end

@ Region 3 of |eqtb| contains the |number_regs| \.{\\skip} registers, as well as the
glue parameters defined here. It is important that the ``muskip''
parameters have larger numbers than the others.

@d line_skip_code=0 {interline glue if |baseline_skip| is infeasible}
@d baseline_skip_code=1 {desired glue between baselines}
@d par_skip_code=2 {extra glue just above a paragraph}
@d above_display_skip_code=3 {extra glue just above displayed math}
@d below_display_skip_code=4 {extra glue just below displayed math}
@d above_display_short_skip_code=5
  {glue above displayed math following short lines}
@d below_display_short_skip_code=6
  {glue below displayed math following short lines}
@d left_skip_code=7 {glue at left of justified lines}
@d right_skip_code=8 {glue at right of justified lines}
@d top_skip_code=9 {glue at top of main pages}
@d split_top_skip_code=10 {glue at top of split pages}
@d tab_skip_code=11 {glue between aligned entries}
@d space_skip_code=12 {glue between words (if not |zero_glue|)}
@d xspace_skip_code=13 {glue after sentences (if not |zero_glue|)}
@d par_fill_skip_code=14 {glue on last line of paragraph}
@d thin_mu_skip_code=15 {thin space in math formula}
@d med_mu_skip_code=16 {medium space in math formula}
@d thick_mu_skip_code=17 {thick space in math formula}
@d glue_pars=18 {total number of glue parameters}
@d skip_base=glue_base+glue_pars {table of |number_regs| ``skip'' registers}
@d mu_skip_base=skip_base+number_regs {table of |number_regs| ``muskip'' registers}
@d local_base=mu_skip_base+number_regs {beginning of region 4}
@#
@d skip(#)==equiv(skip_base+#) {|mem| location of glue specification}
@d mu_skip(#)==equiv(mu_skip_base+#) {|mem| location of math glue spec}
@d glue_par(#)==equiv(glue_base+#) {|mem| location of glue specification}
@d line_skip==glue_par(line_skip_code)
@d baseline_skip==glue_par(baseline_skip_code)
@d par_skip==glue_par(par_skip_code)
@d above_display_skip==glue_par(above_display_skip_code)
@d below_display_skip==glue_par(below_display_skip_code)
@d above_display_short_skip==glue_par(above_display_short_skip_code)
@d below_display_short_skip==glue_par(below_display_short_skip_code)
@d left_skip==glue_par(left_skip_code)
@d right_skip==glue_par(right_skip_code)
@d top_skip==glue_par(top_skip_code)
@d split_top_skip==glue_par(split_top_skip_code)
@d tab_skip==glue_par(tab_skip_code)
@d space_skip==glue_par(space_skip_code)
@d xspace_skip==glue_par(xspace_skip_code)
@d par_fill_skip==glue_par(par_fill_skip_code)
@d thin_mu_skip==glue_par(thin_mu_skip_code)
@d med_mu_skip==glue_par(med_mu_skip_code)
@d thick_mu_skip==glue_par(thick_mu_skip_code)

@<Current |mem| equivalent of glue parameter number |n|@>=glue_par(n)

@ @<Set init...@>=
static_local_base:=local_base;
static_glue_base:=glue_base;

@ Sometimes we need to convert \TeX's internal code numbers into symbolic
form. The |print_skip_param| routine gives the symbolic name of a glue
parameter.

@<Declare the procedure called |print_skip_param|@>=
procedure print_skip_param(@!n:integer);
begin case n of
line_skip_code: print_esc("lineskip");
baseline_skip_code: print_esc("baselineskip");
par_skip_code: print_esc("parskip");
above_display_skip_code: print_esc("abovedisplayskip");
below_display_skip_code: print_esc("belowdisplayskip");
above_display_short_skip_code: print_esc("abovedisplayshortskip");
below_display_short_skip_code: print_esc("belowdisplayshortskip");
left_skip_code: print_esc("leftskip");
right_skip_code: print_esc("rightskip");
top_skip_code: print_esc("topskip");
split_top_skip_code: print_esc("splittopskip");
tab_skip_code: print_esc("tabskip");
space_skip_code: print_esc("spaceskip");
xspace_skip_code: print_esc("xspaceskip");
par_fill_skip_code: print_esc("parfillskip");
thin_mu_skip_code: print_esc("thinmuskip");
med_mu_skip_code: print_esc("medmuskip");
thick_mu_skip_code: print_esc("thickmuskip");
othercases print("[unknown glue parameter!]")
endcases;
end;

@ The symbolic names for glue parameters are put into \TeX's hash table
by using the routine called |primitive|, defined below. Let us enter them
now, so that we don't have to list all those parameter names anywhere else.

@<Put each of \TeX's primitives into the hash table@>=
primitive_tex("lineskip",assign_glue,glue_base+line_skip_code,glue_base);@/
@!@:line_skip_}{\.{\\lineskip} primitive@>
primitive_tex("baselineskip",assign_glue,glue_base+baseline_skip_code,glue_base);@/
@!@:baseline_skip_}{\.{\\baselineskip} primitive@>
primitive_tex("parskip",assign_glue,glue_base+par_skip_code,glue_base);@/
@!@:par_skip_}{\.{\\parskip} primitive@>
primitive_tex("abovedisplayskip",assign_glue,glue_base+above_display_skip_code,glue_base);@/
@!@:above_display_skip_}{\.{\\abovedisplayskip} primitive@>
primitive_tex("belowdisplayskip",assign_glue,glue_base+below_display_skip_code,glue_base);@/
@!@:below_display_skip_}{\.{\\belowdisplayskip} primitive@>
primitive_tex("abovedisplayshortskip",assign_glue,glue_base+above_display_short_skip_code,glue_base);@/
@!@:above_display_short_skip_}{\.{\\abovedisplayshortskip} primitive@>
primitive_tex("belowdisplayshortskip",assign_glue,glue_base+below_display_short_skip_code,glue_base);@/
@!@:below_display_short_skip_}{\.{\\belowdisplayshortskip} primitive@>
primitive_tex("leftskip",assign_glue,glue_base+left_skip_code,glue_base);@/
@!@:left_skip_}{\.{\\leftskip} primitive@>
primitive_tex("rightskip",assign_glue,glue_base+right_skip_code,glue_base);@/
@!@:right_skip_}{\.{\\rightskip} primitive@>
primitive_tex("topskip",assign_glue,glue_base+top_skip_code,glue_base);@/
@!@:top_skip_}{\.{\\topskip} primitive@>
primitive_tex("splittopskip",assign_glue,glue_base+split_top_skip_code,glue_base);@/
@!@:split_top_skip_}{\.{\\splittopskip} primitive@>
primitive_tex("tabskip",assign_glue,glue_base+tab_skip_code,glue_base);@/
@!@:tab_skip_}{\.{\\tabskip} primitive@>
primitive_tex("spaceskip",assign_glue,glue_base+space_skip_code,glue_base);@/
@!@:space_skip_}{\.{\\spaceskip} primitive@>
primitive_tex("xspaceskip",assign_glue,glue_base+xspace_skip_code,glue_base);@/
@!@:xspace_skip_}{\.{\\xspaceskip} primitive@>
primitive_tex("parfillskip",assign_glue,glue_base+par_fill_skip_code,glue_base);@/
@!@:par_fill_skip_}{\.{\\parfillskip} primitive@>
primitive_tex("thinmuskip",assign_mu_glue,glue_base+thin_mu_skip_code,glue_base+thin_mu_skip_code);@/
@!@:thin_mu_skip_}{\.{\\thinmuskip} primitive@>
primitive_tex("medmuskip",assign_mu_glue,glue_base+med_mu_skip_code,glue_base+thin_mu_skip_code);@/
@!@:med_mu_skip_}{\.{\\medmuskip} primitive@>
primitive_tex("thickmuskip",assign_mu_glue,glue_base+thick_mu_skip_code,glue_base+thin_mu_skip_code);@/
@!@:thick_mu_skip_}{\.{\\thickmuskip} primitive@>

@ All glue parameters and registers are initially `\.{0pt plus0pt minus0pt}'.

@<Initialize table entries...@>=
equiv(glue_base):=zero_glue; eq_level(glue_base):=level_one;
eq_type(glue_base):=glue_ref;
for k:=glue_base+1 to local_base-1 do eqtb[k]:=eqtb[glue_base];
glue_ref_count(zero_glue):=glue_ref_count(zero_glue)+local_base-glue_base;

@ @<Show equivalent |n|, in region 3@>=
begin
if n<skip_base then
  begin print_skip_param(n-glue_base); print_char("=");
  if n<glue_base+thin_mu_skip_code then print_spec(equiv(n),'pt')
  else print_spec(equiv(n),'mu');
  end
else if n<mu_skip_base then
  begin print_esc("skip"); print_int(n-skip_base); print_char("=");
  print_spec(equiv(n),'pt');
  end
else  begin print_esc("muskip"); print_int(n-mu_skip_base); print_char("=");
  print_spec(equiv(n),'mu');
  end;
end

@ Region 4 of |eqtb| contains the local quantities defined here. The
bulk of this region is taken up by five tables that are indexed by eight-bit
characters; these tables are important to both the syntactic and semantic
portions of \TeX. There are also a bunch of special things like font and
token parameters, as well as the tables of \.{\\toks} and \.{\\box}
registers.

@d par_shape_loc=local_base {specifies paragraph shape}
@d output_routine_loc=local_base+1 {points to token list for \.{\\output}}
@d every_par_loc=local_base+2 {points to token list for \.{\\everypar}}
@d every_math_loc=local_base+3 {points to token list for \.{\\everymath}}
@d every_display_loc=local_base+4 {points to token list for \.{\\everydisplay}}
@d every_hbox_loc=local_base+5 {points to token list for \.{\\everyhbox}}
@d every_vbox_loc=local_base+6 {points to token list for \.{\\everyvbox}}
@d every_job_loc=local_base+7 {points to token list for \.{\\everyjob}}
@d every_cr_loc=local_base+8 {points to token list for \.{\\everycr}}
@d err_help_loc=local_base+9 {points to token list for \.{\\errhelp}}
@d tex_toks=local_base+10 {end of \TeX's token list parameters}
@#
@d pdftex_first_loc       = tex_toks {base for \pdfTeX's token list parameters}
@d pdf_pages_attr_loc     = pdftex_first_loc + 0 {points to token list for \.{\\pdfpagesattr}}
@d pdf_page_attr_loc      = pdftex_first_loc + 1 {points to token list for \.{\\pdfpageattr}}
@d pdf_page_resources_loc = pdftex_first_loc + 2 {points to token list for \.{\\pdfpageresources}}
@d pdf_pk_mode_loc        = pdftex_first_loc + 3 {points to token list for \.{\\pdfpkmode}}
@d pdf_toks=pdftex_first_loc+4 {end of \pdfTeX's token list parameters}
@#
@d etex_toks_base=pdf_toks {base for \eTeX's token list parameters}
@d every_eof_loc=etex_toks_base {points to token list for \.{\\everyeof}}
@d etex_toks=etex_toks_base+1 {end of \eTeX's token list parameters}
@#
@d ocp_trace_level_base=etex_toks
@d ocp_active_number_base=ocp_trace_level_base+1
@d ocp_active_min_ptr_base = ocp_active_number_base+1
@d ocp_active_max_ptr_base = ocp_active_min_ptr_base+1
@d ocp_active_base = ocp_active_max_ptr_base+1
@d toks_base       = ocp_active_base+max_active_ocp_lists
   {table of |number_regs| token list registers}
@#
@d etex_pen_base=toks_base+number_regs {start of table of \eTeX's penalties}
@d inter_line_penalties_loc=etex_pen_base {additional penalties between lines}
@d club_penalties_loc=etex_pen_base+1 {penalties for creating club lines}
@d widow_penalties_loc=etex_pen_base+2 {penalties for creating widow lines}
@d display_widow_penalties_loc=etex_pen_base+3 {ditto, just before a display}
@d etex_pens=etex_pen_base+4 {end of table of \eTeX's penalties}
@#
@d local_left_box_base=etex_pens
@d local_right_box_base=local_left_box_base+1
@d box_base=local_right_box_base+1 {table of |number_regs| box registers}
@d cur_font_loc=box_base+number_regs {internal font number outside math mode}
@d math_param_base=cur_font_loc+1  {current math parameter data index }
@d cat_code_base=math_param_base+1 {current category code data index }
@d lc_code_base=cat_code_base+1 {table of |number_chars| lowercase mappings}
@d uc_code_base=lc_code_base+1 {table of |number_chars| uppercase mappings}
@d sf_code_base=uc_code_base+1 {table of |number_chars| spacefactor mappings}
@d math_code_base=sf_code_base+1 {table of |number_chars| math mode mappings}
@d int_base=math_code_base+1 {beginning of region 5}
@#
@d par_shape_ptr==equiv(par_shape_loc)
@d output_routine==equiv(output_routine_loc)
@d every_par==equiv(every_par_loc)
@d every_math==equiv(every_math_loc)
@d every_display==equiv(every_display_loc)
@d every_hbox==equiv(every_hbox_loc)
@d every_vbox==equiv(every_vbox_loc)
@d every_job==equiv(every_job_loc)
@d every_cr==equiv(every_cr_loc)
@d err_help==equiv(err_help_loc)
@d pdf_pages_attr==equiv(pdf_pages_attr_loc)
@d pdf_page_attr==equiv(pdf_page_attr_loc)
@d pdf_page_resources==equiv(pdf_page_resources_loc)
@d pdf_pk_mode==equiv(pdf_pk_mode_loc)
@d toks(#)==equiv(toks_base+#)
@d local_left_box==equiv(local_left_box_base)
@d local_right_box==equiv(local_right_box_base)
@d box(#)==equiv(box_base+#)
@d cur_font==equiv(cur_font_loc)

@<Put each...@>=
primitive_tex("output",assign_toks,output_routine_loc,local_base);
@!@:output_}{\.{\\output} primitive@>
primitive_tex("everypar",assign_toks,every_par_loc,local_base);
@!@:every_par_}{\.{\\everypar} primitive@>
primitive_tex("everymath",assign_toks,every_math_loc,local_base);
@!@:every_math_}{\.{\\everymath} primitive@>
primitive_tex("everydisplay",assign_toks,every_display_loc,local_base);
@!@:every_display_}{\.{\\everydisplay} primitive@>
primitive_tex("everyhbox",assign_toks,every_hbox_loc,local_base);
@!@:every_hbox_}{\.{\\everyhbox} primitive@>
primitive_tex("everyvbox",assign_toks,every_vbox_loc,local_base);
@!@:every_vbox_}{\.{\\everyvbox} primitive@>
primitive_tex("everyjob",assign_toks,every_job_loc,local_base);
@!@:every_job_}{\.{\\everyjob} primitive@>
primitive_tex("everycr",assign_toks,every_cr_loc,local_base);
@!@:every_cr_}{\.{\\everycr} primitive@>
primitive_tex("errhelp",assign_toks,err_help_loc,local_base);
@!@:err_help_}{\.{\\errhelp} primitive@>
primitive_pdftex("pdfpagesattr",assign_toks,pdf_pages_attr_loc,local_base);
@!@:pdf_pages_attr_}{\.{\\pdfpagesattr} primitive@>
primitive_pdftex("pdfpageattr",assign_toks,pdf_page_attr_loc,local_base);
@!@:pdf_page_attr_}{\.{\\pdfpageattr} primitive@>
primitive_pdftex("pdfpageresources",assign_toks,pdf_page_resources_loc,local_base);
@!@:pdf_page_resources_}{\.{\\pdfpageresources} primitive@>
primitive_pdftex("pdfpkmode",assign_toks,pdf_pk_mode_loc,local_base);
@!@:pdf_pk_mode_}{\.{\\pdfpkmode} primitive@>


@ We initialize most things to null or undefined values. An undefined font
is represented by the internal code |font_base|.

However, the character code tables are given initial values based on the
conventional interpretation of ASCII code. These initial values should
not be changed when \TeX\ is adapted for use with non-English languages;
all changes to the initialization conventions should be made in format
packages, not in \TeX\ itself, so that global interchange of formats is
possible.

@d null_font==font_base
@d var_code==7 {math code meaning ``use the current family''}

@<Initialize table entries...@>=
par_shape_ptr:=null; eq_type(par_shape_loc):=shape_ref;
eq_level(par_shape_loc):=level_one;@/
for k:=etex_pen_base to etex_pens-1 do
  eqtb[k]:=eqtb[par_shape_loc];
for k:=output_routine_loc to toks_base+biggest_reg do
  eqtb[k]:=eqtb[undefined_control_sequence];
box(0):=null; eq_type(box_base):=box_ref; eq_level(box_base):=level_one;
for k:=box_base+1 to box_base+biggest_reg do eqtb[k]:=eqtb[box_base];
cur_font:=null_font; eq_type(cur_font_loc):=data;
eq_level(cur_font_loc):=level_one;@/
equiv(cat_code_base):=0; eq_type(cat_code_base):=data;
eq_level(cat_code_base):=level_one;@/
eqtb[math_param_base]:=eqtb[cat_code_base];
eqtb[lc_code_base] :=eqtb[cat_code_base];
eqtb[uc_code_base] :=eqtb[cat_code_base];
eqtb[sf_code_base] :=eqtb[cat_code_base];
eqtb[math_code_base]:=eqtb[cat_code_base];@/
cat_code_table:=0;
initialize_math_codes;
initialize_text_codes;
initex_cat_codes(0);
for k:="0" to "9" do set_math_code(k,tex_mathcode,var_code,0,k,level_one);@/
for k:="A" to "Z" do begin
  set_math_code(k,tex_mathcode,var_code,1,k,level_one);
  set_math_code((k+32),tex_mathcode,var_code,1,(k+32),level_one);@/
  set_lc_code(k,k+32,level_one); set_lc_code(k+32,k+32,level_one);@/
  set_uc_code(k,k,level_one);    set_uc_code(k+32,k,level_one);@/
  set_sf_code(k,999,level_one);
  end;

@ @<Set init...@>=
static_int_base:=int_base;

@ @<Show equivalent |n|, in region 4@>=
begin
if (n=par_shape_loc) or ((n>=etex_pen_base) and (n<etex_pens)) then
  begin if n=par_shape_loc then print_cmd_chr(set_tex_shape,n)
  else  print_cmd_chr(set_etex_shape,n);
  print_char("=");
  if equiv(n)=null then print_char("0")
  else if n>par_shape_loc then
    begin print_int(penalty(equiv(n))); print_char(" ");
    print_int(penalty(equiv(n)+1));
    if penalty(equiv(n))>1 then print_esc("ETC.");
    end
  else print_int(vinfo(par_shape_ptr+1));
  end
else if n<toks_base then
  {TH TODO make extra cases for ocps here! }
  begin print_cmd_chr(assign_toks,n); print_char("=");
  if equiv(n)<>null then show_token_list(link(equiv(n)),null,32);
  end
else if n<box_base then
  begin print_esc("toks"); print_int(n-toks_base); print_char("=");
  if equiv(n)<>null then show_token_list(link(equiv(n)),null,32);
  end
else if n<cur_font_loc then
  begin print_esc("box"); print_int(n-box_base); print_char("=");
  if equiv(n)=null then print("void")
  else  begin depth_threshold:=0; breadth_max:=1; show_node_list(equiv(n));
    end;
  end
else if n=cur_font_loc then @<Show the font identifier in |eqtb[n]|@>;
end

@ @<Show the font identifier in |eqtb[n]|@>=
begin print("current font"); print_char("=");@/
print_esc(hash[font_id_base+equiv(n)].rh);
  {that's |font_id_text(equiv(n))|}
end

@ Region 5 of |eqtb| contains the integer parameters and registers defined
here, as well as the |del_code| table. The latter table differs from the
|cat_code..math_code| tables that precede it, since delimiter codes are
fullword integers while the other kinds of codes occupy at most a
halfword. This is what makes region~5 different from region~4. We will
store the |eq_level| information in an auxiliary array of quarterwords
that will be defined later.

@d pretolerance_code=0 {badness tolerance before hyphenation}
@d tolerance_code=1 {badness tolerance after hyphenation}
@d line_penalty_code=2 {added to the badness of every line}
@d hyphen_penalty_code=3 {penalty for break after discretionary hyphen}
@d ex_hyphen_penalty_code=4 {penalty for break after explicit hyphen}
@d club_penalty_code=5 {penalty for creating a club line}
@d widow_penalty_code=6 {penalty for creating a widow line}
@d display_widow_penalty_code=7 {ditto, just before a display}
@d broken_penalty_code=8 {penalty for breaking a page at a broken line}
@d bin_op_penalty_code=9 {penalty for breaking after a binary operation}
@d rel_penalty_code=10 {penalty for breaking after a relation}
@d pre_display_penalty_code=11 {penalty for breaking just before a displayed formula}
@d post_display_penalty_code=12 {penalty for breaking just after a displayed formula}
@d inter_line_penalty_code=13 {additional penalty between lines}
@d double_hyphen_demerits_code=14 {demerits for double hyphen break}
@d final_hyphen_demerits_code=15 {demerits for final hyphen break}
@d adj_demerits_code=16 {demerits for adjacent incompatible lines}
@d mag_code=17 {magnification ratio}
@d delimiter_factor_code=18 {ratio for variable-size delimiters}
@d looseness_code=19 {change in number of lines for a paragraph}
@d time_code=20 {current time of day}
@d day_code=21 {current day of the month}
@d month_code=22 {current month of the year}
@d year_code=23 {current year of our Lord}
@d show_box_breadth_code=24 {nodes per level in |show_box|}
@d show_box_depth_code=25 {maximum level in |show_box|}
@d hbadness_code=26 {hboxes exceeding this badness will be shown by |hpack|}
@d vbadness_code=27 {vboxes exceeding this badness will be shown by |vpack|}
@d pausing_code=28 {pause after each line is read from a file}
@d tracing_online_code=29 {show diagnostic output on terminal}
@d tracing_macros_code=30 {show macros as they are being expanded}
@d tracing_stats_code=31 {show memory usage if \TeX\ knows it}
@d tracing_paragraphs_code=32 {show line-break calculations}
@d tracing_pages_code=33 {show page-break calculations}
@d tracing_output_code=34 {show boxes when they are shipped out}
@d tracing_lost_chars_code=35 {show characters that aren't in the font}
@d tracing_commands_code=36 {show command codes at |big_switch|}
@d tracing_restores_code=37 {show equivalents when they are restored}
@d uc_hyph_code=38 {hyphenate words beginning with a capital letter}
@d output_penalty_code=39 {penalty found at current page break}
@d max_dead_cycles_code=40 {bound on consecutive dead cycles of output}
@d hang_after_code=41 {hanging indentation changes after this many lines}
@d floating_penalty_code=42 {penalty for insertions heldover after a split}
@d global_defs_code=43 {override \.{\\global} specifications}
@d cur_fam_code=44 {current family}
@d escape_char_code=45 {escape character for token output}
@d default_hyphen_char_code=46 {value of \.{\\hyphenchar} when a font is loaded}
@d default_skew_char_code=47 {value of \.{\\skewchar} when a font is loaded}
@d end_line_char_code=48 {character placed at the right end of the buffer}
@d new_line_char_code=49 {character that prints as |print_ln|}
@d language_code=50 {current hyphenation table}
@d left_hyphen_min_code=51 {minimum left hyphenation fragment size}
@d right_hyphen_min_code=52 {minimum right hyphenation fragment size}
@d holding_inserts_code=53 {do not remove insertion nodes from \.{\\box255}}
@d error_context_lines_code=54 {maximum intermediate line pairs shown}
@d local_inter_line_penalty_code=55 {local \.{\\interlinepenalty}}
@d local_broken_penalty_code=56 {local \.{\\brokenpenalty}}
@d no_local_whatsits_code=57 {counts local whatsits}
@d no_local_dirs_code=58
@d level_local_dir_code=59
@d luastartup_id_code=60
@d disable_lig_code=61
@d disable_kern_code=62
@d cat_code_table_code=63
@d output_box_code=64
@d cur_lang_code=65 {current language id}
@d ex_hyphen_char_code=66
@d tex_int_pars=67 {total number of \.{\\TeX} + Aleph integer parameters}
@#
@d dir_base=int_base+tex_int_pars
@d page_direction_code=0
@d body_direction_code=1
@d par_direction_code=2
@d text_direction_code=3
@d math_direction_code=4
@d dir_pars=5
@#
@d pdftex_first_integer_code = tex_int_pars+dir_pars {base for \pdfTeX's integer parameters}
@d pdf_output_code           = pdftex_first_integer_code + 0 {switch on PDF output if positive}
@d pdf_compress_level_code   = pdftex_first_integer_code + 1 {compress level of streams}
@d pdf_decimal_digits_code   = pdftex_first_integer_code + 2 {digits after the decimal point of numbers}
@d pdf_move_chars_code       = pdftex_first_integer_code + 3 {move chars 0..31 to higher area if possible}
@d pdf_image_resolution_code = pdftex_first_integer_code + 4 {default image resolution}
@d pdf_pk_resolution_code    = pdftex_first_integer_code + 5 {default resolution of PK font}
@d pdf_unique_resname_code   = pdftex_first_integer_code + 6 {generate unique names for resouces}
@d pdf_minor_version_code = pdftex_first_integer_code + 9 {fractional part of the PDF version produced}
@d pdf_pagebox_code = pdftex_first_integer_code + 11 {default pagebox to use for PDF inclusion}
@d pdf_inclusion_errorlevel_code = pdftex_first_integer_code + 12 {if the PDF inclusion should treat pdfs newer than |pdf_minor_version| as an error}
@d pdf_gamma_code            = pdftex_first_integer_code + 13
@d pdf_image_gamma_code      = pdftex_first_integer_code + 14
@d pdf_image_hicolor_code    = pdftex_first_integer_code + 15
@d pdf_image_apply_gamma_code = pdftex_first_integer_code + 16
@d pdf_adjust_spacing_code   = pdftex_first_integer_code + 17 {level of spacing adjusting}
@d pdf_protrude_chars_code   = pdftex_first_integer_code + 18 {protrude chars at left/right edge of paragraphs}
@d pdf_tracing_fonts_code    = pdftex_first_integer_code + 19 {level of font detail in log}
@d pdf_objcompresslevel_code = pdftex_first_integer_code + 20 {activate object streams}
@d pdf_gen_tounicode_code    = pdftex_first_integer_code + 24 {generate ToUnicode for fonts?}
@d pdf_draftmode_code        = pdftex_first_integer_code + 25 {switch on draftmode if positive}
@d pdf_replace_font_code     = pdftex_first_integer_code + 26 {generate ToUnicode for fonts?}
@d pdf_inclusion_copy_font_code = pdftex_first_integer_code + 27 {generate ToUnicode for fonts?}
@d pdf_int_pars=pdftex_first_integer_code + 28 {total number of \pdfTeX's integer parameters}
@#
@d etex_int_base=pdf_int_pars {base for \eTeX's integer parameters}
@d tracing_assigns_code=etex_int_base {show assignments}
@d tracing_groups_code=etex_int_base+1 {show save/restore groups}
@d tracing_ifs_code=etex_int_base+2 {show conditionals}
@d tracing_scan_tokens_code=etex_int_base+3 {show pseudo file open and close}
@d tracing_nesting_code=etex_int_base+4 {show incomplete groups and ifs within files}
@d pre_display_direction_code=etex_int_base+5 {text direction preceding a display}
@d last_line_fit_code=etex_int_base+6 {adjustment for last line of paragraph}
@d saving_vdiscards_code=etex_int_base+7 {save items discarded from vlists}
@d saving_hyph_codes_code=etex_int_base+8 {save hyphenation codes for languages}
@d suppress_fontnotfound_error_code=etex_int_base+9 {surpress errors for missing fonts}
@d suppress_long_error_code=etex_int_base+10 {surpress errors for missing fonts}
@d suppress_ifcsname_error_code=etex_int_base+11 {surpress errors for failed \.{\\ifcsname}}
@d suppress_outer_error_code=etex_int_base+12 {surpress errors for \.{\\outer}}
@d etex_int_pars=etex_int_base+13 {total number of \eTeX's integer parameters}
@#
@d synctex_code=etex_int_pars { is synctex file generation enabled ? }
@d int_pars=synctex_code+1 {total number of integer parameters}
@d count_base=int_base+int_pars {|number_regs| user \.{\\count} registers}
@d attribute_base=count_base+number_regs {|number_attrs| user \.{\\attribute} registers}
@d del_code_base=attribute_base+number_attrs {|number_chars| delimiter code mappings}
@d dimen_base=del_code_base+1 {beginning of region 6}
@#
@d count(#)==eqtb[count_base+#].int
@d attribute(#)==eqtb[attribute_base+#].int
@d int_par(#)==eqtb[int_base+#].int {an integer parameter}
@d pretolerance==int_par(pretolerance_code)
@d tolerance==int_par(tolerance_code)
@d line_penalty==int_par(line_penalty_code)
@d hyphen_penalty==int_par(hyphen_penalty_code)
@d ex_hyphen_penalty==int_par(ex_hyphen_penalty_code)
@d club_penalty==int_par(club_penalty_code)
@d widow_penalty==int_par(widow_penalty_code)
@d display_widow_penalty==int_par(display_widow_penalty_code)
@d broken_penalty==int_par(broken_penalty_code)
@d bin_op_penalty==int_par(bin_op_penalty_code)
@d rel_penalty==int_par(rel_penalty_code)
@d pre_display_penalty==int_par(pre_display_penalty_code)
@d post_display_penalty==int_par(post_display_penalty_code)
@d inter_line_penalty==int_par(inter_line_penalty_code)
@d double_hyphen_demerits==int_par(double_hyphen_demerits_code)
@d final_hyphen_demerits==int_par(final_hyphen_demerits_code)
@d adj_demerits==int_par(adj_demerits_code)
@d mag==int_par(mag_code)
@d delimiter_factor==int_par(delimiter_factor_code)
@d looseness==int_par(looseness_code)
@d time==int_par(time_code)
@d day==int_par(day_code)
@d month==int_par(month_code)
@d year==int_par(year_code)
@d show_box_breadth==int_par(show_box_breadth_code)
@d show_box_depth==int_par(show_box_depth_code)
@d hbadness==int_par(hbadness_code)
@d vbadness==int_par(vbadness_code)
@d pausing==int_par(pausing_code)
@d tracing_online==int_par(tracing_online_code)
@d tracing_macros==int_par(tracing_macros_code)
@d tracing_stats==int_par(tracing_stats_code)
@d tracing_paragraphs==int_par(tracing_paragraphs_code)
@d tracing_pages==int_par(tracing_pages_code)
@d tracing_output==int_par(tracing_output_code)
@d tracing_lost_chars==int_par(tracing_lost_chars_code)
@d tracing_commands==int_par(tracing_commands_code)
@d tracing_restores==int_par(tracing_restores_code)
@d uc_hyph==int_par(uc_hyph_code)
@d output_penalty==int_par(output_penalty_code)
@d max_dead_cycles==int_par(max_dead_cycles_code)
@d hang_after==int_par(hang_after_code)
@d floating_penalty==int_par(floating_penalty_code)
@d global_defs==int_par(global_defs_code)
@d cur_fam==int_par(cur_fam_code)
@d escape_char==int_par(escape_char_code)
@d default_hyphen_char==int_par(default_hyphen_char_code)
@d default_skew_char==int_par(default_skew_char_code)
@d end_line_char==int_par(end_line_char_code)
@d new_line_char==int_par(new_line_char_code)
@d local_inter_line_penalty==int_par(local_inter_line_penalty_code)
@d local_broken_penalty==int_par(local_broken_penalty_code)
@d no_local_whatsits==int_par(no_local_whatsits_code)
@d no_local_dirs==int_par(no_local_dirs_code)
@d level_local_dir==int_par(level_local_dir_code)
@d dir_par(#)==eqtb[dir_base+#].int {a direction parameter}
@d page_direction==dir_par(page_direction_code)
@d body_direction==dir_par(body_direction_code)
@d par_direction==dir_par(par_direction_code)
@d text_direction==dir_par(text_direction_code)
@d math_direction==dir_par(math_direction_code)
@d language==int_par(language_code)
@d cur_lang==int_par(cur_lang_code)
@d ex_hyphen_char==int_par(ex_hyphen_char_code)
@d left_hyphen_min==int_par(left_hyphen_min_code)
@d right_hyphen_min==int_par(right_hyphen_min_code)
@d holding_inserts==int_par(holding_inserts_code)
@d error_context_lines==int_par(error_context_lines_code)
@d luastartup_id==int_par(luastartup_id_code)
@d disable_lig==int_par(disable_lig_code)
@d disable_kern==int_par(disable_kern_code)
@d cat_code_table==int_par(cat_code_table_code)
@d output_box==int_par(output_box_code)
@#
@d pdf_adjust_spacing   == int_par(pdf_adjust_spacing_code)
@d pdf_protrude_chars   == int_par(pdf_protrude_chars_code)
@d pdf_tracing_fonts    == int_par(pdf_tracing_fonts_code)
@d pdf_gen_tounicode    == int_par(pdf_gen_tounicode_code)
@d pdf_output           == int_par(pdf_output_code)
@d pdf_compress_level   == int_par(pdf_compress_level_code)
@d pdf_objcompresslevel == int_par(pdf_objcompresslevel_code)
@d pdf_decimal_digits   == int_par(pdf_decimal_digits_code)
@d pdf_move_chars       == int_par(pdf_move_chars_code)
@d pdf_image_resolution == int_par(pdf_image_resolution_code)
@d pdf_pk_resolution    == int_par(pdf_pk_resolution_code)
@d pdf_unique_resname   == int_par(pdf_unique_resname_code)
@d pdf_minor_version == int_par(pdf_minor_version_code)
@d pdf_pagebox == int_par(pdf_pagebox_code)
@d pdf_inclusion_errorlevel == int_par(pdf_inclusion_errorlevel_code)
@d pdf_gamma            == int_par(pdf_gamma_code)
@d pdf_image_gamma      == int_par(pdf_image_gamma_code)
@d pdf_image_hicolor    == int_par(pdf_image_hicolor_code)
@d pdf_image_apply_gamma == int_par(pdf_image_apply_gamma_code)
@d pdf_draftmode        == int_par(pdf_draftmode_code)
@d pdf_inclusion_copy_font == int_par(pdf_inclusion_copy_font_code)
@d pdf_replace_font == int_par(pdf_replace_font_code)
@#
@d tracing_assigns==int_par(tracing_assigns_code)
@d tracing_groups==int_par(tracing_groups_code)
@d tracing_ifs==int_par(tracing_ifs_code)
@d tracing_scan_tokens==int_par(tracing_scan_tokens_code)
@d tracing_nesting==int_par(tracing_nesting_code)
@d pre_display_direction==int_par(pre_display_direction_code)
@d last_line_fit==int_par(last_line_fit_code)
@d saving_vdiscards==int_par(saving_vdiscards_code)
@d saving_hyph_codes==int_par(saving_hyph_codes_code)
@d suppress_fontnotfound_error==int_par(suppress_fontnotfound_error_code)
@d suppress_long_error==int_par(suppress_long_error_code)
@d suppress_ifcsname_error==int_par(suppress_ifcsname_error_code)
@d synctex==int_par(synctex_code)

@<Assign the values |depth_threshold:=show_box_depth|...@>=
depth_threshold:=show_box_depth;
breadth_max:=show_box_breadth


@ @<Set init...@>=
static_dimen_base:=dimen_base;

@ We can print the symbolic name of an integer parameter as follows.

@p procedure print_param(@!n:integer);
begin case n of
pretolerance_code:print_esc("pretolerance");
tolerance_code:print_esc("tolerance");
line_penalty_code:print_esc("linepenalty");
hyphen_penalty_code:print_esc("hyphenpenalty");
ex_hyphen_penalty_code:print_esc("exhyphenpenalty");
club_penalty_code:print_esc("clubpenalty");
widow_penalty_code:print_esc("widowpenalty");
display_widow_penalty_code:print_esc("displaywidowpenalty");
broken_penalty_code:print_esc("brokenpenalty");
bin_op_penalty_code:print_esc("binoppenalty");
rel_penalty_code:print_esc("relpenalty");
pre_display_penalty_code:print_esc("predisplaypenalty");
post_display_penalty_code:print_esc("postdisplaypenalty");
inter_line_penalty_code:print_esc("interlinepenalty");
double_hyphen_demerits_code:print_esc("doublehyphendemerits");
final_hyphen_demerits_code:print_esc("finalhyphendemerits");
adj_demerits_code:print_esc("adjdemerits");
mag_code:print_esc("mag");
delimiter_factor_code:print_esc("delimiterfactor");
looseness_code:print_esc("looseness");
time_code:print_esc("time");
day_code:print_esc("day");
month_code:print_esc("month");
year_code:print_esc("year");
show_box_breadth_code:print_esc("showboxbreadth");
show_box_depth_code:print_esc("showboxdepth");
hbadness_code:print_esc("hbadness");
vbadness_code:print_esc("vbadness");
pausing_code:print_esc("pausing");
tracing_online_code:print_esc("tracingonline");
tracing_macros_code:print_esc("tracingmacros");
tracing_stats_code:print_esc("tracingstats");
tracing_paragraphs_code:print_esc("tracingparagraphs");
tracing_pages_code:print_esc("tracingpages");
tracing_output_code:print_esc("tracingoutput");
tracing_lost_chars_code:print_esc("tracinglostchars");
tracing_commands_code:print_esc("tracingcommands");
tracing_restores_code:print_esc("tracingrestores");
uc_hyph_code:print_esc("uchyph");
output_penalty_code:print_esc("outputpenalty");
max_dead_cycles_code:print_esc("maxdeadcycles");
hang_after_code:print_esc("hangafter");
floating_penalty_code:print_esc("floatingpenalty");
global_defs_code:print_esc("globaldefs");
cur_fam_code:print_esc("fam");
escape_char_code:print_esc("escapechar");
default_hyphen_char_code:print_esc("defaulthyphenchar");
default_skew_char_code:print_esc("defaultskewchar");
end_line_char_code:print_esc("endlinechar");
new_line_char_code:print_esc("newlinechar");
language_code:print_esc("language");
cur_lang_code:print_esc("setlanguage");
ex_hyphen_char_code:print_esc("exhyphenchar");
left_hyphen_min_code:print_esc("lefthyphenmin");
right_hyphen_min_code:print_esc("righthyphenmin");
holding_inserts_code:print_esc("holdinginserts");
error_context_lines_code:print_esc("errorcontextlines");
luastartup_id_code:print_esc("luastartup");
disable_lig_code:print_esc("noligs");
disable_kern_code:print_esc("nokerns");
cat_code_table_code:print_esc("catcodetable");
output_box_code:print_esc("outputbox");
@#
local_inter_line_penalty_code: print_esc("localinterlinepenalty");
local_broken_penalty_code: print_esc("localbrokenpenalty");
{the next three do not have a matching primitive}
no_local_whatsits_code: print("[no_local_whatsits]");
no_local_dirs_code: print("[no_local_dirs]");
level_local_dir_code: print("[level_local_dir]");
@#
pdf_output_code:           print_esc("pdfoutput");
pdf_compress_level_code:   print_esc("pdfcompresslevel");
pdf_objcompresslevel_code: print_esc("pdfobjcompresslevel");
pdf_decimal_digits_code:   print_esc("pdfdecimaldigits");
pdf_image_resolution_code: print_esc("pdfimageresolution");
pdf_pk_resolution_code:    print_esc("pdfpkresolution");
pdf_unique_resname_code:   print_esc("pdfuniqueresname");
pdf_minor_version_code: print_esc("pdfminorversion");
pdf_pagebox_code: print_esc("pdfpagebox");
pdf_inclusion_errorlevel_code: print_esc("pdfinclusionerrorlevel");
pdf_gamma_code:            print_esc("pdfgamma");
pdf_image_gamma_code:      print_esc("pdfimagegamma");
pdf_image_hicolor_code:    print_esc("pdfimagehicolor");
pdf_image_apply_gamma_code: print_esc("pdfimageapplygamma");
pdf_adjust_spacing_code:   print_esc("pdfadjustspacing");
pdf_protrude_chars_code:   print_esc("pdfprotrudechars");
pdf_tracing_fonts_code:    print_esc("pdftracingfonts");
pdf_gen_tounicode_code:    print_esc("pdfgentounicode");
pdf_draftmode_code:        print_esc("pdfdraftmode");
pdf_inclusion_copy_font_code:    print_esc("pdfinclusioncopyfonts");
pdf_replace_font_code:    print_esc("pdfreplacefont");
@/@<Cases for |print_param|@>@/
othercases begin print("[unknown integer parameter!]"); end
endcases;
end;

@ The integer parameter names must be entered into the hash table.

@<Put each...@>=
primitive_tex("pretolerance",assign_int,int_base+pretolerance_code,int_base);@/
@!@:pretolerance_}{\.{\\pretolerance} primitive@>
primitive_tex("tolerance",assign_int,int_base+tolerance_code,int_base);@/
@!@:tolerance_}{\.{\\tolerance} primitive@>
primitive_tex("linepenalty",assign_int,int_base+line_penalty_code,int_base);@/
@!@:line_penalty_}{\.{\\linepenalty} primitive@>
primitive_tex("hyphenpenalty",assign_int,int_base+hyphen_penalty_code,int_base);@/
@!@:hyphen_penalty_}{\.{\\hyphenpenalty} primitive@>
primitive_tex("exhyphenpenalty",assign_int,int_base+ex_hyphen_penalty_code,int_base);@/
@!@:ex_hyphen_penalty_}{\.{\\exhyphenpenalty} primitive@>
primitive_tex("clubpenalty",assign_int,int_base+club_penalty_code,int_base);@/
@!@:club_penalty_}{\.{\\clubpenalty} primitive@>
primitive_tex("widowpenalty",assign_int,int_base+widow_penalty_code,int_base);@/
@!@:widow_penalty_}{\.{\\widowpenalty} primitive@>
primitive_tex("displaywidowpenalty", assign_int,int_base+display_widow_penalty_code,int_base);@/
@!@:display_widow_penalty_}{\.{\\displaywidowpenalty} primitive@>
primitive_tex("brokenpenalty",assign_int,int_base+broken_penalty_code,int_base);@/
@!@:broken_penalty_}{\.{\\brokenpenalty} primitive@>
primitive_tex("binoppenalty",assign_int,int_base+bin_op_penalty_code,int_base);@/
@!@:bin_op_penalty_}{\.{\\binoppenalty} primitive@>
primitive_tex("relpenalty",assign_int,int_base+rel_penalty_code,int_base);@/
@!@:rel_penalty_}{\.{\\relpenalty} primitive@>
primitive_tex("predisplaypenalty",assign_int,int_base+pre_display_penalty_code,int_base);@/
@!@:pre_display_penalty_}{\.{\\predisplaypenalty} primitive@>
primitive_tex("postdisplaypenalty",assign_int,int_base+post_display_penalty_code,int_base);@/
@!@:post_display_penalty_}{\.{\\postdisplaypenalty} primitive@>
primitive_tex("interlinepenalty",assign_int,int_base+inter_line_penalty_code,int_base);@/
@!@:inter_line_penalty_}{\.{\\interlinepenalty} primitive@>
primitive_tex("doublehyphendemerits", assign_int,int_base+double_hyphen_demerits_code,int_base);@/
@!@:double_hyphen_demerits_}{\.{\\doublehyphendemerits} primitive@>
primitive_tex("finalhyphendemerits", assign_int,int_base+final_hyphen_demerits_code,int_base);@/
@!@:final_hyphen_demerits_}{\.{\\finalhyphendemerits} primitive@>
primitive_tex("adjdemerits",assign_int,int_base+adj_demerits_code,int_base);@/
@!@:adj_demerits_}{\.{\\adjdemerits} primitive@>
primitive_tex("mag",assign_int,int_base+mag_code,int_base);@/
@!@:mag_}{\.{\\mag} primitive@>
primitive_tex("delimiterfactor",assign_int,int_base+delimiter_factor_code,int_base);@/
@!@:delimiter_factor_}{\.{\\delimiterfactor} primitive@>
primitive_tex("looseness",assign_int,int_base+looseness_code,int_base);@/
@!@:looseness_}{\.{\\looseness} primitive@>
primitive_tex("time",assign_int,int_base+time_code,int_base);@/
@!@:time_}{\.{\\time} primitive@>
primitive_tex("day",assign_int,int_base+day_code,int_base);@/
@!@:day_}{\.{\\day} primitive@>
primitive_tex("month",assign_int,int_base+month_code,int_base);@/
@!@:month_}{\.{\\month} primitive@>
primitive_tex("year",assign_int,int_base+year_code,int_base);@/
@!@:year_}{\.{\\year} primitive@>
primitive_tex("showboxbreadth",assign_int,int_base+show_box_breadth_code,int_base);@/
@!@:show_box_breadth_}{\.{\\showboxbreadth} primitive@>
primitive_tex("showboxdepth",assign_int,int_base+show_box_depth_code,int_base);@/
@!@:show_box_depth_}{\.{\\showboxdepth} primitive@>
primitive_tex("hbadness",assign_int,int_base+hbadness_code,int_base);@/
@!@:hbadness_}{\.{\\hbadness} primitive@>
primitive_tex("vbadness",assign_int,int_base+vbadness_code,int_base);@/
@!@:vbadness_}{\.{\\vbadness} primitive@>
primitive_tex("pausing",assign_int,int_base+pausing_code,int_base);@/
@!@:pausing_}{\.{\\pausing} primitive@>
primitive_tex("tracingonline",assign_int,int_base+tracing_online_code,int_base);@/
@!@:tracing_online_}{\.{\\tracingonline} primitive@>
primitive_tex("tracingmacros",assign_int,int_base+tracing_macros_code,int_base);@/
@!@:tracing_macros_}{\.{\\tracingmacros} primitive@>
primitive_tex("tracingstats",assign_int,int_base+tracing_stats_code,int_base);@/
@!@:tracing_stats_}{\.{\\tracingstats} primitive@>
primitive_tex("tracingparagraphs",assign_int,int_base+tracing_paragraphs_code,int_base);@/
@!@:tracing_paragraphs_}{\.{\\tracingparagraphs} primitive@>
primitive_tex("tracingpages",assign_int,int_base+tracing_pages_code,int_base);@/
@!@:tracing_pages_}{\.{\\tracingpages} primitive@>
primitive_tex("tracingoutput",assign_int,int_base+tracing_output_code,int_base);@/
@!@:tracing_output_}{\.{\\tracingoutput} primitive@>
primitive_tex("tracinglostchars",assign_int,int_base+tracing_lost_chars_code,int_base);@/
@!@:tracing_lost_chars_}{\.{\\tracinglostchars} primitive@>
primitive_tex("tracingcommands",assign_int,int_base+tracing_commands_code,int_base);@/
@!@:tracing_commands_}{\.{\\tracingcommands} primitive@>
primitive_tex("tracingrestores",assign_int,int_base+tracing_restores_code,int_base);@/
@!@:tracing_restores_}{\.{\\tracingrestores} primitive@>
primitive_tex("uchyph",assign_int,int_base+uc_hyph_code,int_base);@/
@!@:uc_hyph_}{\.{\\uchyph} primitive@>
primitive_tex("outputpenalty",assign_int,int_base+output_penalty_code,int_base);@/
@!@:output_penalty_}{\.{\\outputpenalty} primitive@>
primitive_tex("maxdeadcycles",assign_int,int_base+max_dead_cycles_code,int_base);@/
@!@:max_dead_cycles_}{\.{\\maxdeadcycles} primitive@>
primitive_tex("hangafter",assign_int,int_base+hang_after_code,int_base);@/
@!@:hang_after_}{\.{\\hangafter} primitive@>
primitive_tex("floatingpenalty",assign_int,int_base+floating_penalty_code,int_base);@/
@!@:floating_penalty_}{\.{\\floatingpenalty} primitive@>
primitive_tex("globaldefs",assign_int,int_base+global_defs_code,int_base);@/
@!@:global_defs_}{\.{\\globaldefs} primitive@>
primitive_tex("fam",assign_int,int_base+cur_fam_code,int_base);@/
@!@:fam_}{\.{\\fam} primitive@>
primitive_tex("escapechar",assign_int,int_base+escape_char_code,int_base);@/
@!@:escape_char_}{\.{\\escapechar} primitive@>
primitive_tex("defaulthyphenchar",assign_int,int_base+default_hyphen_char_code,int_base);@/
@!@:default_hyphen_char_}{\.{\\defaulthyphenchar} primitive@>
primitive_tex("defaultskewchar",assign_int,int_base+default_skew_char_code,int_base);@/
@!@:default_skew_char_}{\.{\\defaultskewchar} primitive@>
primitive_tex("endlinechar",assign_int,int_base+end_line_char_code,int_base);@/
@!@:end_line_char_}{\.{\\endlinechar} primitive@>
primitive_tex("newlinechar",assign_int,int_base+new_line_char_code,int_base);@/
@!@:new_line_char_}{\.{\\newlinechar} primitive@>
primitive_tex("language",assign_int,int_base+language_code,int_base);@/
@!@:language_}{\.{\\language} primitive@>
primitive_tex("setlanguage",assign_int,int_base+cur_lang_code,int_base);@/
@!@:cur_lang_}{\.{\\setlanguage} primitive@>
primitive_tex("exhyphenchar",assign_int,int_base+ex_hyphen_char_code,int_base);@/
@!@:ex_hyphen_char_}{\.{\\exhyphenchar} primitive@>
primitive_tex("lefthyphenmin",assign_int,int_base+left_hyphen_min_code,int_base);@/
@!@:left_hyphen_min_}{\.{\\lefthyphenmin} primitive@>
primitive_tex("righthyphenmin",assign_int,int_base+right_hyphen_min_code,int_base);@/
@!@:right_hyphen_min_}{\.{\\righthyphenmin} primitive@>
primitive_tex("holdinginserts",assign_int,int_base+holding_inserts_code,int_base);@/
@!@:holding_inserts_}{\.{\\holdinginserts} primitive@>
primitive_tex("errorcontextlines",assign_int,int_base+error_context_lines_code,int_base);@/
@!@:error_context_lines_}{\.{\\errorcontextlines} primitive@>
primitive_luatex("luastartup",assign_int,int_base+luastartup_id_code,int_base);@/
@!@:luastartup_id_}{\.{\\luastartup} primitive@>
primitive_luatex("nokerns",assign_int,int_base+disable_kern_code,int_base);@/
@!@:disable_kern_}{\.{\\noligkerns} primitive@>
primitive_luatex("noligs",assign_int,int_base+disable_lig_code,int_base);@/
@!@:disable_lig_}{\.{\\noligs} primitive@>
primitive_luatex("catcodetable",assign_int,int_base+cat_code_table_code,int_base);@/
@!@:cat_code_table_}{\.{\\catcodetable} primitive@>
primitive_luatex("outputbox",assign_int,int_base+output_box_code,int_base);@/
@!@:output_box_}{\.{\\outputbox} primitive@>
primitive_pdftex("pdfoutput",assign_int,int_base+pdf_output_code,int_base);@/
@!@:pdf_output_}{\.{\\pdfoutput} primitive@>
primitive_pdftex("pdfcompresslevel",assign_int,int_base+pdf_compress_level_code,int_base);@/
@!@:pdf_compress_level_}{\.{\\pdfcompresslevel} primitive@>
primitive_pdftex("pdfobjcompresslevel",assign_int,int_base+pdf_objcompresslevel_code,int_base);@/
@!@:pdf_objcompresslevel_}{\.{\\pdfobjcompresslevel} primitive@>
primitive_pdftex("pdfdecimaldigits",assign_int,int_base+pdf_decimal_digits_code,int_base);@/
@!@:pdf_decimal_digits_}{\.{\\pdfdecimaldigits} primitive@>
primitive_pdftex("pdfimageresolution",assign_int,int_base+pdf_image_resolution_code,int_base);@/
@!@:pdf_image_resolution_}{\.{\\pdfimageresolution} primitive@>
primitive_pdftex("pdfpkresolution",assign_int,int_base+pdf_pk_resolution_code,int_base);@/
@!@:pdf_pk_resolution_}{\.{\\pdfpkresolution} primitive@>
primitive_pdftex("pdfuniqueresname",assign_int,int_base+pdf_unique_resname_code,int_base);@/
@!@:pdf_unique_resname_}{\.{\\pdfuniqueresname} primitive@>
primitive_pdftex("pdfoptionpdfminorversion",assign_int,int_base+pdf_minor_version_code,int_base);@/
@!@:pdf_minor_version_}{\.{\\pdfoptionpdfminorversion} primitive@>
primitive_pdftex("pdfminorversion",assign_int,int_base+pdf_minor_version_code,int_base);@/
@!@:pdf_minor_version_}{\.{\\pdfminorversion} primitive@>
primitive_pdftex("pdfpagebox",assign_int,int_base+pdf_pagebox_code,int_base);@/
@!@:pdf_pagebox_}{\.{\\pdfpagebox} primitive@>
primitive_pdftex("pdfinclusionerrorlevel",assign_int,int_base+pdf_inclusion_errorlevel_code,int_base);@/
@!@:pdf_inclusion_errorlevel_}{\.{\\pdfinclusionerrorlevel} primitive@>
primitive_pdftex("pdfgamma",assign_int,int_base+pdf_gamma_code,int_base);@/
@!@:pdf_gamma_}{\.{\\pdfgamma} primitive@>
primitive_pdftex("pdfimagegamma",assign_int,int_base+pdf_image_gamma_code,int_base);@/
@!@:pdf_image_gamma_}{\.{\\pdfimagegamma} primitive@>
primitive_pdftex("pdfimagehicolor",assign_int,int_base+pdf_image_hicolor_code,int_base);@/
@!@:pdf_image_hicolor_}{\.{\\pdfimagehicolor} primitive@>
primitive_pdftex("pdfimageapplygamma",assign_int,int_base+pdf_image_apply_gamma_code,int_base);@/
@!@:pdf_image_apply_gamma_}{\.{\\pdfimageapplygamma} primitive@>
primitive_pdftex("pdfadjustspacing",assign_int,int_base+pdf_adjust_spacing_code,int_base);@/
@!@:pdf_adjust_spacing_}{\.{\\pdfadjustspacing} primitive@>
primitive_pdftex("pdfprotrudechars",assign_int,int_base+pdf_protrude_chars_code,int_base);@/
@!@:pdf_protrude_chars_}{\.{\\pdfprotrudechars} primitive@>
primitive_pdftex("pdftracingfonts",assign_int,int_base+pdf_tracing_fonts_code,int_base);@/
@!@:pdf_tracing_fonts_}{\.{\\pdftracingfonts} primitive@>
primitive_pdftex("pdfgentounicode",assign_int,int_base+pdf_gen_tounicode_code,int_base);@/
@!@:pdf_gen_tounicode_}{\.{\\pdfgentounicode} primitive@>
primitive_pdftex("pdfdraftmode",assign_int,int_base+pdf_draftmode_code,int_base);@/
@!@:pdf_draftmode_}{\.{\\pdfdraftmode} primitive@>
primitive_pdftex("pdfinclusioncopyfonts",assign_int,int_base+pdf_inclusion_copy_font_code,int_base);@/
@!@:pdf_inclusion_copy_font_}{\.{\\pdfinclusioncopyfonts} primitive@>
primitive_pdftex("pdfreplacefont",assign_int,int_base+pdf_replace_font_code,int_base);@/
@!@:pdf_replace_font_}{\.{\\pdfreplacefont} primitive@>

@ The integer parameters should really be initialized by a macro package;
the following initialization does the minimum to keep \TeX\ from
complete failure.
@^null delimiter@>

@<Initialize table entries...@>=
for k:=int_base to attribute_base-1 do eqtb[k].int:=0;
for k:=attribute_base to del_code_base-1 do eqtb[k].int:=UNUSED_ATTRIBUTE;
mag:=1000; tolerance:=10000; hang_after:=1; max_dead_cycles:=25;
escape_char:="\"; end_line_char:=carriage_return;
eqtb[int_base+level_local_dir_code].int:=level_one;
set_del_code(".",tex_mathcode,0,0,0,0,level_one); {this null delimiter is used in error recovery}
ex_hyphen_char:="-";
output_box:=255;

@ The following procedure, which is called just before \TeX\ initializes its
input and output, establishes the initial values of the date and time.
@^system dependencies@>
Since standard \PASCAL\ cannot provide such information, something special
is needed. The program here simply specifies July 4, 1776, at noon; but
users probably want a better approximation to the truth.

@p procedure fix_date_and_time;
begin time:=12*60; {minutes since midnight}
day:=4; {fourth day of the month}
month:=7; {seventh month of the year}
year:=1776; {Anno Domini}
end;

@ @<Show equivalent |n|, in region 5@>=
begin if n<count_base then begin print_param(n-int_base);
    print_char("="); print_int(eqtb[n].int);
  end
else if n<attribute_base then
  begin print_esc("count"); print_int(n-count_base);
    print_char("="); print_int(eqtb[n].int);
  end
else if n<del_code_base then
  begin print_esc("attribute"); print_int(n-attribute_base);
    print_char("="); print_int(eqtb[n].int);
  end;
end

@ \TeX\ is occasionally supposed to print diagnostic information that
goes only into the transcript file, unless |tracing_online| is positive.
Here are two routines that adjust the destination of print commands:

@p procedure begin_diagnostic; {prepare to do some tracing}
begin global_old_setting:=selector;
if (tracing_online<=0)and(selector=term_and_log) then
  begin decr(selector);
  if history=spotless then history:=warning_issued;
  end;
end;
@#
procedure end_diagnostic(@!blank_line:boolean);
  {restore proper conditions after tracing}
begin print_nl("");
if blank_line then print_ln;
selector:=global_old_setting;
end;

@ Of course we had better declare another global variable, if the previous
routines are going to work.

@<Glob...@>=
@!global_old_setting:0..max_selector;

@ The final region of |eqtb| contains the dimension parameters defined
here, and the |number_regs| \.{\\dimen} registers.

@d par_indent_code=0 {indentation of paragraphs}
@d math_surround_code=1 {space around math in text}
@d line_skip_limit_code=2 {threshold for |line_skip| instead of |baseline_skip|}
@d hsize_code=3 {line width in horizontal mode}
@d vsize_code=4 {page height in vertical mode}
@d max_depth_code=5 {maximum depth of boxes on main pages}
@d split_max_depth_code=6 {maximum depth of boxes on split pages}
@d box_max_depth_code=7 {maximum depth of explicit vboxes}
@d hfuzz_code=8 {tolerance for overfull hbox messages}
@d vfuzz_code=9 {tolerance for overfull vbox messages}
@d delimiter_shortfall_code=10 {maximum amount uncovered by variable delimiters}
@d null_delimiter_space_code=11 {blank space in null delimiters}
@d script_space_code=12 {extra space after subscript or superscript}
@d pre_display_size_code=13 {length of text preceding a display}
@d display_width_code=14 {length of line for displayed equation}
@d display_indent_code=15 {indentation of line for displayed equation}
@d overfull_rule_code=16 {width of rule that identifies overfull hboxes}
@d hang_indent_code=17 {amount of hanging indentation}
@d h_offset_code=18 {amount of horizontal offset when shipping pages out}
@d v_offset_code=19 {amount of vertical offset when shipping pages out}
@d emergency_stretch_code=20 {reduces badnesses on final pass of line-breaking}
@d page_left_offset_code=21
@d page_top_offset_code=22
@d page_right_offset_code=23
@d page_bottom_offset_code=24
@d pdftex_first_dimen_code = 25 {first number defined in this section}
@d pdf_h_origin_code       = pdftex_first_dimen_code + 0 {horigin of the PDF output}
@d pdf_v_origin_code       = pdftex_first_dimen_code + 1 {vorigin of the PDF output}
@d page_width_code         = pdftex_first_dimen_code + 2 {page width of the PDF output}
@d page_height_code        = pdftex_first_dimen_code + 3 {page height of the PDF output}
@d pdf_link_margin_code    = pdftex_first_dimen_code + 4 {link margin in the PDF output}
@d pdf_dest_margin_code    = pdftex_first_dimen_code + 5 {dest margin in the PDF output}
@d pdf_thread_margin_code  = pdftex_first_dimen_code + 6 {thread margin in the PDF output}
@d pdf_first_line_height_code = pdftex_first_dimen_code + 7
@d pdf_last_line_depth_code   = pdftex_first_dimen_code + 8
@d pdf_each_line_height_code  = pdftex_first_dimen_code + 9
@d pdf_each_line_depth_code   = pdftex_first_dimen_code + 10
@d pdf_ignored_dimen_code   = pdftex_first_dimen_code + 11
@d pdf_px_dimen_code       = pdftex_first_dimen_code + 12
@d pdftex_last_dimen_code  = pdftex_first_dimen_code + 12 {last number defined in this section}
@d dimen_pars = pdftex_last_dimen_code + 1 {total number of dimension parameters}
@d scaled_base=dimen_base+dimen_pars
  {table of |number_regs| user-defined \.{\\dimen} registers}
@d eqtb_size=scaled_base+biggest_reg {largest subscript of |eqtb|}
@#
@d dimen(#)==eqtb[scaled_base+#].sc
@d dimen_par(#)==eqtb[dimen_base+#].sc {a scaled quantity}
@d par_indent==dimen_par(par_indent_code)
@d math_surround==dimen_par(math_surround_code)
@d line_skip_limit==dimen_par(line_skip_limit_code)
@d hsize==dimen_par(hsize_code)
@d vsize==dimen_par(vsize_code)
@d max_depth==dimen_par(max_depth_code)
@d split_max_depth==dimen_par(split_max_depth_code)
@d box_max_depth==dimen_par(box_max_depth_code)
@d hfuzz==dimen_par(hfuzz_code)
@d vfuzz==dimen_par(vfuzz_code)
@d delimiter_shortfall==dimen_par(delimiter_shortfall_code)
@d null_delimiter_space==dimen_par(null_delimiter_space_code)
@d script_space==dimen_par(script_space_code)
@d pre_display_size==dimen_par(pre_display_size_code)
@d display_width==dimen_par(display_width_code)
@d display_indent==dimen_par(display_indent_code)
@d overfull_rule==dimen_par(overfull_rule_code)
@d hang_indent==dimen_par(hang_indent_code)
@d h_offset==dimen_par(h_offset_code)
@d v_offset==dimen_par(v_offset_code)
@d emergency_stretch==dimen_par(emergency_stretch_code)
@d page_left_offset==dimen_par(page_left_offset_code)
@d page_top_offset==dimen_par(page_top_offset_code)
@d page_right_offset==dimen_par(page_right_offset_code)
@d page_bottom_offset==dimen_par(page_bottom_offset_code)
@d pdf_h_origin      == dimen_par(pdf_h_origin_code)
@d pdf_v_origin      == dimen_par(pdf_v_origin_code)
@d page_width    == dimen_par(page_width_code)
@d page_height   == dimen_par(page_height_code)
@d pdf_link_margin   == dimen_par(pdf_link_margin_code)
@d pdf_dest_margin   == dimen_par(pdf_dest_margin_code)
@d pdf_thread_margin == dimen_par(pdf_thread_margin_code)
@d pdf_first_line_height == dimen_par(pdf_first_line_height_code)
@d pdf_last_line_depth   == dimen_par(pdf_last_line_depth_code)
@d pdf_each_line_height  == dimen_par(pdf_each_line_height_code)
@d pdf_each_line_depth   == dimen_par(pdf_each_line_depth_code)
@d pdf_ignored_dimen     == dimen_par(pdf_ignored_dimen_code)
@d pdf_px_dimen      == dimen_par(pdf_px_dimen_code)

@p procedure print_length_param(@!n:integer);
begin case n of
par_indent_code:print_esc("parindent");
math_surround_code:print_esc("mathsurround");
line_skip_limit_code:print_esc("lineskiplimit");
hsize_code:print_esc("hsize");
vsize_code:print_esc("vsize");
max_depth_code:print_esc("maxdepth");
split_max_depth_code:print_esc("splitmaxdepth");
box_max_depth_code:print_esc("boxmaxdepth");
hfuzz_code:print_esc("hfuzz");
vfuzz_code:print_esc("vfuzz");
delimiter_shortfall_code:print_esc("delimitershortfall");
null_delimiter_space_code:print_esc("nulldelimiterspace");
script_space_code:print_esc("scriptspace");
pre_display_size_code:print_esc("predisplaysize");
display_width_code:print_esc("displaywidth");
display_indent_code:print_esc("displayindent");
overfull_rule_code:print_esc("overfullrule");
hang_indent_code:print_esc("hangindent");
h_offset_code:print_esc("hoffset");
v_offset_code:print_esc("voffset");
emergency_stretch_code:print_esc("emergencystretch");
page_left_offset_code:  print_esc("pageleftoffset");
page_top_offset_code:   print_esc("pagetopoffset");
page_right_offset_code: print_esc("pagerightoffset");
page_bottom_offset_code:print_esc("pagebottomoffset");
pdf_h_origin_code:      print_esc("pdfhorigin");
pdf_v_origin_code:      print_esc("pdfvorigin");
page_width_code:    print_esc("pagewidth");
page_height_code:   print_esc("pageheight");
pdf_link_margin_code:   print_esc("pdflinkmargin");
pdf_dest_margin_code:   print_esc("pdfdestmargin");
pdf_thread_margin_code: print_esc("pdfthreadmargin");
pdf_first_line_height_code: print_esc("pdffirstlineheight");
pdf_last_line_depth_code: print_esc("pdflastlinedepth");
pdf_each_line_height_code: print_esc("pdfeachlineheight");
pdf_each_line_depth_code: print_esc("pdfeachlinedepth");
pdf_ignored_dimen_code: print_esc("pdfignoreddimen");
pdf_px_dimen_code:      print_esc("pdfpxdimen");
othercases print("[unknown dimen parameter!]")
endcases;
end;

@ @<Put each...@>=
primitive_tex("parindent",assign_dimen,dimen_base+par_indent_code,dimen_base);@/
@!@:par_indent_}{\.{\\parindent} primitive@>
primitive_tex("mathsurround",assign_dimen,dimen_base+math_surround_code,dimen_base);@/
@!@:math_surround_}{\.{\\mathsurround} primitive@>
primitive_tex("lineskiplimit",assign_dimen,dimen_base+line_skip_limit_code,dimen_base);@/
@!@:line_skip_limit_}{\.{\\lineskiplimit} primitive@>
primitive_tex("hsize",assign_dimen,dimen_base+hsize_code,dimen_base);@/
@!@:hsize_}{\.{\\hsize} primitive@>
primitive_tex("vsize",assign_dimen,dimen_base+vsize_code,dimen_base);@/
@!@:vsize_}{\.{\\vsize} primitive@>
primitive_tex("maxdepth",assign_dimen,dimen_base+max_depth_code,dimen_base);@/
@!@:max_depth_}{\.{\\maxdepth} primitive@>
primitive_tex("splitmaxdepth",assign_dimen,dimen_base+split_max_depth_code,dimen_base);@/
@!@:split_max_depth_}{\.{\\splitmaxdepth} primitive@>
primitive_tex("boxmaxdepth",assign_dimen,dimen_base+box_max_depth_code,dimen_base);@/
@!@:box_max_depth_}{\.{\\boxmaxdepth} primitive@>
primitive_tex("hfuzz",assign_dimen,dimen_base+hfuzz_code,dimen_base);@/
@!@:hfuzz_}{\.{\\hfuzz} primitive@>
primitive_tex("vfuzz",assign_dimen,dimen_base+vfuzz_code,dimen_base);@/
@!@:vfuzz_}{\.{\\vfuzz} primitive@>
primitive_tex("delimitershortfall", assign_dimen,dimen_base+delimiter_shortfall_code,dimen_base);@/
@!@:delimiter_shortfall_}{\.{\\delimitershortfall} primitive@>
primitive_tex("nulldelimiterspace", assign_dimen,dimen_base+null_delimiter_space_code,dimen_base);@/
@!@:null_delimiter_space_}{\.{\\nulldelimiterspace} primitive@>
primitive_tex("scriptspace",assign_dimen,dimen_base+script_space_code,dimen_base);@/
@!@:script_space_}{\.{\\scriptspace} primitive@>
primitive_tex("predisplaysize",assign_dimen,dimen_base+pre_display_size_code,dimen_base);@/
@!@:pre_display_size_}{\.{\\predisplaysize} primitive@>
primitive_tex("displaywidth",assign_dimen,dimen_base+display_width_code,dimen_base);@/
@!@:display_width_}{\.{\\displaywidth} primitive@>
primitive_tex("displayindent",assign_dimen,dimen_base+display_indent_code,dimen_base);@/
@!@:display_indent_}{\.{\\displayindent} primitive@>
primitive_tex("overfullrule",assign_dimen,dimen_base+overfull_rule_code,dimen_base);@/
@!@:overfull_rule_}{\.{\\overfullrule} primitive@>
primitive_tex("hangindent",assign_dimen,dimen_base+hang_indent_code,dimen_base);@/
@!@:hang_indent_}{\.{\\hangindent} primitive@>
primitive_tex("hoffset",assign_dimen,dimen_base+h_offset_code,dimen_base);@/
@!@:h_offset_}{\.{\\hoffset} primitive@>
primitive_tex("voffset",assign_dimen,dimen_base+v_offset_code,dimen_base);@/
@!@:v_offset_}{\.{\\voffset} primitive@>
primitive_tex("emergencystretch",assign_dimen,dimen_base+emergency_stretch_code,dimen_base);@/
@!@:emergency_stretch_}{\.{\\emergencystretch} primitive@>
primitive_pdftex("pdfhorigin",assign_dimen,dimen_base+pdf_h_origin_code,dimen_base);@/
@!@:pdf_h_origin_}{\.{\\pdfhorigin} primitive@>
primitive_pdftex("pdfvorigin",assign_dimen,dimen_base+pdf_v_origin_code,dimen_base);@/
@!@:pdf_v_origin_}{\.{\\pdfvorigin} primitive@>
@#
primitive_omega("pagewidth",assign_dimen,dimen_base+page_width_code,dimen_base);@/
primitive_pdftex("pdfpagewidth",assign_dimen,dimen_base+page_width_code,dimen_base);@/
@!@:page_width_}{\.{\\pdfpagewidth} primitive@>
primitive_omega("pageheight",assign_dimen,dimen_base+page_height_code,dimen_base);@/
primitive_pdftex("pdfpageheight",assign_dimen,dimen_base+page_height_code,dimen_base);@/
@!@:page_height_}{\.{\\pdfpageheight} primitive@>
@#
primitive_pdftex("pdflinkmargin",assign_dimen,dimen_base+pdf_link_margin_code,dimen_base);@/
@!@:pdf_link_margin_}{\.{\\pdflinkmargin} primitive@>
primitive_pdftex("pdfdestmargin",assign_dimen,dimen_base+pdf_dest_margin_code,dimen_base);@/
@!@:pdf_dest_margin_}{\.{\\pdfdestmargin} primitive@>
primitive_pdftex("pdfthreadmargin",assign_dimen,dimen_base+pdf_thread_margin_code,dimen_base);@/
@!@:pdf_thread_margin_}{\.{\\pdfthreadmargin} primitive@>
primitive_pdftex("pdffirstlineheight",assign_dimen,dimen_base+pdf_first_line_height_code,dimen_base);@/
@!@:pdf_first_line_height_}{\.{\\pdffirstlineheight} primitive@>
primitive_pdftex("pdflastlinedepth",assign_dimen,dimen_base+pdf_last_line_depth_code,dimen_base);@/
@!@:pdf_last_line_depth_}{\.{\\pdflastlinedepth} primitive@>
primitive_pdftex("pdfeachlineheight",assign_dimen,dimen_base+pdf_each_line_height_code,dimen_base);@/
@!@:pdf_each_line_height_}{\.{\\pdfeachlineheight} primitive@>
primitive_pdftex("pdfeachlinedepth",assign_dimen,dimen_base+pdf_each_line_depth_code,dimen_base);@/
@!@:pdf_each_line_depth_}{\.{\\pdfeachlinedepth} primitive@>
primitive_pdftex("pdfignoreddimen",assign_dimen,dimen_base+pdf_ignored_dimen_code,dimen_base);@/
@!@:pdf_ignored_dimen_}{\.{\\pdfignoreddimen} primitive@>
primitive_pdftex("pdfpxdimen",assign_dimen,dimen_base+pdf_px_dimen_code,dimen_base);@/
@!@:pdf_px_dimen_}{\.{\\pdfpxdimen} primitive@>

@ @<Initialize table entries...@>=
for k:=dimen_base to eqtb_size do eqtb[k].sc:=0;
page_left_offset := one_inch;
page_top_offset := one_inch;
page_right_offset := one_inch;
page_bottom_offset := one_inch;

@ @<Initialize table entries...@>=
pdf_ignored_dimen := ignore_depth;
pdf_each_line_height := pdf_ignored_dimen;
pdf_each_line_depth := pdf_ignored_dimen;
pdf_first_line_height := pdf_ignored_dimen;
pdf_last_line_depth := pdf_ignored_dimen;


@ @<Show equivalent |n|, in region 6@>=
begin if n<scaled_base then print_length_param(n-dimen_base)
else  begin print_esc("dimen"); print_int(n-scaled_base);
  end;
print_char("="); print_scaled(eqtb[n].sc); print("pt");
end

@ Here is a procedure that displays the contents of |eqtb[n]|
symbolically.

@p
@!stat procedure show_eqtb(@!n:pointer);
begin if n<null_cs then print_char("?") {this can't happen}
else if n<glue_base then @<Show equivalent |n|, in region 1 or 2@>
else if n<local_base then @<Show equivalent |n|, in region 3@>
else if n<int_base then @<Show equivalent |n|, in region 4@>
else if n<dimen_base then @<Show equivalent |n|, in region 5@>
else if n<=eqtb_size then @<Show equivalent |n|, in region 6@>
else print_char("?"); {this can't happen either}
end;
tats

@ The last two regions of |eqtb| have fullword values instead of the
three fields |eq_level|, |eq_type|, and |equiv|. An |eq_type| is unnecessary,
but \TeX\ needs to store the |eq_level| information in another array
called |xeq_level|.

@<Glob...@>=
@!eqtb:array[null_cs..eqtb_size] of memory_word;
@!xeq_level:array[null_cs..eqtb_size] of quarterword;

@ @<Set init...@>=
for k:=int_base to eqtb_size do xeq_level[k]:=level_one;

@* \[18] The hash table.
Control sequences are stored and retrieved by means of a fairly standard hash
table algorithm called the method of ``coalescing lists'' (cf.\ Algorithm 6.4C
in {\sl The Art of Computer Programming\/}). Once a control sequence enters the
table, it is never removed, because there are complicated situations
involving \.{\\gdef} where the removal of a control sequence at the end of
a group would be a mistake preventable only by the introduction of a
complicated reference-count mechanism.

The actual sequence of letters forming a control sequence identifier is
stored in the |str_pool| array together with all the other strings. An
auxiliary array |hash| consists of items with two halfword fields per
word. The first of these, called |next(p)|, points to the next identifier
belonging to the same coalesced list as the identifier corresponding to~|p|;
and the other, called |text(p)|, points to the |str_start| entry for
|p|'s identifier. If position~|p| of the hash table is empty, we have
|text(p)=0|; if position |p| is either empty or the end of a coalesced
hash list, we have |next(p)=0|. An auxiliary pointer variable called
|hash_used| is maintained in such a way that all locations |p>=hash_used|
are nonempty. The global variable |cs_count| tells how many multiletter
control sequences have been defined, if statistics are being kept.

A global boolean variable called |no_new_control_sequence| is set to
|true| during the time that new hash table entries are forbidden.

@d next(#) == hash[#].lh {link for coalesced lists}
@d text(#) == hash[#].rh {string number for control sequence name}
@d hash_is_full == (hash_used=hash_base) {test if all positions are occupied}
@d font_id_text(#) == text(font_id_base+#) {a frozen font identifier's name}

@<Glob...@>=
@!hash: array[hash_base..undefined_control_sequence-1] of two_halves;
  {the hash table}
@!hash_used:pointer; {allocation pointer for |hash|}
@!no_new_control_sequence:boolean; {are new identifiers legal?}
@!cs_count:integer; {total number of known identifiers}

@ The extra set of functions make sure we can query the
primitive meanings of thing s from C code

@p
function get_eq_type(p:integer):quarterword;
begin
  get_eq_type := eq_type(p);
end;
function get_eq_level(p:integer):quarterword;
begin
  get_eq_level := eq_level(p);
end;
function is_undefined_cs(cs:integer):boolean;
begin
  is_undefined_cs := (cs=undefined_cs);
end;
function get_equiv(p:integer):halfword;
begin
  get_equiv := equiv(p);
end;
function get_box_base:halfword;
begin
  get_box_base := box_base;
end;
function get_cs_text(cs:integer):str_number;
begin if cs=null_cs then get_cs_text := "\csname\endcsname"
  else if (text(cs)<0)or(text(cs)>=str_ptr) then get_cs_text := ""
  else get_cs_text := text(cs);
end;
function get_max_command:integer;
begin
  get_max_command := max_command;
end;
function get_count_base:halfword;
begin
  get_count_base := count_base;
end;
function get_skip_base:halfword;
begin
  get_skip_base := skip_base;
end;
function get_mu_skip_base:halfword;
begin
  get_mu_skip_base := mu_skip_base;
end;
function get_attribute_base:halfword;
begin
  get_attribute_base := attribute_base;
end;
function get_scaled_base:halfword;
begin
  get_scaled_base := scaled_base;
end;
function get_int_base:halfword;
begin
  get_int_base := int_base;
end;
function get_dimen_base:halfword;
begin
  get_dimen_base := dimen_base;
end;
function get_toks_base:halfword;
begin
  get_toks_base := toks_base;
end;
function get_del_code_base:halfword;
begin
  get_del_code_base := del_code_base;
end;
function get_every_eof:halfword;
begin
  get_every_eof := every_eof;
end;
function get_suppress_fontnotfound_error:boolean;
begin
  get_suppress_fontnotfound_error := suppress_fontnotfound_error;
end;

@ @<Set init...@>=
no_new_control_sequence:=true; {new identifiers are usually forbidden}
init_primitives;
next(hash_base):=0; text(hash_base):=0;
for k:=hash_base+1 to undefined_control_sequence-1 do hash[k]:=hash[hash_base];

@ @<Initialize table entries...@>=
ini_init_primitives;
hash_used:=frozen_control_sequence; {nothing is used}
cs_count:=0;
eq_type(frozen_dont_expand):=dont_expand;
text(frozen_dont_expand):="notexpanded:";
@.notexpanded:@>

eq_type(frozen_primitive):=ignore_spaces;
equiv(frozen_primitive):=1;
eq_level(frozen_primitive):=level_one;
text(frozen_primitive):="primitive";


@ Many of \TeX's primitives need no |equiv|, since they are identifiable
by their |eq_type| alone. These primitives are loaded into the hash table
as follows:

@<Put each of \TeX's primitives into the hash table@>=
primitive_tex(" ",ex_space,0,0);@/
@!@:Single-character primitives /}{\quad\.{\\\ }@>
primitive_tex("/",ital_corr,0,0);@/
@!@:Single-character primitives /}{\quad\.{\\/}@>
primitive_tex("accent",accent,0,0);@/
@!@:accent_}{\.{\\accent} primitive@>
primitive_tex("advance",advance,0,0);@/
@!@:advance_}{\.{\\advance} primitive@>
primitive_tex("afterassignment",after_assignment,0,0);@/
@!@:after_assignment_}{\.{\\afterassignment} primitive@>
primitive_tex("aftergroup",after_group,0,0);@/
@!@:after_group_}{\.{\\aftergroup} primitive@>
primitive_tex("begingroup",begin_group,0,0);@/
@!@:begin_group_}{\.{\\begingroup} primitive@>
primitive_tex("char",char_num,0,0);@/
@!@:char_}{\.{\\char} primitive@>
primitive_tex("csname",cs_name,0,0);@/
@!@:cs_name_}{\.{\\csname} primitive@>
primitive_tex("delimiter",delim_num,0,0);@/
@!@:delimiter_}{\.{\\delimiter} primitive@>
primitive_omega("odelimiter",delim_num,1,0);@/
@!@:odelimiter_}{\.{\\odelimiter} primitive@>
primitive_luatex("Udelimiter",delim_num,2,0);@/
@!@:odelimiter_}{\.{\\Udelimiter} primitive@>
primitive_tex("divide",divide,0,0);@/
@!@:divide_}{\.{\\divide} primitive@>
primitive_tex("endcsname",end_cs_name,0,0);@/
@!@:end_cs_name_}{\.{\\endcsname} primitive@>
primitive_tex("endgroup",end_group,0,0);
@!@:end_group_}{\.{\\endgroup} primitive@>
text(frozen_end_group):="endgroup"; eqtb[frozen_end_group]:=eqtb[cur_val];@/
primitive_tex("expandafter",expand_after,0,0);@/
@!@:expand_after_}{\.{\\expandafter} primitive@>
primitive_tex("font",def_font,0,0);@/
@!@:font_}{\.{\\font} primitive@>
primitive_pdftex("letterspacefont",letterspace_font,0,0);@/
@!@:letterspace_font_}{\.{\\letterspacefont} primitive@>
primitive_pdftex("pdfcopyfont",pdf_copy_font,0,0);@/
@!@:pdf_copy_font_}{\.{\\pdfcopyfont} primitive@>
primitive_tex("fontdimen",assign_font_dimen,0,0);@/
@!@:font_dimen_}{\.{\\fontdimen} primitive@>
primitive_tex("halign",halign,0,0);@/
@!@:halign_}{\.{\\halign} primitive@>
primitive_tex("hrule",hrule,0,0);@/
@!@:hrule_}{\.{\\hrule} primitive@>
primitive_tex("ignorespaces",ignore_spaces,0,0);@/
@!@:ignore_spaces_}{\.{\\ignorespaces} primitive@>
primitive_tex("insert",insert,0,0);@/
@!@:insert_}{\.{\\insert} primitive@>
primitive_omega("leftghost",char_ghost,0,0);@/
@!@:leftghost_}{\.{\\leftghost} primitive@>
primitive_tex("mark",mark,0,0);@/
@!@:mark_}{\.{\\mark} primitive@>
primitive_tex("mathaccent",math_accent,0,0);@/
@!@:math_accent_}{\.{\\mathaccent} primitive@>
primitive_omega("omathaccent",math_accent,1,0);@/
@!@:math_accent_}{\.{\\omathaccent} primitive@>
primitive_luatex("Umathaccent",math_accent,2,0);@/
@!@:math_accent_}{\.{\\Umathaccent} primitive@>
primitive_luatex("Umathbotaccent",math_accent,3,0);@/
@!@:math_accent_}{\.{\\Umathbotaccent} primitive@>
primitive_luatex("Umathaccents",math_accent,4,0);@/
@!@:math_accent_}{\.{\\Umathaccents} primitive@>
primitive_tex("mathchar",math_char_num,0,0);@/
@!@:math_char_}{\.{\\mathchar} primitive@>
primitive_omega("omathchar",math_char_num,1,0);@/
@!@:math_char_}{\.{\\omathchar} primitive@>
primitive_luatex("Umathchar",math_char_num,2,0);@/
@!@:math_char_}{\.{\\Umathchar} primitive@>
primitive_luatex("Umathcharnum",math_char_num,3,0);@/
@!@:math_char_}{\.{\\Umathcharnum} primitive@>
primitive_tex("mathchoice",math_choice,0,0);@/
@!@:math_choice_}{\.{\\mathchoice} primitive@>
primitive_luatex("Ustack",math_choice,1,0);@/
@!@:math_choice_}{\.{\\Ustack} primitive@>
primitive_tex("multiply",multiply,0,0);@/
@!@:multiply_}{\.{\\multiply} primitive@>
primitive_tex("noalign",no_align,0,0);@/
@!@:no_align_}{\.{\\noalign} primitive@>
primitive_tex("noboundary",no_boundary,0,0);@/
@!@:no_boundary_}{\.{\\noboundary} primitive@>
primitive_tex("noexpand",no_expand,0,0);@/
@!@:no_expand_}{\.{\\noexpand} primitive@>
primitive_luatex("primitive",no_expand,1,0);@/
@!@:primitive_}{\.{\\primitive} primitive@>
primitive_pdftex("pdfprimitive",no_expand,1,0);@/
@!@:pdfprimitive_}{\.{\\pdfprimitive} primitive@>
primitive_tex("nonscript",non_script,0,0);@/
@!@:non_script_}{\.{\\nonscript} primitive@>
primitive_tex("omit",omit,0,0);@/
@!@:omit_}{\.{\\omit} primitive@>
primitive_tex("parshape",set_tex_shape,par_shape_loc,par_shape_loc);@/
@!@:par_shape_}{\.{\\parshape} primitive@>
primitive_tex("penalty",break_penalty,0,0);@/
@!@:penalty_}{\.{\\penalty} primitive@>
primitive_tex("prevgraf",set_prev_graf,0,0);@/
@!@:prev_graf_}{\.{\\prevgraf} primitive@>
primitive_tex("radical",radical,0,0);@/
@!@:radical_}{\.{\\radical} primitive@>
primitive_omega("oradical",radical,1,0);@/
@!@:radical_}{\.{\\oradical} primitive@>
primitive_luatex("Uradical",radical,2,0);@/
@!@:radical_}{\.{\\Uradical} primitive@>
primitive_luatex("Uroot",radical,3,0);@/
@!@:radical_}{\.{\\Uroot} primitive@>
primitive_luatex("Uunderdelimiter",radical,4,0);@/
@!@:radical_}{\.{\\Uunderdelimiter} primitive@>
primitive_luatex("Uoverdelimiter",radical,5,0);@/
@!@:radical_}{\.{\\Uoverdelimiter} primitive@>
primitive_luatex("Udelimiterunder",radical,6,0);@/
@!@:radical_}{\.{\\Udelimiterunder} primitive@>
primitive_luatex("Udelimiterover",radical,7,0);@/
@!@:radical_}{\.{\\Udelimiterover} primitive@>
primitive_tex("read",read_to_cs,0,0);@/
@!@:read_}{\.{\\read} primitive@>
primitive_tex("relax",relax,too_big_char,too_big_char);
@!@:relax_}{\.{\\relax} primitive@>
text(frozen_relax):="relax"; eqtb[frozen_relax]:=eqtb[cur_val];@/
primitive_omega("rightghost",char_ghost,1,0);@/
@!@:rightghost_}{\.{\\rightghost} primitive@>
primitive_tex("setbox",set_box,0,0);@/
@!@:set_box_}{\.{\\setbox} primitive@>
primitive_tex("the",the,0,0);@/
@!@:the_}{\.{\\the} primitive@>
primitive_tex("toks",toks_register,0,0);@/
@!@:toks_}{\.{\\toks} primitive@>
primitive_tex("vadjust",vadjust,0,0);@/
@!@:vadjust_}{\.{\\vadjust} primitive@>
primitive_tex("valign",valign,0,0);@/
@!@:valign_}{\.{\\valign} primitive@>
primitive_tex("vcenter",vcenter,0,0);@/
@!@:vcenter_}{\.{\\vcenter} primitive@>
primitive_tex("vrule",vrule,0,0);@/
@!@:vrule_}{\.{\\vrule} primitive@>

@ Each primitive has a corresponding inverse, so that it is possible to
display the cryptic numeric contents of |eqtb| in symbolic form.
Every call of |primitive| in this program is therefore accompanied by some
straightforward code that forms part of the |print_cmd_chr| routine
below.

@ We will deal with the other primitives later, at some point in the program
where their |eq_type| and |equiv| values are more meaningful.  For example,
the primitives for math mode will be loaded when we consider the routines
that deal with formulas. It is easy to find where each particular
primitive was treated by looking in the index at the end; for example, the
section where |"radical"| entered |eqtb| is listed under `\.{\\radical}
primitive'. (Primitives consisting of a single nonalphabetic character,
@!like `\.{\\/}', are listed under `Single-character primitives'.)
@!@^Single-character primitives@>


@* \[19] Saving and restoring equivalents.
The nested structure provided by `$\.{\char'173}\ldots\.{\char'175}$' groups
in \TeX\ means that |eqtb| entries valid in outer groups should be saved
and restored later if they are overridden inside the braces. When a new |eqtb|
value is being assigned, the program therefore checks to see if the previous
entry belongs to an outer level. In such a case, the old value is placed
on the |save_stack| just before the new value enters |eqtb|. At the
end of a grouping level, i.e., when the right brace is sensed, the
|save_stack| is used to restore the outer values, and the inner ones are
destroyed.

Entries on the |save_stack| are of type |memory_word|. The top item on
this stack is |save_stack[p]|, where |p=save_ptr-1|; it contains three
fields called |save_type|, |save_level|, and |save_index|, and it is
interpreted in one of four ways:

\yskip\hangg 1) If |save_type(p)=restore_old_value|, then
|save_index(p)| is a location in |eqtb| whose current value should
be destroyed at the end of the current group and replaced by |save_stack[p-1]|.
Furthermore if |save_index(p)>=int_base|, then |save_level(p)|
should replace the corresponding entry in |xeq_level|.

\yskip\hangg 2) If |save_type(p)=restore_zero|, then |save_index(p)|
is a location in |eqtb| whose current value should be destroyed at the end
of the current group, when it should be
replaced by the current value of |eqtb[undefined_control_sequence]|.

\yskip\hangg 3) If |save_type(p)=insert_token|, then |save_index(p)|
is a token that should be inserted into \TeX's input when the current
group ends.

\yskip\hangg 4) If |save_type(p)=level_boundary|, then |save_level(p)|
is a code explaining what kind of group we were previously in, and
|save_index(p)| points to the level boundary word at the bottom of
the entries for that group.
Furthermore, in extended \eTeX\ mode, |save_stack[p-1]| contains the
source line number at which the current level of grouping was entered.

@d save_type(#)==save_stack[#].hh.b0 {classifies a |save_stack| entry}
@d save_level(#)==save_stack[#].hh.b1
  {saved level for regions 5 and 6, or group code}
@d save_index(#)==save_stack[#].hh.rh
  {|eqtb| location or token or |save_stack| location}
@d restore_old_value=0 {|save_type| when a value should be restored later}
@d restore_zero=1 {|save_type| when an undefined entry should be restored}
@d insert_token=2 {|save_type| when a token is being saved for later use}
@d level_boundary=3 {|save_type| corresponding to beginning of group}

@p@t\4@>@<Declare \eTeX\ procedures for tracing and input@>

@ Here are the group codes that are used to discriminate between different
kinds of groups. They allow \TeX\ to decide what special actions, if any,
should be performed when a group ends.
\def\grp{\.{\char'173...\char'175}}

Some groups are not supposed to be ended by right braces. For example,
the `\.\$' that begins a math formula causes a |math_shift_group| to
be started, and this should be terminated by a matching `\.\$'. Similarly,
a group that starts with \.{\\left} should end with \.{\\right}, and
one that starts with \.{\\begingroup} should end with \.{\\endgroup}.

@d bottom_level=0 {group code for the outside world}
@d simple_group=1 {group code for local structure only}
@d hbox_group=2 {code for `\.{\\hbox}\grp'}
@d adjusted_hbox_group=3 {code for `\.{\\hbox}\grp' in vertical mode}
@d vbox_group=4 {code for `\.{\\vbox}\grp'}
@d vtop_group=5 {code for `\.{\\vtop}\grp'}
@d align_group=6 {code for `\.{\\halign}\grp', `\.{\\valign}\grp'}
@d no_align_group=7 {code for `\.{\\noalign}\grp'}
@d output_group=8 {code for output routine}
@d math_group=9 {code for, e.g., `\.{\char'136}\grp'}
@d disc_group=10 {code for `\.{\\discretionary}\grp\grp\grp'}
@d insert_group=11 {code for `\.{\\insert}\grp', `\.{\\vadjust}\grp'}
@d vcenter_group=12 {code for `\.{\\vcenter}\grp'}
@d math_choice_group=13 {code for `\.{\\mathchoice}\grp\grp\grp\grp'}
@d semi_simple_group=14 {code for `\.{\\begingroup...\\endgroup}'}
@d math_shift_group=15 {code for `\.{\$...\$}'}
@d math_left_group=16 {code for `\.{\\left...\\right}'}
@d local_box_group=17 {code for `\.{\\localleftbox...\\localrightbox}'}
@d max_group_code=17
@d split_off_group=18 {box code for the top part of a \.{\\vsplit}}
@d split_keep_group=19 {box code for the bottom part of a \.{\\vsplit}}
@d preamble_group=20 {box code for the preamble processing  in an alignment}
@d align_set_group=21 {box code for the final item pass in an alignment}
@d fin_row_group=22 {box code for a provisory line in an alignment}

@<Types...@>=
@!group_code=0..max_group_code; {|save_level| for a level boundary}

@ The global variable |cur_group| keeps track of what sort of group we are
currently in. Another global variable, |cur_boundary|, points to the
topmost |level_boundary| word.  And |cur_level| is the current depth of
nesting. The routines are designed to preserve the condition that no entry
in the |save_stack| or in |eqtb| ever has a level greater than |cur_level|.

@ @<Glob...@>=
@!save_stack : array[0..save_size] of memory_word;
@!save_ptr : 0..save_size; {first unused entry on |save_stack|}
@!max_save_stack:0..save_size; {maximum usage of save stack}
@!cur_level: quarterword; {current nesting level for groups}
@!cur_group: group_code; {current group type}
@!cur_boundary: 0..save_size; {where the current level begins}

@ At this time it might be a good idea for the reader to review the introduction
to |eqtb| that was given above just before the long lists of parameter names.
Recall that the ``outer level'' of the program is |level_one|, since
undefined control sequences are assumed to be ``defined'' at |level_zero|.

@<Set init...@>=
save_ptr:=0; cur_level:=level_one; cur_group:=bottom_level; cur_boundary:=0;
max_save_stack:=0;

@ The following macro is used to test if there is room for up to eight more
entries on |save_stack|. By making a conservative test like this, we can
get by with testing for overflow in only a few places.

@d check_full_save_stack==if save_ptr>max_save_stack then
  begin max_save_stack:=save_ptr;
  if max_save_stack>save_size-8 then overflow('save size',save_size);
@:TeX capacity exceeded save size}{\quad save size@>
  end

@ Procedure |new_save_level| is called when a group begins. The
argument is a group identification code like `|hbox_group|'. After
calling this routine, it is safe to put six more entries on |save_stack|.

In some cases integer-valued items are placed onto the
|save_stack| just below a |level_boundary| word, because this is a
convenient place to keep information that is supposed to ``pop up'' just
when the group has finished.
For example, when `\.{\\hbox to 100pt}\grp' is being treated, the 100pt
dimension is stored on |save_stack| just before |new_save_level| is
called.

We use the notation |saved(k)| to stand for an integer item that
appears in location |save_ptr+k| of the save stack.

@d saved(#)==save_stack[save_ptr+#].int

@p procedure new_save_level(@!c:group_code); {begin a new level of grouping}
begin check_full_save_stack;
saved(0):=line; incr(save_ptr);
save_type(save_ptr):=level_boundary; save_level(save_ptr):=cur_group;
save_index(save_ptr):=cur_boundary;
if cur_level=max_quarterword then overflow('grouping levels',
@:TeX capacity exceeded grouping levels}{\quad grouping levels@>
  max_quarterword-min_quarterword);
  {quit if |(cur_level+1)| is too big to be stored in |eqtb|}
cur_boundary:=save_ptr; cur_group:=c;
@!stat if tracing_groups>0 then group_trace(false);@+tats@;@/
incr(cur_level); incr(save_ptr);
end;

@ Just before an entry of |eqtb| is changed, the following procedure should
be called to update the other data structures properly. It is important
to keep in mind that reference counts in |mem| include references from
within |save_stack|, so these counts must be handled carefully.
@^reference counts@>

@p procedure eq_destroy(@!w:memory_word); {gets ready to forget |w|}
var q:pointer; {|equiv| field of |w|}
begin case eq_type_field(w) of
call,long_call,outer_call,long_outer_call: delete_token_ref(equiv_field(w));
glue_ref: delete_glue_ref(equiv_field(w));
shape_ref: begin q:=equiv_field(w); {we need to free a \.{\\parshape} block}
  if q<>null then flush_node(q);
  end; {such a block is |2n+1| words long, where |n=vinfo(q)|}
box_ref: flush_node_list(equiv_field(w));
othercases do_nothing
endcases;
end;

@ To save a value of |eqtb[p]| that was established at level |l|, we
can use the following subroutine.

@p procedure eq_save(@!p:pointer;@!l:quarterword); {saves |eqtb[p]|}
begin check_full_save_stack;
if l=level_zero then save_type(save_ptr):=restore_zero
else  begin save_stack[save_ptr]:=eqtb[p]; incr(save_ptr);
  save_type(save_ptr):=restore_old_value;
  end;
save_level(save_ptr):=l; save_index(save_ptr):=p; incr(save_ptr);
end;

@ The procedure |eq_define| defines an |eqtb| entry having specified
|eq_type| and |equiv| fields, and saves the former value if appropriate.
This procedure is used only for entries in the first four regions of |eqtb|,
i.e., only for entries that have |eq_type| and |equiv| fields.
After calling this routine, it is safe to put four more entries on
|save_stack|, provided that there was room for four more entries before
the call, since |eq_save| makes the necessary test.

@d assign_trace(#)==@!stat if tracing_assigns>0 then restore_trace(#);
  tats

@p procedure eq_define(@!p:pointer;@!t:quarterword;@!e:halfword);
  {new data for |eqtb|}
label exit;
begin if (eq_type(p)=t)and(equiv(p)=e) then
  begin assign_trace(p,"reassigning")@;@/
  eq_destroy(eqtb[p]); return;
  end;
assign_trace(p,"changing")@;@/
if eq_level(p)=cur_level then eq_destroy(eqtb[p])
else if cur_level>level_one then eq_save(p,eq_level(p));
eq_level(p):=cur_level; eq_type(p):=t; equiv(p):=e;
assign_trace(p,"into")@;@/
exit:end;

@ The counterpart of |eq_define| for the remaining (fullword) positions in
|eqtb| is called |eq_word_define|. Since |xeq_level[p]>=level_one| for all
|p|, a `|restore_zero|' will never be used in this case.

@p procedure eq_word_define(@!p:pointer;@!w:integer);
label exit;
begin if eqtb[p].int=w then
  begin assign_trace(p,"reassigning")@;@/
  return;
  end;
assign_trace(p,"changing")@;@/
if xeq_level[p]<>cur_level then
  begin eq_save(p,xeq_level[p]); xeq_level[p]:=cur_level;
  end;
eqtb[p].int:=w;
assign_trace(p,"into")@;@/
exit:end;

@ The |eq_define| and |eq_word_define| routines take care of local definitions.
@^global definitions@>
Global definitions are done in almost the same way, but there is no need
to save old values, and the new value is associated with |level_one|.

@p procedure geq_define(@!p:pointer;@!t:quarterword;@!e:halfword);
  {global |eq_define|}
begin assign_trace(p,"globally changing")@;@/
begin eq_destroy(eqtb[p]);
eq_level(p):=level_one; eq_type(p):=t; equiv(p):=e;
end;
assign_trace(p,"into")@;@/
end;
@#
procedure geq_word_define(@!p:pointer;@!w:integer); {global |eq_word_define|}
begin assign_trace(p,"globally changing")@;@/
begin eqtb[p].int:=w; xeq_level[p]:=level_one;
end;
assign_trace(p,"into")@;@/
end;

@ Subroutine |save_for_after| puts a token on the stack for save-keeping.

@p procedure save_for_after(@!t:halfword);
begin if cur_level>level_one then
  begin check_full_save_stack;
  save_type(save_ptr):=insert_token; save_level(save_ptr):=level_zero;
  save_index(save_ptr):=t; incr(save_ptr);
  end;
end;

@ The |unsave| routine goes the other way, taking items off of |save_stack|.
This routine takes care of restoration when a level ends; everything
belonging to the topmost group is cleared off of the save stack.

@p
procedure@?back_input; forward; @t\2@>
procedure unsave; {pops the top level off the save stack}
label done;
var p:pointer; {position to be restored}
@!l:quarterword; {saved level, if in fullword regions of |eqtb|}
@!a:boolean; {have we already processed an \.{\\aftergroup} ?}
begin a:=false; l:=level_one; {just in case}
unsave_math_codes(cur_level);
unsave_cat_codes (cat_code_table,cur_level);
unsave_text_codes(cur_level);
unsave_math_data(cur_level);
if cur_level>level_one then
  begin decr(cur_level);
  @<Clear off top level from |save_stack|@>;
  end
else confusion('curlevel'); {|unsave| is not used when |cur_group=bottom_level|}
@:this can't happen curlevel}{\quad curlevel@>
attr_list_cache:=cache_disabled;
end;

@ @<Clear off...@>=
loop@+begin decr(save_ptr);
  if save_type(save_ptr)=level_boundary then goto done;
  p:=save_index(save_ptr);
  if save_type(save_ptr)=insert_token then
    a := reinsert_token(a, p)
  else  begin if save_type(save_ptr)=restore_old_value then
      begin l:=save_level(save_ptr); decr(save_ptr);
      end
    else save_stack[save_ptr]:=eqtb[undefined_control_sequence];
    @<Store \(s)|save_stack[save_ptr]| in |eqtb[p]|, unless
      |eqtb[p]| holds a global value@>;
    end;
  end;
done: @!stat if tracing_groups>0 then group_trace(true);@+tats@;@/
if grp_stack[in_open]=cur_boundary then group_warning;
  {groups possibly not properly nested with files}
cur_group:=save_level(save_ptr); cur_boundary:=save_index(save_ptr);
decr(save_ptr)

@ A global definition, which sets the level to |level_one|,
@^global definitions@>
will not be undone by |unsave|. If at least one global definition of
|eqtb[p]| has been carried out within the group that just ended, the
last such definition will therefore survive.

@<Store \(s)|save...@>=
if p<int_base then
  if eq_level(p)=level_one then
    begin eq_destroy(save_stack[save_ptr]); {destroy the saved value}
    @!stat if tracing_restores>0 then restore_trace(p,"retaining");@+tats@;@/
    end
  else  begin eq_destroy(eqtb[p]); {destroy the current value}
    eqtb[p]:=save_stack[save_ptr]; {restore the saved value}
    @!stat if tracing_restores>0 then restore_trace(p,"restoring");@+tats@;@/
    end
else if xeq_level[p]<>level_one then
  begin eqtb[p]:=save_stack[save_ptr]; xeq_level[p]:=l;
  @!stat if tracing_restores>0 then restore_trace(p,"restoring");@+tats@;@/
  end
else  begin
  @!stat if tracing_restores>0 then restore_trace(p,"retaining");@+tats@;@/
  end

@ @<Declare \eTeX\ procedures for tr...@>=
@!stat procedure restore_trace(@!p:pointer;@!s:str_number);
  {|eqtb[p]| has just been restored or retained}
begin begin_diagnostic; print_char("{"); print(s); print_char(" ");
show_eqtb(p); print_char("}");
end_diagnostic(false);
end;
tats

@ Most of the parameters kept in |eqtb| can be changed freely, but there's
an exception:  The magnification should not be used with two different
values during any \TeX\ job, since a single magnification is applied to an
entire run. The global variable |mag_set| is set to the current magnification
whenever it becomes necessary to ``freeze'' it at a particular value.

@<Glob...@>=
@!mag_set:integer; {if nonzero, this magnification should be used henceforth}

@ @<Set init...@>=
mag_set:=0;

@ The |prepare_mag| subroutine is called whenever \TeX\ wants to use |mag|
for magnification.

@p procedure prepare_mag;
begin if (mag_set>0)and(mag<>mag_set) then
  begin print_err('Incompatible magnification ('); print_int(mag);
@.Incompatible magnification@>
  print(");"); print_nl(" the previous value will be retained");
  help2('I can handle only one magnification ratio per job. So I''ve',
        'reverted to the magnification you used earlier on this run.');@/
  int_error(mag_set);
  geq_word_define(int_base+mag_code,mag_set); {|mag:=mag_set|}
  end;
if (mag<=0)or(mag>32768) then
  begin print_err('Illegal magnification has been changed to 1000');@/
@.Illegal magnification...@>
  help1('The magnification ratio must be between 1 and 32768.');
  int_error(mag); geq_word_define(int_base+mag_code,1000);
  end;
if (mag_set=0) and (mag<>mag_set) then begin
  if mag<>1000 then
    one_true_inch:=xn_over_d(one_hundred_inch,10,mag)
  else
    one_true_inch:=one_inch;
end;
mag_set:=mag;
end;

@* \[20] Token lists.

@ Sigh. Of course these can't go away either...

@d cs_token_flag==@"1FFFFFFF {amount added to the |eqtb| location in a
  token that stands for a control sequence; is a multiple of~$2^{21}$, less~1}
@d left_brace_token=@"200000   {$2^{21}\cdot|left_brace|$}
@d left_brace_limit=@"400000   {$2^{21}\cdot(|left_brace|+1)$}
@d right_brace_token=@"400000  {$2^{21}\cdot|right_brace|$}
@d right_brace_limit=@"600000  {$2^{21}\cdot(|right_brace|+1)$}
@d math_shift_token= @"600000  {$2^{21}\cdot|math_shift|$}
@d tab_token=@"800000          {$2^{21}\cdot|tab_mark|$}
@d out_param_token=@"A00000    {$2^{21}\cdot|out_param|$}
@d space_token=@"1400020       {$2^{21}\cdot|spacer|+|" "|$}
@d letter_token=@"1600000      {$2^{21}\cdot|letter|$}
@d other_token=@"1800000       {$2^{21}\cdot|other_char|$}
@d match_token=@"1A00000       {$2^{21}\cdot|match|$}
@d end_match_token=@"1C00000   {$2^{21}\cdot|end_match|$}
@d protected_token=@"1C00001   {$2^{21}\cdot|end_match|+1$}

@ @<Check the ``constant''...@>=
if cs_token_flag+undefined_control_sequence>max_halfword then bad:=21;


@* \[21] Introduction to the syntactic routines.
Let's pause a moment now and try to look at the Big Picture.
The \TeX\ program consists of three main parts: syntactic routines,
semantic routines, and output routines. The chief purpose of the
syntactic routines is to deliver the user's input to the semantic routines,
one token at a time. The semantic routines act as an interpreter
responding to these tokens, which may be regarded as commands. And the
output routines are periodically called on to convert box-and-glue
lists into a compact set of instructions that will be sent
to a typesetter. We have discussed the basic data structures and utility
routines of \TeX, so we are good and ready to plunge into the real activity by
considering the syntactic routines.

Our current goal is to come to grips with the |get_next| procedure,
which is the keystone of \TeX's input mechanism. Each call of |get_next|
sets the value of three variables |cur_cmd|, |cur_chr|, and |cur_cs|,
representing the next input token.
$$\vbox{\halign{#\hfil\cr
  \hbox{|cur_cmd| denotes a command code from the long list of codes
   given above;}\cr
  \hbox{|cur_chr| denotes a character code or other modifier of the command
   code;}\cr
  \hbox{|cur_cs| is the |eqtb| location of the current control sequence,}\cr
  \hbox{\qquad if the current token was a control sequence,
   otherwise it's zero.}\cr}}$$
Underlying this external behavior of |get_next| is all the machinery
necessary to convert from character files to tokens. At a given time we
may be only partially finished with the reading of several files (for
which \.{\\input} was specified), and partially finished with the expansion
of some user-defined macros and/or some macro parameters, and partially
finished with the generation of some text in a template for \.{\\halign},
and so on. When reading a character file, special characters must be
classified as math delimiters, etc.; comments and extra blank spaces must
be removed, paragraphs must be recognized, and control sequences must be
found in the hash table. Furthermore there are occasions in which the
scanning routines have looked ahead for a word like `\.{plus}' but only
part of that word was found, hence a few characters must be put back
into the input and scanned again.

To handle these situations, which might all be present simultaneously,
\TeX\ uses various stacks that hold information about the incomplete
activities, and there is a finite state control for each level of the
input mechanism. These stacks record the current state of an implicitly
recursive process, but the |get_next| procedure is not recursive.
Therefore it will not be difficult to translate these algorithms into
low-level languages that do not support recursion.

@<Glob...@>=
@!cur_cmd: integer; {current command set by |get_next|}
@!cur_chr: halfword; {operand of current command}
@!cur_cs: pointer; {control sequence found here, zero if none found}
@!cur_tok: halfword; {packed representative of |cur_cmd| and |cur_chr|}

@ Here is a procedure that displays the current command.

@p procedure show_cur_cmd_chr;
var n:integer; {level of \.{\\if...\\fi} nesting}
@!l:integer; {line where \.{\\if} started}
@!p:pointer;
begin begin_diagnostic; print_nl("{");
if mode<>shown_mode then
  begin print_mode(mode); print(": "); shown_mode:=mode;
  end;
print_cmd_chr(cur_cmd,cur_chr);
if tracing_ifs>0 then
  if cur_cmd>=if_test then if cur_cmd<=fi_or_else then
    begin print(": ");
    if cur_cmd=fi_or_else then
      begin print_cmd_chr(if_test,cur_if); print_char(" ");
      n:=0; l:=if_line;
      end
    else  begin n:=1; l:=line;
      end;
    p:=cond_ptr;
    while p<>null do
      begin incr(n); p:=vlink(p);
      end;
    print("(level "); print_int(n); print_char(")"); print_if_line(l);
    end;
print_char("}");
end_diagnostic(false);
end;

@* \[22] Input stacks and states.

Input stack structures are now defined in C.

@* \[23] Maintaining the input stacks.

@ @<Initialize the input routines@>=
initialize_inputstack;


@* \[24] Getting the next token.

@ @<Put each...@>=
primitive_tex("par",par_end,too_big_char,too_big_char); {cf.\ |scan_file_name|}
@!@:par_}{\.{\\par} primitive@>
par_loc:=cur_val; par_token:=cs_token_flag+par_loc;


@* \[25] Expanding the next token.

@ The processing of \.{\\input} involves the |start_input| subroutine,
which will be declared later; the processing of \.{\\endinput} is trivial.

@<Put each...@>=
primitive_tex("input",input,0,0);@/
@!@:input_}{\.{\\input} primitive@>
primitive_tex("endinput",input,1,0);@/
@!@:end_input_}{\.{\\endinput} primitive@>

@ @<Set init...@>=
initialize_marks;

@ @<Put each...@>=
primitive_tex("topmark",top_bot_mark,top_mark_code,0);
@!@:top_mark_}{\.{\\topmark} primitive@>
primitive_tex("firstmark",top_bot_mark,first_mark_code,0);
@!@:first_mark_}{\.{\\firstmark} primitive@>
primitive_tex("botmark",top_bot_mark,bot_mark_code,0);
@!@:bot_mark_}{\.{\\botmark} primitive@>
primitive_tex("splitfirstmark",top_bot_mark,split_first_mark_code,0);
@!@:split_first_mark_}{\.{\\splitfirstmark} primitive@>
primitive_tex("splitbotmark",top_bot_mark,split_bot_mark_code,0);
@!@:split_bot_mark_}{\.{\\splitbotmark} primitive@>
primitive_luatex("clearmarks",mark,clear_marks_code,0);@/
@!@:clearmarks_}{\.{\\clearmarks} primitive@>
primitive_etex("marks",mark,marks_code,0);
@!@:marks_}{\.{\\marks} primitive@>
primitive_etex("topmarks",top_bot_mark,top_mark_code+marks_code,0);
@!@:top_marks_}{\.{\\topmarks} primitive@>
primitive_etex("firstmarks",top_bot_mark,first_mark_code+marks_code,0);
@!@:first_marks_}{\.{\\firstmarks} primitive@>
primitive_etex("botmarks",top_bot_mark,bot_mark_code+marks_code,0);
@!@:bot_marks_}{\.{\\botmarks} primitive@>
primitive_etex("splitfirstmarks",top_bot_mark,split_first_mark_code+marks_code,0);
@!@:split_first_marks_}{\.{\\splitfirstmarks} primitive@>
primitive_etex("splitbotmarks",top_bot_mark,split_bot_mark_code+marks_code,0);
@!@:split_bot_marks_}{\.{\\splitbotmarks} primitive@>

@* \[26] Basic scanning subroutines.

@ @<Get the next non-blank non-relax non-call token@>=
repeat get_x_token;
until (cur_cmd<>spacer)and(cur_cmd<>relax)

@ @<Get the next non-blank non-call token@>=
repeat get_x_token;
until cur_cmd<>spacer

@ The hash table is initialized with `\.{\\count}', `\.{\\attribute}',
`\.{\\dimen}', `\.{\\skip}', and `\.{\\muskip}' all having |register|
as their command code; they are distinguished by the |chr_code|, which
is either |int_val|, |attr_val|, |dimen_val|, |glue_val|, or |mu_val|.

@<Put each...@>=
primitive_tex("count",register,int_val_level,0);
@!@:count_}{\.{\\count} primitive@>
primitive_luatex("attribute",register,attr_val_level,0);
@!@:count_}{\.{\\attribute} primitive@>
primitive_tex("dimen",register,dimen_val_level,0);
@!@:dimen_}{\.{\\dimen} primitive@>
primitive_tex("skip",register,glue_val_level,0);
@!@:skip_}{\.{\\skip} primitive@>
primitive_tex("muskip",register,mu_val_level,0);


@ Users refer to `\.{\\the\\spacefactor}' only in horizontal
mode, and to `\.{\\the\\prevdepth}' only in vertical mode; so we put the
associated mode in the modifier part of the |set_aux| command.
The |set_page_int| command has modifier 0 or 1, for `\.{\\deadcycles}' and
`\.{\\insertpenalties}', respectively. The |set_box_dimen| command is
modified by either |width_offset|, |height_offset|, or |depth_offset|.
And the |last_item| command is modified by either |int_val|, |dimen_val|,
|glue_val|, |input_line_no_code|, or |badness_code|.
\pdfTeX\ adds the codes for its extensions: |pdftex_version_code|, \dots\ .
\eTeX\ inserts |last_node_type_code| after |glue_val| and adds
the codes for its extensions: |eTeX_version_code|, \dots\ .

@d glue_val=3 {this is a temp hack }
@d last_node_type_code=glue_val+1 {code for \.{\\lastnodetype}}
@d input_line_no_code=glue_val+2 {code for \.{\\inputlineno}}
@d badness_code=input_line_no_code+1 {code for \.{\\badness}}
@#
@d pdftex_first_rint_code     = badness_code + 1 {base for \pdfTeX's command codes}
@d pdftex_version_code        = pdftex_first_rint_code + 0 {code for \.{\\pdftexversion}}
@d pdf_last_obj_code          = pdftex_first_rint_code + 1 {code for \.{\\pdflastobj}}
@d pdf_last_xform_code        = pdftex_first_rint_code + 2 {code for \.{\\pdflastxform}}
@d pdf_last_ximage_code       = pdftex_first_rint_code + 3 {code for \.{\\pdflastximage}}
@d pdf_last_ximage_pages_code = pdftex_first_rint_code + 4 {code for \.{\\pdflastximagepages}}
@d pdf_last_annot_code        = pdftex_first_rint_code + 5 {code for \.{\\pdflastannot}}
@d pdf_last_x_pos_code        = pdftex_first_rint_code + 6 {code for \.{\\pdflastxpos}}
@d pdf_last_y_pos_code        = pdftex_first_rint_code + 7 {code for \.{\\pdflastypos}}
@d pdf_retval_code            = pdftex_first_rint_code + 8 {global multi-purpose return value}
@d pdf_last_ximage_colordepth_code = pdftex_first_rint_code + 9 {code for \.{\\pdflastximagecolordepth}}
@d random_seed_code           = pdftex_first_rint_code + 10 {code for \.{\\pdfrandomseed}}
@d pdf_last_link_code         = pdftex_first_rint_code + 11 {code for \.{\\pdflastlink}}
@d luatex_version_code        = pdftex_first_rint_code + 12 {code for \.{\\luatexversion}}
@d pdftex_last_item_codes     = pdftex_first_rint_code + 12 {end of \pdfTeX's command codes}
@#
@d Aleph_int=pdftex_last_item_codes+1 {first of \Aleph\ codes for integers}
@d Aleph_int_num=5 {number of \Aleph\ integers}
@d eTeX_int=Aleph_int+Aleph_int_num {first of \eTeX\ codes for integers}
@d eTeX_dim=eTeX_int+8 {first of \eTeX\ codes for dimensions}
@d eTeX_glue=eTeX_dim+9 {first of \eTeX\ codes for glue}
@d eTeX_mu=eTeX_glue+1 {first of \eTeX\ codes for muglue}
@d eTeX_expr=eTeX_mu+1 {first of \eTeX\ codes for expressions}

@d last_item_lastpenalty_code==int_val_level
@d last_item_lastkern_code==dimen_val_level
@d last_item_lastskip_code==glue_val_level

@<Put each...@>=
primitive_tex("spacefactor",set_aux,hmode,0);
@!@:space_factor_}{\.{\\spacefactor} primitive@>
primitive_tex("prevdepth",set_aux,vmode,0);@/
@!@:prev_depth_}{\.{\\prevdepth} primitive@>
primitive_tex("deadcycles",set_page_int,0,0);
@!@:dead_cycles_}{\.{\\deadcycles} primitive@>
primitive_tex("insertpenalties",set_page_int,1,0);
@!@:insert_penalties_}{\.{\\insertpenalties} primitive@>
primitive_tex("wd",set_box_dimen,width_offset,0);
@!@:wd_}{\.{\\wd} primitive@>
primitive_tex("ht",set_box_dimen,height_offset,0);
@!@:ht_}{\.{\\ht} primitive@>
primitive_tex("dp",set_box_dimen,depth_offset,0);
@!@:dp_}{\.{\\dp} primitive@>
primitive_tex("lastpenalty",last_item,last_item_lastpenalty_code,0);
@!@:last_penalty_}{\.{\\lastpenalty} primitive@>
primitive_tex("lastkern",last_item,last_item_lastkern_code,0);
@!@:last_kern_}{\.{\\lastkern} primitive@>
primitive_tex("lastskip",last_item,last_item_lastskip_code,0);
@!@:last_skip_}{\.{\\lastskip} primitive@>
primitive_tex("inputlineno",last_item,input_line_no_code,0);
@!@:input_line_no_}{\.{\\inputlineno} primitive@>
primitive_tex("badness",last_item,badness_code,0);
@!@:badness_}{\.{\\badness} primitive@>
primitive_pdftex("pdftexversion",last_item,pdftex_version_code,0);@/
@!@:pdftex_version_}{\.{\\pdftexversion} primitive@>
primitive_luatex("luatexversion",last_item,luatex_version_code,0);@/
@!@:luatex_version_}{\.{\\luatexversion} primitive@>
primitive_pdftex("pdflastobj",last_item,pdf_last_obj_code,0);@/
@!@:pdf_last_obj_}{\.{\\pdflastobj} primitive@>
primitive_pdftex("pdflastxform",last_item,pdf_last_xform_code,0);@/
@!@:pdf_last_xform_}{\.{\\pdflastxform} primitive@>
primitive_pdftex("pdflastximage",last_item,pdf_last_ximage_code,0);@/
@!@:pdf_last_ximage_}{\.{\\pdflastximage} primitive@>
primitive_pdftex("pdflastximagepages",last_item,pdf_last_ximage_pages_code,0);@/
@!@:pdf_last_ximage_pages_}{\.{\\pdflastximagepages} primitive@>
primitive_pdftex("pdflastannot",last_item,pdf_last_annot_code,0);@/
@!@:pdf_last_annot_}{\.{\\pdflastannot} primitive@>
primitive_pdftex("pdflastxpos",last_item,pdf_last_x_pos_code,0);@/
@!@:pdf_last_x_pos_}{\.{\\pdflastxpos} primitive@>
primitive_pdftex("pdflastypos",last_item,pdf_last_y_pos_code,0);@/
@!@:pdf_last_y_pos_}{\.{\\pdflastypos} primitive@>
primitive_pdftex("pdfretval",last_item,pdf_retval_code,0);@/
@!@:pdf_retval_}{\.{\\pdfretval} primitive@>
primitive_pdftex("pdflastximagecolordepth",last_item,pdf_last_ximage_colordepth_code,0);@/
@!@:pdf_last_ximage_colordepth_}{\.{\\pdflastximagecolordepth} primitive@>
primitive_pdftex("pdfrandomseed",last_item,random_seed_code,0);
@!@:random_seed_}{\.{\\pdfrandomseed} primitive@>
primitive_pdftex("pdflastlink",last_item,pdf_last_link_code,0);@/
@!@:pdf_last_link_}{\.{\\pdflastlink} primitive@>

@ Inside an \.{\\output} routine, a user may wish to look at the page totals
that were present at the moment when output was triggered.

@d max_dimen==@'7777777777 {$2^{30}-1$}

@* \[27] Building token lists.

@ The primitives \.{\\number}, \.{\\romannumeral}, \.{\\string}, \.{\\meaning},
\.{\\fontname}, and \.{\\jobname} are defined as follows.

\eTeX\ adds \.{\\eTeXrevision} such that |job_name_code| remains last.

\pdfTeX\ adds \.{\\eTeXrevision}, \.{\\pdftexrevision}, \.{\\pdftexbanner},
\.{\\pdffontname}, \.{\\pdffontobjnum}, \.{\\pdffontsize}, and \.{\\pdfpageref}
such that |job_name_code| remains last.

@d number_code=0 {command code for \.{\\number}}
@d roman_numeral_code=1 {command code for \.{\\romannumeral}}
@d string_code=2 {command code for \.{\\string}}
@d meaning_code=3 {command code for \.{\\meaning}}
@d font_name_code=4 {command code for \.{\\fontname}}
@d etex_code=5 {command code for \.{\\eTeXVersion}}
@d omega_code=6 {command code for \.{\\OmegaVersion}}
@d aleph_code=7 {command code for \.{\\AlephVersion}}
@d format_name_code=8 {command code for \.{\\AlephVersion}}
@d pdftex_first_expand_code = 9 {base for \pdfTeX's command codes}
@d pdftex_revision_code     = pdftex_first_expand_code + 0 {command code for \.{\\pdftexrevision}}
@d pdftex_banner_code       = pdftex_first_expand_code + 1 {command code for \.{\\pdftexbanner}}
@d pdf_font_name_code       = pdftex_first_expand_code + 2 {command code for \.{\\pdffontname}}
@d pdf_font_objnum_code     = pdftex_first_expand_code + 3 {command code for \.{\\pdffontobjnum}}
@d pdf_font_size_code       = pdftex_first_expand_code + 4 {command code for \.{\\pdffontsize}}
@d pdf_page_ref_code        = pdftex_first_expand_code + 5 {command code for \.{\\pdfpageref}}
@d pdf_xform_name_code      = pdftex_first_expand_code + 6 {command code for \.{\\pdfxformname}}
@d left_margin_kern_code    = pdftex_first_expand_code + 7 {command code for \.{\\leftmarginkern}}
@d right_margin_kern_code   = pdftex_first_expand_code + 8 {command code for \.{\\rightmarginkern}}
@d pdf_creation_date_code   = pdftex_first_expand_code + 9 {command code for \.{\\pdfcreationdate}}
@d uniform_deviate_code     = pdftex_first_expand_code + 10 {command code for \.{\\uniformdeviate}}
@d normal_deviate_code      = pdftex_first_expand_code + 11 {command code for \.{\\normaldeviate}}
@d pdf_insert_ht_code       = pdftex_first_expand_code + 12 {command code for \.{\\pdfinsertht}}
@d pdf_ximage_bbox_code     = pdftex_first_expand_code + 13 {command code for \.{\\pdfximagebbox}}
@d lua_code                 = pdftex_first_expand_code + 14 {command code for \.{\\directlua}}
@d lua_escape_string_code   = pdftex_first_expand_code + 15 {command code for \.{\\luaescapestring}}
@d pdf_colorstack_init_code = pdftex_first_expand_code + 16 {command code for \.{\\pdfcolorstackinit}}
@d luatex_revision_code     = pdftex_first_expand_code + 17 {command code for \.{\\luatexrevision}}
@d luatex_date_code         = pdftex_first_expand_code + 18 {command code for \.{\\luatexdate}}
@d math_style_code          = pdftex_first_expand_code + 19 {command code for \.{\\mathstyle}}
@d expanded_code            = pdftex_first_expand_code + 20 {command code for \.{\\expanded}}
@d pdftex_convert_codes     = pdftex_first_expand_code + 21 {end of \pdfTeX's command codes}
@d job_name_code=pdftex_convert_codes {command code for \.{\\jobname}}


@<Put each...@>=
primitive_tex("number",convert,number_code,0);@/
@!@:number_}{\.{\\number} primitive@>
primitive_tex("romannumeral",convert,roman_numeral_code,0);@/
@!@:roman_numeral_}{\.{\\romannumeral} primitive@>
primitive_tex("string",convert,string_code,0);@/
@!@:string_}{\.{\\string} primitive@>
primitive_tex("meaning",convert,meaning_code,0);@/
@!@:meaning_}{\.{\\meaning} primitive@>
primitive_etex("eTeXVersion",convert,etex_code,0);@/
@!@:omega_version_}{\.{\\OmegaVersion} primitive@>
primitive_omega("OmegaVersion",convert,omega_code,0);@/
@!@:omega_version_}{\.{\\OmegaVersion} primitive@>
primitive_aleph("AlephVersion",convert,aleph_code,0);@/
@!@:aleph_version_}{\.{\\AlephVersion} primitive@>
primitive_tex("fontname",convert,font_name_code,0);@/
@!@:font_name_}{\.{\\fontname} primitive@>
primitive_pdftex("pdftexrevision",convert,pdftex_revision_code,0);@/
@!@:pdftex_revision_}{\.{\\pdftexrevision} primitive@>
primitive_luatex("luatexrevision",convert,luatex_revision_code,0);@/
@!@:luatex_revision_}{\.{\\luatexrevision} primitive@>
primitive_luatex("luatexdatestamp",convert,luatex_date_code,0);@/
@!@:luatex_date_}{\.{\\luatexdatestamp} primitive@>
primitive_pdftex("pdftexbanner",convert,pdftex_banner_code,0);@/
@!@:pdftex_banner_}{\.{\\pdftexbanner} primitive@>
primitive_pdftex("pdffontname",convert,pdf_font_name_code,0);@/
@!@:pdf_font_name_}{\.{\\pdffontname} primitive@>
primitive_pdftex("pdffontobjnum",convert,pdf_font_objnum_code,0);@/
@!@:pdf_font_objnum_}{\.{\\pdffontobjnum} primitive@>
primitive_pdftex("pdffontsize",convert,pdf_font_size_code,0);@/
@!@:pdf_font_size_}{\.{\\pdffontsize} primitive@>
primitive_pdftex("pdfpageref",convert,pdf_page_ref_code,0);@/
@!@:pdf_page_ref_}{\.{\\pdfpageref} primitive@>
primitive_pdftex("leftmarginkern",convert,left_margin_kern_code,0);@/
@!@:left_margin_kern_}{\.{\\leftmarginkern} primitive@>
primitive_pdftex("rightmarginkern",convert,right_margin_kern_code,0);@/
@!@:right_margin_kern_}{\.{\\rightmarginkern} primitive@>
primitive_pdftex("pdfxformname",convert,pdf_xform_name_code,0);@/
@!@:pdf_xform_name_}{\.{\\pdfxformname} primitive@>
primitive_pdftex("pdfcreationdate",convert,pdf_creation_date_code,0);@/
@!@:pdf_creation_date_}{\.{\\pdfcreationdate} primitive@>
primitive_pdftex("pdfuniformdeviate",convert,uniform_deviate_code,0);@/
@!@:uniform_deviate_}{\.{\\pdfuniformdeviate} primitive@>
primitive_pdftex("pdfcolorstackinit",convert,pdf_colorstack_init_code,0);@/
@!@:pdf_colorstack_init_}{\.{\\pdfcolorstackinit} primitive@>
primitive_pdftex("pdfnormaldeviate",convert,normal_deviate_code,0);@/
@!@:normal_deviate_}{\.{\\pdfnormaldeviate} primitive@>
primitive_core("directlua",convert,lua_code,0);@/
@!@:lua_}{\.{\\directlua} primitive@>
primitive_luatex("luaescapestring",convert,lua_escape_string_code,0);@/
@!@:lua_}{\.{\\luaescapestring} primitive@>
primitive_luatex("mathstyle",convert,math_style_code,0);@/
@!@:math_style_}{\.{\\mathstyle} primitive@>
primitive_pdftex("expanded",convert,expanded_code,0);@/
@!@:expanded_}{\.{\\expanded} primitive@>
@#
primitive_tex("jobname",convert,job_name_code,0);@/
@!@:job_name_}{\.{\\jobname} primitive@>
primitive_luatex("formatname",convert,format_name_code,0);@/
@!@:format_name_}{\.{\\formatname} primitive@>
primitive_pdftex("pdfinsertht",convert,pdf_insert_ht_code,0);@/
@!@:pdf_insert_ht_}{\.{\\pdfinsertht} primitive@>
primitive_pdftex("pdfximagebbox",convert,pdf_ximage_bbox_code,0);@/
@!@:pdf_ximage_bbox_}{\.{\\pdfximagebbox} primitive@>

@ The procedure |conv_toks| uses |str_toks| to insert the token list
for |convert| functions into the scanner; `\.{\\outer}' control sequences
are allowed to follow `\.{\\string}' and `\.{\\meaning}'.

The extra temp string |u| is needed because |pdf_scan_ext_toks| incorporates
any pending string in its output. In order to save such a pending string,
we have to create a temporary string that is destroyed immediately after.

@d save_cur_string==if str_start_macro(str_ptr)<pool_ptr then u:=make_string
@d restore_cur_string==if u<>0 then begin decr(str_ptr); u:=0; end

@p procedure conv_toks;
label exit;
var old_setting:0..max_selector; {holds |selector| setting}
p, q: pointer;
@!c:number_code..job_name_code; {desired type of conversion}
@!save_scanner_status:small_number; {|scanner_status| upon entry}
@!save_def_ref: pointer; {|def_ref| upon entry, important if inside `\.{\\message}'}
@!save_warning_index: pointer;
@!bool: boolean; {temp boolean}
@!i: integer; {first temp integer}
@!j: integer; {second temp integer}
@!b:pool_pointer; {base of temporary string}
@!s: str_number; {first temp string}
@!sn: integer; {lua chunk name}
@!u: str_number; {third temp string}
@!ff: integer; {for use with |set_ff| }
@!junk: pointer;
begin
c:=cur_chr;
u:=0; { will become non-nil if a string is already being built}
j:=0; i:=0;
@<Scan the argument for command |c|@>;
old_setting:=selector; selector:=new_string; b:=pool_ptr;
@<Print the result of command |c|@>;
selector:=old_setting; junk:=str_toks(b); ins_list(link(temp_token_head));
exit:
end;

@ @<Glob...@>=
in_lua_escape:boolean;

@ @<Set init...@>=
in_lua_escape:=false;

@ @<Scan the argument for command |c|@>=
case c of
number_code,roman_numeral_code: scan_int;
string_code, meaning_code: begin save_scanner_status:=scanner_status;
  scanner_status:=normal; get_token; scanner_status:=save_scanner_status;
  end;
etex_code: do_nothing;
omega_code: do_nothing;
aleph_code: do_nothing;
font_name_code: scan_font_ident;
pdftex_revision_code: do_nothing;
luatex_revision_code: do_nothing;
luatex_date_code: do_nothing;
pdftex_banner_code: do_nothing;
pdf_font_name_code, pdf_font_objnum_code, pdf_font_size_code: begin
    scan_font_ident;
    if cur_val = null_font then
        pdf_error('font', 'invalid font identifier');
    if c <> pdf_font_size_code then begin
        pdf_check_vf(cur_val);
        if not font_used(cur_val) then
            pdf_init_font(static_pdf, cur_val);
    end;
end;
pdf_page_ref_code: begin
    scan_int;
    if cur_val <= 0 then
        pdf_error('pageref', 'invalid page number');
end;
left_margin_kern_code, right_margin_kern_code: begin
    scan_int;
    if (box(cur_val) = null) or (type(box(cur_val)) <> hlist_node) then
        pdf_error('marginkern', 'a non-empty hbox expected')
end;
pdf_xform_name_code: begin
    scan_int;
    pdf_check_obj(static_pdf,obj_type_xform, cur_val);
end;
pdf_creation_date_code:
  begin
    ins_list(string_to_toks(getcreationdate(static_pdf)));
    return;
  end;
job_name_code: if job_name=0 then open_log_file;
pdf_colorstack_init_code:
  begin
    bool := scan_keyword('page');
    if scan_keyword('direct') then
        cur_val := direct_always
    else
        if scan_keyword('page') then
            cur_val := direct_page
        else
            cur_val := set_origin;
    save_scanner_status := scanner_status;
    save_warning_index := warning_index;
    save_def_ref := def_ref;
    save_cur_string;
    scan_pdf_ext_toks;
    s := tokens_to_string(def_ref);
    delete_token_ref(def_ref);
    def_ref := save_def_ref;
    warning_index := save_warning_index;
    scanner_status := save_scanner_status;
    cur_val := newcolorstack(s, cur_val, bool);
    flush_str(s);
    cur_val_level := int_val_level;
    if cur_val < 0 then begin
        print_err('Too many color stacks');
@.Too many color stacks@>
        help2('The number of color stacks is limited to 32768.',
        'I''ll use the default color stack 0 here.');
        error;
        cur_val := 0;
       restore_cur_string;
    end;
  end;
uniform_deviate_code:     scan_int;
normal_deviate_code:      do_nothing;
lua_escape_string_code:
  begin
        u:=0;
    { check if a string is already being built}
    if str_start_macro(str_ptr)<pool_ptr then u:=make_string;
    save_scanner_status := scanner_status;
    save_def_ref := def_ref;
    save_warning_index := warning_index;
    scan_pdf_ext_toks;
    bool := in_lua_escape;
    in_lua_escape:=true;
    s := tokens_to_string(def_ref);
    in_lua_escape:=bool;
    delete_token_ref(def_ref);
    def_ref := save_def_ref;
    warning_index := save_warning_index;
    scanner_status := save_scanner_status;
    junk := lua_str_toks(str_start_macro(s));
        ins_list(link(temp_token_head));
    flush_str(s);
        if u<>0 then begin decr(str_ptr); u:=0; end;
    return;
  end;
math_style_code:  do_nothing;
expanded_code:
  begin
    save_scanner_status := scanner_status;
    save_warning_index := warning_index;
    save_def_ref := def_ref;
    save_cur_string;
    scan_pdf_ext_toks;
    warning_index := save_warning_index;
    scanner_status := save_scanner_status;
    ins_list(link(def_ref));
    def_ref := save_def_ref;
    restore_cur_string;
    return;
  end;
lua_code:
  begin
    u:=0;
    { Have to check if a string is already being built, because lua code
      may call library functions that may call C functions that
      themselves use the string pool, like e.g. |maketexstring| }
    if str_start_macro(str_ptr)<pool_ptr then u:=make_string;
    save_scanner_status := scanner_status;
    save_def_ref := def_ref;
    save_warning_index := warning_index;
    sn:=0;
    if scan_keyword('name') then begin
       scan_pdf_ext_toks;
       sn := def_ref;
    end;
    @<Parse optional lua state integer, or an instance name to be stored in |sn|@>;
    scan_pdf_ext_toks;
    s := def_ref;
    warning_index := save_warning_index;
    def_ref := save_def_ref;
    scanner_status := save_scanner_status;
    luacstrings:=0;
    luatokencall(s,sn);
    delete_token_ref(s);
    if u<>0 then begin
      if str_ptr=u+1 then
        decr(str_ptr)
      else begin {copy old string to the top location}
         i:=0;
             str_room(length(u));
         while i<length(u) do
           str_pool[pool_ptr+i]:=str_pool[str_start_macro(u)+i];
        end;
    end;
    if luacstrings>0 then
      lua_string_start;
    return;
  end;
pdf_insert_ht_code: scan_register_num;
pdf_ximage_bbox_code: begin
    scan_int;
    pdf_check_obj(static_pdf, obj_type_ximage, cur_val);
    i := obj_data_ptr(static_pdf, cur_val);
    scan_int;
    j := cur_val;
    if (j < 1) or (j > 4) then
        pdf_error('pdfximagebbox', 'invalid parameter');
    end;
@<Cases of `Scan the argument for command |c|'@>
end {there are no other cases}

@ @<Parse optional lua state...@>=
begin
    @<Get the next non-blank non-relax non-call token@>;
    back_input; { have to push it back, whatever it is }
    if cur_cmd<>left_brace then begin
      scan_register_num;
      if get_lua_name(cur_val) then
        sn:=(cur_val-65536);
      end;
end

@ @<Print the result of command |c|@>=
case c of
number_code: print_int(cur_val);
roman_numeral_code: print_roman_int(cur_val);
string_code:if cur_cs<>0 then sprint_cs(cur_cs)
  else print(cur_chr);
meaning_code: print_meaning;
etex_code: print(eTeX_version_string);
omega_code: print(Omega_version_string);
aleph_code: print(Aleph_version_string);
font_name_code: begin
  append_string(font_name(cur_val));
  if font_size(cur_val)<>font_dsize(cur_val) then
    begin print(" at "); print_scaled(font_size(cur_val));
    print("pt");
    end;
  end;
pdftex_revision_code: print(pdftex_revision);
luatex_revision_code: print(luatex_revision);
luatex_date_code:   print_int(luatex_date_info);
pdftex_banner_code: tprint(pdftex_banner);
pdf_font_name_code, pdf_font_objnum_code: begin
    set_ff(cur_val);
    if c = pdf_font_name_code then
        print_int(obj_info(static_pdf, pdf_font_num(ff)))
    else
        print_int(pdf_font_num(ff));
end;
pdf_font_size_code: begin
    print_scaled(font_size(cur_val));
    print("pt");
end;
pdf_page_ref_code: print_int(get_obj(static_pdf, obj_type_page, cur_val, false));
left_margin_kern_code: begin
    p := list_ptr(box(cur_val));
    if (p <> null) and (not is_char_node(p)) and
       (type(p) = glue_node) and (subtype(p) = left_skip_code + 1) then
       p := vlink(p);
    if (p <> null) and (not is_char_node(p)) and
       (type(p) = margin_kern_node) and (subtype(p) = left_side) then
        print_scaled(width(p))
    else
        print("0");
    print("pt");
end;
right_margin_kern_code: begin
    q := list_ptr(box(cur_val));
    p := null;
    if q <> null then begin
        p := prev_rightmost(q, null);
        if (p <> null) and (not is_char_node(p)) and
           (type(p) = glue_node) and (subtype(p) = right_skip_code + 1) then
           p := prev_rightmost(q, p);
    end;
    if (p <> null) and (not is_char_node(p)) and
       (type(p) = margin_kern_node) and (subtype(p) = right_side) then
        print_scaled(width(p))
    else
        print("0");
    print("pt");
end;
pdf_xform_name_code: print_int(obj_info(static_pdf, cur_val));
pdf_colorstack_init_code: print_int(cur_val);
uniform_deviate_code:     print_int(unif_rand(cur_val));
normal_deviate_code:      print_int(norm_rand);
math_style_code:          print_math_style;
pdf_insert_ht_code: begin
    i := qi(cur_val);
    p := page_ins_head;
    while i >= subtype(vlink(p)) do
        p := vlink(p);
    if subtype(p) = i then
        print_scaled(height(p))
    else
        print("0");
    print("pt");
end;
pdf_ximage_bbox_code: begin
    if is_pdf_image(i) then begin
        case j of
        1: print_scaled(epdf_orig_x(i));
        2: print_scaled(epdf_orig_y(i));
        3: print_scaled(epdf_orig_x(i) + epdf_xsize(i));
        4: print_scaled(epdf_orig_y(i) + epdf_ysize(i));
        endcases;
    end else
        print_scaled(0);
    print("pt");
end;
format_name_code: print(format_name);
job_name_code: print(job_name);
@/@<Cases of `Print the result of command |c|'@>@/
end {there are no other cases}

@
@p function is_convert(c:halfword):boolean;
begin
  is_convert:=(c=convert);
end;

function the_convert_string (c:halfword;i:integer):str_number;
var old_setting:0..max_selector; {saved |selector| setting}
        is_known:boolean;
        ff:integer; {for use with |set_ff| }
begin
  old_setting:=selector;
  selector:=new_string;
  is_known:=true;
  case c of
  number_code:            print_int(i);
  roman_numeral_code:     print_roman_int(i);
  etex_code:              print(eTeX_version_string);
  omega_code:             print(Omega_version_string);
  aleph_code:             print(Aleph_version_string);
  pdftex_revision_code:   print(pdftex_revision);
  luatex_revision_code:   print(luatex_revision);
  luatex_date_code:       print_int(luatex_date_info);
  pdftex_banner_code:     tprint(pdftex_banner);
  normal_deviate_code:    print_int(norm_rand);
  uniform_deviate_code:   print_int(unif_rand(i));
  format_name_code:       print(format_name);
  job_name_code:          print(job_name);
  math_style_code:        print_math_style;
  font_name_code: begin
    append_string(font_name(i));
    if font_size(i)<>font_dsize(i) then
      begin print(" at "); print_scaled(font_size(i));
      print("pt");
      end;
    end;
  font_identifier_code:   print_font_identifier(i);
  pdf_page_ref_code:      print_int(get_obj(static_pdf, obj_type_page, i, false));
  pdf_xform_name_code:    print_int(obj_info(static_pdf, i));
  pdf_font_name_code, pdf_font_objnum_code: begin
    set_ff(i);
    if c = pdf_font_name_code then
        print_int(obj_info(static_pdf, pdf_font_num(ff)))
    else
        print_int(pdf_font_num(ff));
    end;
  pdf_font_size_code: begin
    print_scaled(font_size(i));
    print("pt");
  end;

@/@<Cases of `Print the result of command |c|'@>@/
  othercases            is_known:=false
  end;
  if is_known then
    the_convert_string := make_string
  else
    the_convert_string := 0;
  selector:=old_setting;
end;

@ Another way to create a token list is via the \.{\\read} command. The
sixteen files potentially usable for reading appear in the following
global variables. The value of |read_open[n]| will be |closed| if
stream number |n| has not been opened or if it has been fully read;
|just_open| if an \.{\\openin} but not a \.{\\read} has been done;
and |normal| if it is open and ready to read the next line.

@d closed=2 {not open, or at end of file}
@d just_open=1 {newly opened, first line not yet read}

@<Glob...@>=
@!read_file:array[0..15] of alpha_file; {used for \.{\\read}}
@!read_open:array[0..16] of normal..closed; {state of |read_file[n]|}

@ @<Set init...@>=
for k:=0 to 16 do begin
    read_open[k]:=closed;
end;

@ The |read_toks| procedure constructs a token list like that for any
macro definition, and makes |cur_val| point to it. Parameter |r| points
to the control sequence that will receive this token list.

@p procedure read_toks(@!n:integer;@!r:pointer;@!j:halfword);
label done;
var p:pointer; {tail of the token list}
@!q:pointer; {new node being added to the token list via |store_new_token|}
@!s:integer; {saved value of |align_state|}
@!m:small_number; {stream number}
begin scanner_status:=defining; warning_index:=r;
p:=get_avail; def_ref:=p; set_token_ref_count(def_ref,0);
p:=def_ref; {the reference count}
store_new_token(end_match_token);
if (n<0)or(n>15) then m:=16@+else m:=n;
s:=align_state; align_state:=1000000; {disable tab marks, etc.}
repeat @<Input and store tokens from the next line of the file@>;
until align_state=1000000;
cur_val:=def_ref; scanner_status:=normal; align_state:=s;
end;

@ @<Input and store tokens from the next line of the file@>=
begin_file_reading; iname:=m+1;
if read_open[m]=closed then @<Input for \.{\\read} from the terminal@>
else if read_open[m]=just_open then @<Input the first line of |read_file[m]|@>
else @<Input the next line of |read_file[m]|@>;
ilimit:=last;
if end_line_char_inactive then decr(ilimit)
else  buffer[ilimit]:=end_line_char;
first:=ilimit+1; iloc:=istart; istate:=new_line;@/
@<Handle \.{\\readline} and |goto done|@>;@/
loop@+  begin get_token;
  if cur_tok=0 then goto done;
    {|cur_cmd=cur_chr=0| will occur at the end of the line}
  if align_state<1000000 then {unmatched `\.\}' aborts the line}
    begin repeat get_token; until cur_tok=0;
    align_state:=1000000; goto done;
    end;
  store_new_token(cur_tok);
  end;
done: end_file_reading

@ Here we input on-line into the |buffer| array, prompting the user explicitly
if |n>=0|.  The value of |n| is set negative so that additional prompts
will not be given in the case of multi-line input.

@<Input for \.{\\read} from the terminal@>=
if interaction>nonstop_mode then
  if n<0 then prompt_input('')
  else  begin wake_up_terminal;
    print_ln; sprint_cs(r); prompt_input(' ='); n:=-1;
    end
else fatal_error('*** (cannot \read from terminal in nonstop modes)')
@.cannot \\read@>

@ The first line of a file must be treated specially, since |lua_input_ln|
must be told not to start with |get|.
@^system dependencies@>

@<Input the first line of |read_file[m]|@>=
begin if lua_input_ln(read_file[m],(m+1),false) then read_open[m]:=normal
else  begin lua_a_close_in(read_file[m],(m+1)); read_open[m]:=closed;
  end;
end

@ An empty line is appended at the end of a |read_file|.
@^empty line at end of file@>

@<Input the next line of |read_file[m]|@>=
begin if not lua_input_ln(read_file[m],(m+1),true) then
  begin lua_a_close_in(read_file[m],(m+1)); read_open[m]:=closed;
  if align_state<>1000000 then
    begin runaway;
    print_err('File ended within '); print_esc("read");
@.File ended within \\read@>
    help1('This \read has unbalanced braces.');
    align_state:=1000000; error;
    end;
  end;
end

@* \[28] Conditional processing.

@<Put each...@>=
primitive_tex("if",if_test,if_char_code,0);
@!@:if_char_}{\.{\\if} primitive@>
primitive_tex("ifcat",if_test,if_cat_code,0);
@!@:if_cat_code_}{\.{\\ifcat} primitive@>
primitive_tex("ifnum",if_test,if_int_code,0);
@!@:if_int_}{\.{\\ifnum} primitive@>
primitive_tex("ifdim",if_test,if_dim_code,0);
@!@:if_dim_}{\.{\\ifdim} primitive@>
primitive_tex("ifodd",if_test,if_odd_code,0);
@!@:if_odd_}{\.{\\ifodd} primitive@>
primitive_tex("ifvmode",if_test,if_vmode_code,0);
@!@:if_vmode_}{\.{\\ifvmode} primitive@>
primitive_tex("ifhmode",if_test,if_hmode_code,0);
@!@:if_hmode_}{\.{\\ifhmode} primitive@>
primitive_tex("ifmmode",if_test,if_mmode_code,0);
@!@:if_mmode_}{\.{\\ifmmode} primitive@>
primitive_tex("ifinner",if_test,if_inner_code,0);
@!@:if_inner_}{\.{\\ifinner} primitive@>
primitive_tex("ifvoid",if_test,if_void_code,0);
@!@:if_void_}{\.{\\ifvoid} primitive@>
primitive_tex("ifhbox",if_test,if_hbox_code,0);
@!@:if_hbox_}{\.{\\ifhbox} primitive@>
primitive_tex("ifvbox",if_test,if_vbox_code,0);
@!@:if_vbox_}{\.{\\ifvbox} primitive@>
primitive_tex("ifx",if_test,ifx_code,0);
@!@:ifx_}{\.{\\ifx} primitive@>
primitive_tex("ifeof",if_test,if_eof_code,0);
@!@:if_eof_}{\.{\\ifeof} primitive@>
primitive_tex("iftrue",if_test,if_true_code,0);
@!@:if_true_}{\.{\\iftrue} primitive@>
primitive_tex("iffalse",if_test,if_false_code,0);
@!@:if_false_}{\.{\\iffalse} primitive@>
primitive_tex("ifcase",if_test,if_case_code,0);
@!@:if_case_}{\.{\\ifcase} primitive@>
primitive_luatex("ifprimitive",if_test,if_primitive_code,0);
@!@:if_primitive_}{\.{\\ifprimitive} primitive@>
primitive_pdftex("ifpdfprimitive",if_test,if_primitive_code,0);
@!@:if_primitive_}{\.{\\ifpdfprimitive} primitive@>

@ @<Put each...@>=
primitive_tex("fi",fi_or_else,fi_code,0);
@!@:fi_}{\.{\\fi} primitive@>
text(frozen_fi):="fi"; eqtb[frozen_fi]:=eqtb[cur_val];
primitive_tex("or",fi_or_else,or_code,0);
@!@:or_}{\.{\\or} primitive@>
primitive_tex("else",fi_or_else,else_code,0);
@!@:else_}{\.{\\else} primitive@>

@* \[29] File names.

@ @<Check the ``constant'' values for consistency@>=
if format_default_length>file_name_size then bad:=31;

@* \[30] Font metric data and OCPS.
\TeX\ gets its knowledge about fonts from font metric files, also called
\.{TFM} files; the `\.T' in `\.{TFM}' stands for \TeX,
but other programs know about them too.
@:TFM files}{\.{TFM} files@>
@^font metric files@>

@ When the user defines \.{\\font\\f}, say, \TeX\ assigns an internal number
to the user's font~\.{\\f}. Adding this number to |font_id_base| gives the
|eqtb| location of a ``frozen'' control sequence that will always select
the font.

@<Types...@>=
@!internal_font_number=integer; {|font| in a |char_node|}
@!font_index=integer; {index into |font_info|}

@ @<Glob...@>=
@!font_bytes:integer;

@ \TeX\ always knows at least one font, namely the null font. It has no
characters, and its seven parameters are all equal to zero.

@<Initialize table...@>=
create_null_font;
font_bytes:=0;

@ @<Put each...@>=
primitive_tex("nullfont",set_font,null_font,0);
@!@:null_font_}{\.{\\nullfont} primitive@>
text(frozen_null_font):="nullfont"; eqtb[frozen_null_font]:=eqtb[cur_val];

@ When \TeX\ wants to typeset a character that doesn't exist, the
character node is not created; thus the output routine can assume
that characters exist when it sees them. The following procedure
prints a warning message unless the user has suppressed it.

@p procedure char_warning(@!f:internal_font_number;@!c:integer);
var old_setting: integer; {saved value of |tracing_online|}
    k:0..22; {index to current digit; we assume that $0\L n<16^{22}$}
begin if tracing_lost_chars>0 then
 begin old_setting:=tracing_online;
 if tracing_lost_chars>1 then tracing_online:=1;
  begin begin_diagnostic;
  print_nl("Missing character: There is no ");
@.Missing character@>
  print(c); print(" (U+");
  k:=0;
  if c<16 then print_char('0');
  if c<256 then print_char('0');
  if c<4096 then print_char('0');
  repeat dig[k]:=c mod 16; c:=c div 16; incr(k);
  until c=0;
  print_the_digs(k);
  print(") in font ");
  print_font_name(f);
  print_char("!"); end_diagnostic(false);
  end;
 tracing_online:=old_setting;
 end;
end;

@ Here we begin the \.{OCP} handling.

@ $\Omega$ always knows at least one ocp, namely the null ocp.
It does nothing.

@<Initialize table...@>=
init_null_ocp("","nullocp");

@ @<Put each...@>=
primitive_omega("nullocp", set_ocp, null_ocp,0);
text(frozen_null_ocp) := "nullocp";
eqtb[frozen_null_ocp] := eqtb[cur_val];
geq_define(ocp_active_number_base, data, 0);
geq_define(ocp_active_min_ptr_base, data, 0);
geq_define(ocp_active_max_ptr_base, data, 0);

@ Here we begin the \.{OCP} list handling.

@
@<Initialize table...@>=
initialize_init_ocplists;

@ $\Omega$ always knows at least one ocp list, namely the null ocp list.

@ @<Put each...@>=
primitive_omega("nullocplist", set_ocp_list, null_ocp_list,0);
text(frozen_null_ocp_list) := "nullocplist";
eqtb[frozen_null_ocp_list] := eqtb[cur_val];

@* \[31] Device-independent file format.

@* \[32a] \pdfTeX\ basic.

Initialize \pdfTeX's parameters to some useful default value.
Helpful in case one forgets to set them during initex run.

@<Initialize table entries...@>=
pdf_h_origin := one_inch;
pdf_v_origin := one_inch;
pdf_compress_level := 9;
pdf_objcompresslevel := 0;
pdf_decimal_digits := 3;
pdf_image_resolution := 72;
pdf_minor_version := 4;
pdf_gamma := 1000;
pdf_image_gamma := 2200;
pdf_image_hicolor := 1;
pdf_image_apply_gamma := 0;
pdf_px_dimen := one_bp;
pdf_draftmode := 0;

@ The subroutines define the corresponding macros so we can use them
in C.

@d is_valid_char(#) == char_exists(f,#)

@p function get_nullfont: internal_font_number;
begin
    get_nullfont := null_font;
end;

function get_ocp_active_number_base: integer;
begin
    get_ocp_active_number_base := ocp_active_number_base;
end;

function get_ocp_id_base: integer;
begin
    get_ocp_id_base := ocp_id_base;
end;

function get_ocp_list_id_base: integer;
begin
    get_ocp_list_id_base := ocp_list_id_base;
end;

function get_luatexversion: integer;
begin
    get_luatexversion := luatex_version;
end;
function get_luatexrevision: str_number;
begin
    get_luatexrevision := luatex_revision;
end;
function get_pdftexversion: integer;
begin
    get_pdftexversion := pdftex_version;
end;
function get_Aleph_version: integer;
begin
    get_Aleph_version := Aleph_version;
end;
function get_Omega_version: integer;
begin
    get_Omega_version := Omega_version;
end;
function get_eTeX_version: integer;
begin
    get_eTeX_version := eTeX_version;
end;

function get_Aleph_minor_version: integer;
begin
    get_Aleph_minor_version := Aleph_minor_version;
end;
function get_Omega_minor_version: integer;
begin
    get_Omega_minor_version := Omega_minor_version;
end;
function get_eTeX_minor_version: integer;
begin
    get_eTeX_minor_version := eTeX_minor_version;
end;

function get_par_shape_ptr: halfword;
begin
    get_par_shape_ptr := par_shape_ptr;
end;

function get_escape_char: integer;
begin
    get_escape_char := escape_char;
end;

function get_undefined_control_sequence: integer;
begin
    get_undefined_control_sequence := undefined_control_sequence;
end;

function get_fontbase: internal_font_number;
begin
    get_fontbase := font_base;
end;

function get_nullcs: pointer;
begin
    get_nullcs := null_cs;
end;

function get_tex_int(code: integer): integer;
begin
    get_tex_int := int_par(code);
end;

function get_tex_dimen(code: integer): scaled;
begin
    get_tex_dimen := dimen_par(code);
end;


function get_x_height(f: internal_font_number): scaled;
begin
    get_x_height := x_height(f);
end;

function get_charwidth(f: internal_font_number; c: integer): scaled;
begin
    if is_valid_char(c) then
        get_charwidth := char_width(f,c)
    else
        get_charwidth := 0;
end;

function get_charheight(f: internal_font_number; c: integer): scaled;
begin
    if is_valid_char(c) then
        get_charheight := char_height(f,c)
    else
        get_charheight := 0;
end;

function get_chardepth(f: internal_font_number; c: integer): scaled;
begin
    if is_valid_char(c) then
        get_chardepth := char_depth(f,c)
    else
        get_chardepth := 0;
end;

function get_quad(f: internal_font_number): scaled;
begin
    get_quad := quad(f);
end;

function get_slant(f: internal_font_number): scaled;
begin
    get_slant := slant(f);
end;

function new_dummy_font: internal_font_number;
begin
    new_dummy_font := read_font_info(null_cs, "dummy", -1000, -1);
end;

function get_hash_size: integer;
begin
  get_hash_size:= hash_size;
end;

function get_eqtb_size: integer;
begin
  get_eqtb_size:= eqtb_size;
end;

function get_hash_base: integer;
begin
  get_hash_base:= hash_base;
end;

function get_font_id_base: integer;
begin
  get_font_id_base:= font_id_base;
end;

function get_cur_font: internal_font_number;
begin
  get_cur_font:= cur_font;
end;

function get_default_hyphen_char:integer;
begin
  get_default_hyphen_char:=default_hyphen_char;
end;

function get_default_skew_char:integer;
begin
  get_default_skew_char:=default_skew_char;
end;

@ 

@p procedure set_cur_font (f: internal_font_number);
var a:small_number;
begin
  a:=0;
  define(cur_font_loc,data,f);
end;

@ Helper for debugging purposes

@p procedure short_display_n(@!p, m:integer); {prints highlights of list |p|}
var i: integer;
begin
i := 0;
font_in_short_display:=null_font;
if p = null then
    return;
while p<>null do
  begin if is_char_node(p) then
    begin if p<=max_halfword then
      begin if font(p)<>font_in_short_display then
        begin if not is_valid_font(font(p)) then
          print_char("*")
@.*\relax@>
        else print_font_identifier(font(p));
        print_char(" "); font_in_short_display:=font(p);
        end;
      print(qo(character(p)));
      end;
    end
  else begin
      if (type(p) = glue_node) or
         (type(p) = disc_node) or
         (type(p) = penalty_node) or
         ((type(p) = kern_node) and (subtype(p) = explicit)) then
         incr(i);
      if i >= m then
         return;
      if (type(p) = disc_node) then begin
          print("|");
          short_display(vlink(pre_break(p)));
          print("|");
          short_display(vlink(post_break(p)));
          print("|");
        end
        else
            @<Print a short indication of the contents of node |p|@>;
  end;
  p:=vlink(p);
  if p = null then
      return;
  end;
  update_terminal;
end;


@* \[32b] \pdfTeX\ output low-level subroutines.

@ @<Set init...@>=
initialize_pdfgen;

@ @p
function fix_int(val, min, max: integer): integer;
begin
    if val < min then
        fix_int := min
    else if val > max then
        fix_int := max
    else
        fix_int := val;
end;

@ @<Declare procedures that need to be declared forward for \pdfTeX@>=
function tokens_to_string(p: pointer): str_number; {return a string from tokens
list}
var old_setting:integer;
last_tokens_string:str_number;
begin
    if selector = new_string then
        pdf_error('tokens', 'tokens_to_string() called while selector = new_string');
    old_setting:=selector; selector:=new_string;
    show_token_list(link(p),null,pool_size-pool_ptr);
    selector:=old_setting;
    last_tokens_string := make_string;
    tokens_to_string := last_tokens_string;
end;

@  This are more generally useful
@d call_func(#) == begin if # <> 0 then do_nothing end
@d max_integer == @"7FFFFFFF {$2^{31}-1$}


@* \[32c] PDF page description.

This is now in pdfgen.c.

@ data structure for \.{\\latelua}

@d late_lua_data           == write_tokens {data}
@d late_lua_name(#)        == vlink(#+3) {name}

@* \[32d] The cross-reference table.

@* \[32e] Font processing.

@* \[32f] PDF shipping out.

@ Now we are ready to declare our new procedure |ship_out|.  It will call
|pdf_ship_out| if the integer parameter |pdf_output| is positive; otherwise it
will call |dvi_ship_out|, which is the \TeX\ original |ship_out|.

@p procedure ship_out(p:pointer); {output the box |p|}
begin
    fix_pdfoutput;
    if pdf_output > 0 then
        pdf_ship_out(static_pdf, p, true)
    else
        dvi_ship_out(p);
end;

@* \[33] Packaging.

Is done in C.

@* \[34] Data structures for math mode.

Is done in C.

@* \[35] Subroutines for math mode.

Is one in C.

@* \[36] Typesetting math formulas.

Is done in C.

@* \[37] Alignment.

@<Put each of \TeX's primitives into the hash table@>=
primitive_tex("span",tab_mark,span_code,span_code);@/
@!@:span_}{\.{\\span} primitive@>
primitive_tex("cr",car_ret,cr_code,cr_code);
@!@:cr_}{\.{\\cr} primitive@>
text(frozen_cr):="cr"; eqtb[frozen_cr]:=eqtb[cur_val];@/
primitive_tex("crcr",car_ret,cr_cr_code,cr_code);
@!@:cr_cr_}{\.{\\crcr} primitive@>
text(frozen_end_template):="endtemplate"; text(frozen_endv):="endtemplate";
eq_type(frozen_endv):=endv; equiv(frozen_endv):=null_list;
eq_level(frozen_endv):=level_one;@/
eqtb[frozen_end_template]:=eqtb[frozen_endv];
eq_type(frozen_end_template):=end_template;

@ @<Initialize the special...@>=
initialize_alignments;

@* \[38] Breaking paragraphs into lines.

@p @<Declare \eTeX\ procedures for use by |main_control|@>

@ It is possible that the user wants to interfere at some point.

@d check_filter(#)==if not output_active then lua_node_filter_s(buildpage_filter_callback,#)

@* \[39] Breaking paragraphs into lines, continued.

Hyphenation and line breaking are now all handled in C. Only the
section heads are kept here.

@* \[40] Pre-hyphenation.

@* \[41] Post-hyphenation.

@* \[42] Hyphenation.

@* \[43] Initializing the hyphenation tables.

None of the trie-related stuff is applicable any more in luatex.

@* \[44] Breaking vertical lists into pages.

Part of the C packaging code.

@* \[45] The page builder.
When \TeX\ appends new material to its main vlist in vertical mode, it uses
a method something like |vsplit| to decide where a page ends, except that
the calculations are done ``on line'' as new items come in.
The main complication in this process is that insertions must be put
into their boxes and removed from the vlist, in a more-or-less optimum manner.

We shall use the term ``current page'' for that part of the main vlist that
is being considered as a candidate for being broken off and sent to the
user's output routine. The current page starts at |vlink(page_head)|, and
it ends at |page_tail|.  We have |page_head=page_tail| if this list is empty.
@^current page@>

Utter chaos would reign if the user kept changing page specifications
while a page is being constructed, so the page builder keeps the pertinent
specifications frozen as soon as the page receives its first box or
insertion.  The global variable |page_contents| is |empty| when the
current page contains only mark nodes and content-less whatsit nodes; it
is |inserts_only| if the page contains only insertion nodes in addition to
marks and whatsits.  Glue nodes, kern nodes, and penalty nodes are
discarded until a box or rule node appears, at which time |page_contents|
changes to |box_there|.  As soon as |page_contents| becomes non-|empty|,
the current |vsize| and |max_depth| are squirreled away into |page_goal|
and |page_max_depth|; the latter values will be used until the page has
been forwarded to the user's output routine. The \.{\\topskip} adjustment
is made when |page_contents| changes to |box_there|.

Although |page_goal| starts out equal to |vsize|, it is decreased by the
scaled natural height-plus-depth of the insertions considered so far, and by
the \.{\\skip} corrections for those insertions. Therefore it represents
the size into which the non-inserted material should fit, assuming that
all insertions in the current page have been made.

The global variables |best_page_break| and |least_page_cost| correspond
respectively to the local variables |best_place| and |least_cost| in the
|vert_break| routine that we have already studied; i.e., they record the
location and value of the best place currently known for breaking the
current page. The value of |page_goal| at the time of the best break is
stored in |best_size|.

@d inserts_only=1
  {|page_contents| when an insert node has been contributed, but no boxes}
@d box_there=2 {|page_contents| when a box or rule has been contributed}

@<Glob...@>=
@!page_tail:pointer; {the final node on the current page}
@!page_contents:empty..box_there; {what is on the current page so far?}
@!page_max_depth:scaled; {maximum box depth on page being built}
@!best_page_break:pointer; {break here to get the best page known so far}
@!least_page_cost:integer; {the score for this currently best page}
@!best_size:scaled; {its |page_goal|}

@ The page builder has another data structure to keep track of insertions.
This is a list of four-word nodes, starting and ending at |page_ins_head|.
That is, the first element of the list is node |r@t$_1$@>=vlink(page_ins_head)|;
node $r_j$ is followed by |r@t$_{j+1}$@>=vlink(r@t$_j$@>)|; and if there are
|n| items we have |r@t$_{n+1}$@>=page_ins_head|. The |subtype| field of
each node in this list refers to an insertion number; for example, `\.{\\insert
250}' would correspond to a node whose |subtype| is |qi(250)|
(the same as the |subtype| field of the relevant |ins_node|). These |subtype|
fields are in increasing order, and |subtype(page_ins_head)=65535|, so
|page_ins_head| serves as a convenient sentinel
at the end of the list. A record is present for each insertion number that
appears in the current page.

The |type| field in these nodes distinguishes two possibilities that
might occur as we look ahead before deciding on the optimum page break.
If |type(r)=inserting_node|, then |height(r)| contains the total of the
height-plus-depth dimensions of the box and all its inserts seen so far.
If |type(r)=split_up_node|, then no more insertions will be made into this box,
because at least one previous insertion was too big to fit on the current
page; |broken_ptr(r)| points to the node where that insertion will be
split, if \TeX\ decides to split it, |broken_ins(r)| points to the
insertion node that was tentatively split, and |height(r)| includes also the
natural height plus depth of the part that would be split off.

In both cases, |last_ins_ptr(r)| points to the last |ins_node|
encountered for box |qo(subtype(r))| that would be at least partially
inserted on the next page; and |best_ins_ptr(r)| points to the last
such |ins_node| that should actually be inserted, to get the page with
minimum badness among all page breaks considered so far. We have
|best_ins_ptr(r)=null| if and only if no insertion for this box should
be made to produce this optimum page.

The data structure definitions here use the fact that the |@!height| field
appears in the fourth word of a box node.
@^data structure assumptions@>

@d broken_ptr(#)==vlink(#+2)
  {an insertion for this class will break here if anywhere}
@d broken_ins(#)==vinfo(#+2) {this insertion might break at |broken_ptr|}
@d last_ins_ptr(#)==vlink(#+3) {the most recent insertion for this |subtype|}
@d best_ins_ptr(#)==vinfo(#+3) {the optimum most recent insertion}

@<Initialize the special list heads...@>=
subtype(page_ins_head):=65535;
type(page_ins_head):=split_up_node; vlink(page_ins_head):=page_ins_head;

@ An array |page_so_far| records the heights and depths of everything
on the current page. This array contains six |scaled| numbers, like the
similar arrays already considered in |line_break| and |vert_break|; and it
also contains |page_goal| and |page_depth|, since these values are
all accessible to the user via |set_page_dimen| commands. The
value of |page_so_far[1]| is also called |page_total|.  The stretch
and shrink components of the \.{\\skip} corrections for each insertion are
included in |page_so_far|, but the natural space components of these
corrections are not, since they have been subtracted from |page_goal|.

The variable |page_depth| records the depth of the current page; it has been
adjusted so that it is at most |page_max_depth|. The variable
|last_glue| points to the glue specification of the most recent node
contributed from the contribution list, if this was a glue node; otherwise
|last_glue=max_halfword|. (If the contribution list is nonempty,
however, the value of |last_glue| is not necessarily accurate.)
The variables |last_penalty|, |last_kern|, and |last_node_type|
are similar.  And
finally, |insert_penalties| holds the sum of the penalties associated with
all split and floating insertions.

@d page_goal==page_so_far[0] {desired height of information on page being built}
@d page_total==page_so_far[1] {height of the current page}
@d page_shrink==page_so_far[6] {shrinkability of the current page}
@d page_depth==page_so_far[7] {depth of the current page}

@<Glob...@>=
@!page_so_far:array [0..7] of scaled; {height and glue of the current page}
@!last_glue:pointer; {used to implement \.{\\lastskip}}
@!last_penalty:integer; {used to implement \.{\\lastpenalty}}
@!last_kern:scaled; {used to implement \.{\\lastkern}}
@!last_node_type:integer; {used to implement \.{\\lastnodetype}}
@!insert_penalties:integer; {sum of the penalties for held-over insertions}

@ @<Put each...@>=
primitive_tex("pagegoal",set_page_dimen,0,0);
@!@:page_goal_}{\.{\\pagegoal} primitive@>
primitive_tex("pagetotal",set_page_dimen,1,0);
@!@:page_total_}{\.{\\pagetotal} primitive@>
primitive_tex("pagestretch",set_page_dimen,2,0);
@!@:page_stretch_}{\.{\\pagestretch} primitive@>
primitive_tex("pagefilstretch",set_page_dimen,3,0);
@!@:page_fil_stretch_}{\.{\\pagefilstretch} primitive@>
primitive_tex("pagefillstretch",set_page_dimen,4,0);
@!@:page_fill_stretch_}{\.{\\pagefillstretch} primitive@>
primitive_tex("pagefilllstretch",set_page_dimen,5,0);
@!@:page_filll_stretch_}{\.{\\pagefilllstretch} primitive@>
primitive_tex("pageshrink",set_page_dimen,6,0);
@!@:page_shrink_}{\.{\\pageshrink} primitive@>
primitive_tex("pagedepth",set_page_dimen,7,0);
@!@:page_depth_}{\.{\\pagedepth} primitive@>

@ @d print_plus_end(#)==print(#);@+end
@d print_plus(#)==if page_so_far[#]<>0 then
  begin print(" plus "); print_scaled(page_so_far[#]); print_plus_end

@p procedure print_totals;
begin print_scaled(page_total);
print_plus(2)("");
print_plus(3)("fil");
print_plus(4)("fill");
print_plus(5)("filll");
if page_shrink<>0 then
  begin print(" minus "); print_scaled(page_shrink);
  end;
end;

@ Here is a procedure that is called when the |page_contents| is changing
from |empty| to |inserts_only| or |box_there|.

@d do_all_six(#)==#(1);#(2);#(3);#(4);#(5);#(6);#(7)
@d set_page_so_far_zero(#)==page_so_far[#]:=0

@p procedure freeze_page_specs(@!s:small_number);
begin page_contents:=s;
page_goal:=vsize; page_max_depth:=max_depth;
page_depth:=0; do_all_six(set_page_so_far_zero);
least_page_cost:=awful_bad;
@!stat if tracing_pages>0 then
  begin begin_diagnostic;
  print_nl("%% goal height="); print_scaled(page_goal);
@.goal height@>
  print(", max depth="); print_scaled(page_max_depth);
  end_diagnostic(false);
  end;@;@+tats@;@/
end;

@ Pages are built by appending nodes to the current list in \TeX's
vertical mode, which is at the outermost level of the semantic nest. This
vlist is split into two parts; the ``current page'' that we have been
talking so much about already, and the ``contribution list'' that receives
new nodes as they are created.  The current page contains everything that
the page builder has accounted for in its data structures, as described
above, while the contribution list contains other things that have been
generated by other parts of \TeX\ but have not yet been
seen by the page builder.
The contribution list starts at |vlink(contrib_head)|, and it ends at the
current node in \TeX's vertical mode.

When \TeX\ has appended new material in vertical mode, it calls the procedure
|build_page|, which tries to catch up by moving nodes from the contribution
list to the current page. This procedure will succeed in its goal of
emptying the contribution list, unless a page break is discovered, i.e.,
unless the current page has grown to the point where the optimum next
page break has been determined. In the latter case, the nodes after the
optimum break will go back onto the contribution list, and control will
effectively pass to the user's output routine.

We make |type(page_head)=glue_node|, so that an initial glue node on
the current page will not be considered a valid breakpoint.

@<Initialize the special list...@>=
type(page_head):=glue_node; subtype(page_head):=normal;

@ The global variable |output_active| is true during the time the
user's output routine is driving \TeX.

@<Glob...@>=
@!output_active:boolean; {are we in the midst of an output routine?}

@ @<Set init...@>=
output_active:=false; insert_penalties:=0;

@ The page builder is ready to start a fresh page if we initialize
the following state variables. (However, the page insertion list is initialized
elsewhere.)

@<Start a new current page@>=
page_contents:=empty; page_tail:=page_head; vlink(page_head):=null;@/
last_glue:=max_halfword; last_penalty:=0; last_kern:=0;
last_node_type:=-1;
page_depth:=0; page_max_depth:=0

@ At certain times box \.{\\outputbox} is supposed to be void (i.e., |null|),
or an insertion box is supposed to be ready to accept a vertical list.
If not, an error message is printed, and the following subroutine
flushes the unwanted contents, reporting them to the user.

@p procedure box_error(@!n:integer);
begin error; begin_diagnostic;
print_nl("The following box has been deleted:");
@.The following...deleted@>
show_box(box(n)); end_diagnostic(true);
flush_node_list(box(n)); box(n):=null;
end;

@ The following procedure guarantees that a given box register
does not contain an \.{\\hbox}.

@p procedure ensure_vbox(@!n:integer);
var p:pointer; {the box register contents}
begin p:=box(n);
if p<>null then if type(p)=hlist_node then
  begin print_err('Insertions can only be added to a vbox');
@.Insertions can only...@>
  help3('Tut tut: You''re trying to \insert into a',
    '\box register that now contains an \hbox.',
    'Proceed, and I''ll discard its present contents.');
  box_error(n);
  end;
end;

@ \TeX\ is not always in vertical mode at the time |build_page|
is called; the current mode reflects what \TeX\ should return to, after
the contribution list has been emptied. A call on |build_page| should
be immediately followed by `|goto big_switch|', which is \TeX's central
control point.

@d contribute=80 {go here to link a node into the current page}
@d update_heights=90 {go here to record glue in the |active_height| table}

@p @t\4@>@<Declare the procedure called |fire_up|@>@;@/
procedure build_page; {append contributions to the current page}
label exit,done,done1,continue,contribute,update_heights;
var p:pointer; {the node being appended}
@!q,@!r:pointer; {nodes being examined}
@!b,@!c:integer; {badness and cost of current page}
@!pi:integer; {penalty to be added to the badness}
@!n:min_quarterword..255; {insertion box number}
@!delta,@!h,@!w:scaled; {sizes used for insertion calculations}
begin pi:=0;
if (vlink(contrib_head)=null)or output_active then return;
repeat continue: p:=vlink(contrib_head);@/
@<Update the values of |last_glue|, |last_penalty|, and |last_kern|@>;
@<Move node |p| to the current page; if it is time for a page break,
  put the nodes following the break back onto the contribution list,
  and |return| to the user's output routine if there is one@>;
until vlink(contrib_head)=null;
@<Make the contribution list empty by setting its tail to |contrib_head|@>;
exit:end;

@ @d contrib_tail==nest[0].tail_field {tail of the contribution list}

@<Make the contribution list empty...@>=
if nest_ptr=0 then tail:=contrib_head {vertical mode}
else contrib_tail:=contrib_head {other modes}

@ @<Update the values of |last_glue|...@>=
if last_glue<>max_halfword then delete_glue_ref(last_glue);
last_penalty:=0; last_kern:=0;
last_node_type:=type(p)+1;
if type(p)=glue_node then
  begin last_glue:=glue_ptr(p); add_glue_ref(last_glue);
  end
else  begin last_glue:=max_halfword;
  if type(p)=penalty_node then last_penalty:=penalty(p)
  else if type(p)=kern_node then last_kern:=width(p);
  end

@ The code here is an example of a many-way switch into routines that
merge together in different places. Some people call this unstructured
programming, but the author doesn't see much wrong with it, as long as
@^Knuth, Donald Ervin@>
the various labels have a well-understood meaning.

@<Move node |p| to the current page; ...@>=
@<If the current page is empty and node |p| is to be deleted, |goto done1|;
  otherwise use node |p| to update the state of the current page;
  if this node is an insertion, |goto contribute|; otherwise if this node
  is not a legal breakpoint, |goto contribute| or |update_heights|;
  otherwise set |pi| to the penalty associated with this breakpoint@>;
@<Check if node |p| is a new champion breakpoint; then \(if)if it is time for
  a page break, prepare for output, and either fire up the user's
  output routine and |return| or ship out the page and |goto done|@>;
if (type(p)<glue_node)or(type(p)>kern_node) then goto contribute;
update_heights:@<Update the current page measurements with respect to the
  glue or kern specified by node~|p|@>;
contribute: @<Make sure that |page_max_depth| is not exceeded@>;
@<Link node |p| into the current page and |goto done|@>;
done1:@<Recycle node |p|@>;
done:

@ @<Link node |p| into the current page and |goto done|@>=
vlink(page_tail):=p; page_tail:=p;
vlink(contrib_head):=vlink(p); vlink(p):=null; goto done

@ @<Recycle node |p|@>=
vlink(contrib_head):=vlink(p); vlink(p):=null;
if saving_vdiscards>0 then
  begin if page_disc=null then page_disc:=p@+else vlink(tail_page_disc):=p;
  tail_page_disc:=p;
  end
else flush_node_list(p)

@ The title of this section is already so long, it seems best to avoid
making it more accurate but still longer, by mentioning the fact that a
kern node at the end of the contribution list will not be contributed until
we know its successor.

@<If the current page is empty...@>=
case type(p) of
hlist_node_case,vlist_node_case,rule_node_case: if page_contents<box_there then
    @<Initialize the current page, insert the \.{\\topskip} glue
      ahead of |p|, and |goto continue|@>
  else @<Prepare to move a box or rule node to the current page,
    then |goto contribute|@>;
whatsit_node_case: @<Prepare to move whatsit |p| to the current page,
                     then |goto contribute|@>;
glue_node_case: if page_contents<box_there then goto done1
  else if precedes_break(page_tail) then pi:=0
  else goto update_heights;
kern_node_case: if page_contents<box_there then goto done1
  else if vlink(p)=null then return
  else if type(vlink(p))=glue_node then pi:=0
  else goto update_heights;
penalty_node_case: if page_contents<box_there then goto done1@+else pi:=penalty(p);
mark_node_case: goto contribute;
ins_node_case: @<Append an insertion to the current page and |goto contribute|@>;
othercases confusion('page')
@:this can't happen page}{\quad page@>
endcases

@ @<Initialize the current page, insert the \.{\\topskip} glue...@>=
begin if page_contents=empty then freeze_page_specs(box_there)
else page_contents:=box_there;
q:=new_skip_param(top_skip_code); {now |temp_ptr=glue_ptr(q)|}
if (type(p)=hlist_node) and is_mirrored(body_direction) then begin
  if width(temp_ptr)>depth(p) then width(temp_ptr):=width(temp_ptr)-depth(p)
  else width(temp_ptr):=0;
  end
else begin
  if width(temp_ptr)>height(p) then width(temp_ptr):=width(temp_ptr)-height(p)
  else width(temp_ptr):=0;
  end;
vlink(q):=p; vlink(contrib_head):=q; goto continue;
end

@ @<Prepare to move a box or rule node to the current page...@>=
begin
if (type(p)=hlist_node) and is_mirrored(body_direction) then begin
  page_total:=page_total+page_depth+depth(p);
  page_depth:=height(p);
  end
else begin
  page_total:=page_total+page_depth+height(p);
  page_depth:=depth(p);
  end;
goto contribute;
end

@ @<Make sure that |page_max_depth| is not exceeded@>=
if page_depth>page_max_depth then
  begin page_total:=@|
    page_total+page_depth-page_max_depth;@/
  page_depth:=page_max_depth;
  end;

@ @<Update the current page measurements with respect to the glue...@>=
if type(p)=kern_node then q:=p
else begin q:=glue_ptr(p);
if stretch_order(q)>1 then
  page_so_far[1+stretch_order(q)]:=@|
    page_so_far[1+stretch_order(q)]+stretch(q)@/
else
  page_so_far[2+stretch_order(q)]:=@|
    page_so_far[2+stretch_order(q)]+stretch(q);@/
  page_shrink:=page_shrink+shrink(q);
  if (shrink_order(q)<>normal)and(shrink(q)<>0) then
    begin@t@>@;@/
    print_err('Infinite glue shrinkage found on current page');@/
@.Infinite glue shrinkage...@>
    help4('The page about to be output contains some infinitely',
      'shrinkable glue, e.g., `\vss'' or `\vskip 0pt minus 1fil''.',
      'Such glue doesn''t belong there; but you can safely proceed,',
      'since the offensive shrinkability has been made finite.');
    error;
    r:=new_spec(q); shrink_order(r):=normal; delete_glue_ref(q);
    glue_ptr(p):=r; q:=r;
    end;
  end;
page_total:=page_total+page_depth+width(q); page_depth:=0

@ @<Check if node |p| is a new champion breakpoint; then \(if)...@>=
if pi<inf_penalty then
  begin @<Compute the badness, |b|, of the current page,
    using |awful_bad| if the box is too full@>;
  if b<awful_bad then
    if pi<=eject_penalty then c:=pi
    else  if b<inf_bad then c:=b+pi+insert_penalties
      else c:=deplorable
  else c:=b;
  if insert_penalties>=10000 then c:=awful_bad;
  @!stat if tracing_pages>0 then @<Display the page break cost@>;@+tats@;@/
  if c<=least_page_cost then
    begin best_page_break:=p; best_size:=page_goal;
    least_page_cost:=c;
    r:=vlink(page_ins_head);
    while r<>page_ins_head do
      begin best_ins_ptr(r):=last_ins_ptr(r);
      r:=vlink(r);
      end;
    end;
  if (c=awful_bad)or(pi<=eject_penalty) then
    begin fire_up(p); {output the current page at the best place}
    if output_active then return; {user's output routine will act}
    goto done; {the page has been shipped out by default output routine}
    end;
  end

@ @<Display the page break cost@>=
begin begin_diagnostic; print_nl("%");
print(" t="); print_totals;@/
print(" g="); print_scaled(page_goal);@/
print(" b=");
if b=awful_bad then print_char("*")@+else print_int(b);
@.*\relax@>
print(" p="); print_int(pi);
print(" c=");
if c=awful_bad then print_char("*")@+else print_int(c);
if c<=least_page_cost then print_char("#");
end_diagnostic(false);
end

@ @<Compute the badness, |b|, of the current page...@>=
if page_total<page_goal then
  if (page_so_far[3]<>0) or (page_so_far[4]<>0) or@|
    (page_so_far[5]<>0) then b:=0
  else b:=badness(page_goal-page_total,page_so_far[2])
else if page_total-page_goal>page_shrink then b:=awful_bad
else b:=badness(page_total-page_goal,page_shrink)

@ @<Append an insertion to the current page and |goto contribute|@>=
begin if page_contents=empty then freeze_page_specs(inserts_only);
n:=subtype(p); r:=page_ins_head;
while n>=subtype(vlink(r)) do r:=vlink(r);
n:=qo(n);
if subtype(r)<>qi(n) then
  @<Create a page insertion node with |subtype(r)=qi(n)|, and
    include the glue correction for box |n| in the
    current page state@>;
if type(r)=split_up_node then insert_penalties:=insert_penalties+float_cost(p)
else  begin last_ins_ptr(r):=p;
  delta:=page_goal-page_total-page_depth+page_shrink;
    {this much room is left if we shrink the maximum}
  if count(n)=1000 then h:=height(p)
  else h:=x_over_n(height(p),1000)*count(n); {this much room is needed}
  if ((h<=0)or(h<=delta))and(height(p)+height(r)<=dimen(n)) then
    begin page_goal:=page_goal-h; height(r):=height(r)+height(p);
    end
  else @<Find the best way to split the insertion, and change
    |type(r)| to |split_up_node|@>;
  end;
goto contribute;
end

@ We take note of the value of \.{\\skip} |n| and the height plus depth
of \.{\\box}~|n| only when the first \.{\\insert}~|n| node is
encountered for a new page. A user who changes the contents of \.{\\box}~|n|
after that first \.{\\insert}~|n| had better be either extremely careful
or extremely lucky, or both.

@<Create a page insertion node...@>=
begin q:=new_node(inserting_node,n); vlink(q):=vlink(r); vlink(r):=q; r:=q;
ensure_vbox(n);
if box(n)=null then height(r):=0
else height(r):=height(box(n))+depth(box(n));
best_ins_ptr(r):=null;@/
q:=skip(n);
if count(n)=1000 then h:=height(r)
else h:=x_over_n(height(r),1000)*count(n);
page_goal:=page_goal-h-width(q);@/
if stretch_order(q)>1 then
  page_so_far[1+stretch_order(q)]:=@|page_so_far[1+stretch_order(q)]+stretch(q)@/
else
  page_so_far[2+stretch_order(q)]:=@|page_so_far[2+stretch_order(q)]+stretch(q);@/
page_shrink:=page_shrink+shrink(q);
if (shrink_order(q)<>normal)and(shrink(q)<>0) then
  begin print_err('Infinite glue shrinkage inserted from '); print_esc("skip");
@.Infinite glue shrinkage...@>
  print_int(n);
  help3('The correction glue for page breaking with insertions',
    'must have finite shrinkability. But you may proceed,',
    'since the offensive shrinkability has been made finite.');
  error;
  end;
end

@ Here is the code that will split a long footnote between pages, in an
emergency. The current situation deserves to be recapitulated: Node |p|
is an insertion into box |n|; the insertion will not fit, in its entirety,
either because it would make the total contents of box |n| greater than
\.{\\dimen} |n|, or because it would make the incremental amount of growth
|h| greater than the available space |delta|, or both. (This amount |h| has
been weighted by the insertion scaling factor, i.e., by \.{\\count} |n|
over 1000.) Now we will choose the best way to break the vlist of the
insertion, using the same criteria as in the \.{\\vsplit} operation.

@<Find the best way to split the insertion...@>=
begin if count(n)<=0 then w:=max_dimen
else  begin w:=page_goal-page_total-page_depth;
  if count(n)<>1000 then w:=x_over_n(w,count(n))*1000;
  end;
if w>dimen(n)-height(r) then w:=dimen(n)-height(r);
q:=vert_break(ins_ptr(p),w,depth(p));
height(r):=height(r)+best_height_plus_depth;
@!stat if tracing_pages>0 then @<Display the insertion split cost@>;@+tats@;@/
if count(n)<>1000 then
  best_height_plus_depth:=x_over_n(best_height_plus_depth,1000)*count(n);
page_goal:=page_goal-best_height_plus_depth;
type(r):=split_up_node; broken_ptr(r):=q; broken_ins(r):=p;
if q=null then insert_penalties:=insert_penalties+eject_penalty
else if type(q)=penalty_node then insert_penalties:=insert_penalties+penalty(q);
end

@ @<Display the insertion split cost@>=
begin begin_diagnostic; print_nl("% split"); print_int(n);
@.split@>
print(" to "); print_scaled(w);
print_char(","); print_scaled(best_height_plus_depth);@/
print(" p=");
if q=null then print_int(eject_penalty)
else if type(q)=penalty_node then print_int(penalty(q))
else print_char("0");
end_diagnostic(false);
end

@ When the page builder has looked at as much material as could appear before
the next page break, it makes its decision. The break that gave minimum
badness will be used to put a completed ``page'' into box \.{\\outputbox}, with insertions
appended to their other boxes.

We also set the values of |top_mark|, |first_mark|, and |bot_mark|. The
program uses the fact that |bot_mark(x)<>null| implies |first_mark(x)<>null|;
it also knows that |bot_mark(x)=null| implies |top_mark(x)=first_mark(x)=null|.

The |fire_up| subroutine prepares to output the current page at the best
place; then it fires up the user's output routine, if there is one,
or it simply ships out the page. There is one parameter, |c|, which represents
the node that was being contributed to the page when the decision to
force an output was made.

@<Declare the procedure called |fire_up|@>=
procedure fire_up(@!c:pointer);
label exit;
var p,@!q,@!r,@!s:pointer; {nodes being examined and/or changed}
@!prev_p:pointer; {predecessor of |p|}
@!n:min_quarterword..255; {insertion box number}
@!wait:boolean; {should the present insertion be held over?}
@!save_vbadness:integer; {saved value of |vbadness|}
@!save_vfuzz: scaled; {saved value of |vfuzz|}
@!save_split_top_skip: pointer; {saved value of |split_top_skip|}
@!i: halfword; { for looping through the marks}
begin @<Set the value of |output_penalty|@>;
for i:=0 to biggest_used_mark do begin
  if bot_mark(i)<>null then
    begin if top_mark(i)<>null then delete_token_ref(top_mark(i));
    set_top_mark(i,bot_mark(i)); add_token_ref(top_mark(i));
    delete_first_mark(i);
    end;
  end;
@<Put the \(o)optimal current page into box |output_box|, update |first_mark| and
  |bot_mark|, append insertions to their boxes, and put the
  remaining nodes back on the contribution list@>;
for i:=0 to biggest_used_mark do begin
  if (top_mark(i)<>null)and(first_mark(i)=null) then
    begin set_first_mark(i,top_mark(i)); add_token_ref(top_mark(i));
    end;
  end;
if output_routine<>null then begin
  if dead_cycles>=max_dead_cycles then
    @<Explain that too many dead cycles have occurred in a row@>
  else @<Fire up the user's output routine and |return|@>;
  end;
@<Perform the default output routine@>;
exit:end;

@ @<Set the value of |output_penalty|@>=
if type(best_page_break)=penalty_node then
  begin geq_word_define(int_base+output_penalty_code,penalty(best_page_break));
  penalty(best_page_break):=inf_penalty;
  end
else geq_word_define(int_base+output_penalty_code,inf_penalty)

@ As the page is finally being prepared for output,
pointer |p| runs through the vlist, with |prev_p| trailing behind;
pointer |q| is the tail of a list of insertions that
are being held over for a subsequent page.

@<Put the \(o)optimal current page into box ...@>=
if c=best_page_break then best_page_break:=null; {|c| not yet linked in}
@<Ensure that box |output_box| is empty before output@>;
insert_penalties:=0; {this will count the number of insertions held over}
save_split_top_skip:=split_top_skip;
if holding_inserts<=0 then
  @<Prepare all the boxes involved in insertions to act as queues@>;
q:=hold_head; vlink(q):=null; prev_p:=page_head; p:=vlink(prev_p);
while p<>best_page_break do
  begin if type(p)=ins_node then
    begin if holding_inserts<=0 then
       @<Either insert the material specified by node |p| into the
         appropriate box, or hold it for the next page;
         also delete node |p| from the current page@>;
    end
  else if type(p)=mark_node then @<Update the values of
    |first_mark| and |bot_mark|@>;
  prev_p:=p; p:=vlink(prev_p);
  end;
split_top_skip:=save_split_top_skip;
@<Break the current page at node |p|, put it in box~|output_box|,
  and put the remaining nodes on the contribution list@>;
@<Delete \(t)the page-insertion nodes@>

@ @<Ensure that box |output_box| is empty before output@>=
if box(output_box)<>null then
  begin print_err(''); print_esc("box"); print_int(output_box); print(" is not void");
@:box\\outputbox}{\.{\\box\\outputbox is not void}@>
  help2('You shouldn''t use \box\outputbox except in \output routines.',
    'Proceed, and I''ll discard its present contents.');
  box_error(output_box);
  end

@ @<Update the values of |first_mark| and |bot_mark|@>=
begin if first_mark(mark_class(p))=null then
  begin set_first_mark(mark_class(p),mark_ptr(p));
  add_token_ref(first_mark(mark_class(p)));
  end;
if bot_mark(mark_class(p))<>null then delete_token_ref(bot_mark(mark_class(p)));
set_bot_mark(mark_class(p),mark_ptr(p)); add_token_ref(bot_mark(mark_class(p)));
end;

@ When the following code is executed, the current page runs from node
|vlink(page_head)| to node |prev_p|, and the nodes from |p| to |page_tail|
are to be placed back at the front of the contribution list. Furthermore
the heldover insertions appear in a list from |vlink(hold_head)| to |q|; we
will put them into the current page list for safekeeping while the user's
output routine is active.  We might have |q=hold_head|; and |p=null| if
and only if |prev_p=page_tail|. Error messages are suppressed within
|vpackage|, since the box might appear to be overfull or underfull simply
because the stretch and shrink from the \.{\\skip} registers for inserts
are not actually present in the box.

@<Break the current page at node |p|, put it...@>=
if p<>null then
  begin if vlink(contrib_head)=null then begin
    if nest_ptr=0 then tail:=page_tail
    else contrib_tail:=page_tail;
    end;
  vlink(page_tail):=vlink(contrib_head);
  vlink(contrib_head):=p;
  vlink(prev_p):=null;
  end;
save_vbadness:=vbadness; vbadness:=inf_bad;
save_vfuzz:=vfuzz; vfuzz:=max_dimen; {inhibit error messages}
pack_direction:=body_direction;
box(output_box):=filtered_vpackage(vlink(page_head),best_size,exactly,page_max_depth,output_group);
vbadness:=save_vbadness; vfuzz:=save_vfuzz;
if last_glue<>max_halfword then delete_glue_ref(last_glue);
@<Start a new current page@>; {this sets |last_glue:=max_halfword|}
if q<>hold_head then
  begin vlink(page_head):=vlink(hold_head); page_tail:=q;
  end

@ If many insertions are supposed to go into the same box, we want to know
the position of the last node in that box, so that we don't need to waste time
when linking further information into it. The |last_ins_ptr| fields of the
page insertion nodes are therefore used for this purpose during the
packaging phase.

@<Prepare all the boxes involved in insertions to act as queues@>=
begin r:=vlink(page_ins_head);
while r<>page_ins_head do
  begin if best_ins_ptr(r)<>null then
    begin n:=qo(subtype(r)); ensure_vbox(n);
    if box(n)=null then box(n):=new_null_box;
    p:=box(n)+list_offset;
    while vlink(p)<>null do p:=vlink(p);
    last_ins_ptr(r):=p;
    end;
  r:=vlink(r);
  end;
end

@ @<Delete \(t)the page-insertion nodes@>=
r:=vlink(page_ins_head);
while r<>page_ins_head do
  begin q:=vlink(r); flush_node(r); r:=q;
  end;
vlink(page_ins_head):=page_ins_head

@ We will set |best_ins_ptr:=null| and package the box corresponding to
insertion node~|r|, just after making the final insertion into that box.
If this final insertion is `|split_up_node|', the remainder after splitting
and pruning (if any) will be carried over to the next page.

@<Either insert the material specified by node |p| into...@>=
begin r:=vlink(page_ins_head);
while subtype(r)<>subtype(p) do r:=vlink(r);
if best_ins_ptr(r)=null then wait:=true
else  begin wait:=false; s:=last_ins_ptr(r); vlink(s):=ins_ptr(p);
  if best_ins_ptr(r)=p then
    @<Wrap up the box specified by node |r|, splitting node |p| if
    called for; set |wait:=true| if node |p| holds a remainder after
    splitting@>
  else  begin while vlink(s)<>null do s:=vlink(s);
    last_ins_ptr(r):=s;
    end;
  end;
@<Either append the insertion node |p| after node |q|, and remove it
  from the current page, or delete |node(p)|@>;
end

@ @<Wrap up the box specified by node |r|, splitting node |p| if...@>=
begin if type(r)=split_up_node then
  if (broken_ins(r)=p)and(broken_ptr(r)<>null) then
    begin while vlink(s)<>broken_ptr(r) do s:=vlink(s);
    vlink(s):=null;
    split_top_skip:=split_top_ptr(p);
    ins_ptr(p):=prune_page_top(broken_ptr(r),false);
    if ins_ptr(p)<>null then
      begin temp_ptr:=vpack(ins_ptr(p),0,additional);
      height(p):=height(temp_ptr)+depth(temp_ptr);
      list_ptr(temp_ptr):=null; flush_node(temp_ptr); wait:=true;
      end;
    end;
best_ins_ptr(r):=null;
n:=qo(subtype(r));
temp_ptr:=list_ptr(box(n));
list_ptr(box(n)):=null; flush_node(box(n));
pack_direction:=body_direction;
box(n):=vpack(temp_ptr,0,additional);
end

@ @<Either append the insertion node |p|...@>=
vlink(prev_p):=vlink(p); vlink(p):=null;
if wait then
  begin vlink(q):=p; q:=p; incr(insert_penalties);
  end
else  begin ins_ptr(p):=null; flush_node(p);
  end;
p:=prev_p

@ The list of heldover insertions, running from |vlink(page_head)| to
|page_tail|, must be moved to the contribution list when the user has
specified no output routine.

@<Perform the default output routine@>=
begin if vlink(page_head)<>null then
  begin if vlink(contrib_head)=null then
    if nest_ptr=0 then tail:=page_tail@+else contrib_tail:=page_tail
  else vlink(page_tail):=vlink(contrib_head);
  vlink(contrib_head):=vlink(page_head);
  vlink(page_head):=null; page_tail:=page_head;
  end;
flush_node_list(page_disc); page_disc:=null;
ship_out(box(output_box)); box(output_box):=null;
end

@ @<Explain that too many dead cycles have occurred in a row@>=
begin print_err('Output loop---'); print_int(dead_cycles);
@.Output loop...@>
print(" consecutive dead cycles");
help3('I''ve concluded that your \output is awry; it never does a',
'\shipout, so I''m shipping \box\outputbox out myself. Next time',
'increase \maxdeadcycles if you want me to be more patient!'); error;
end

@ @<Fire up the user's output routine and |return|@>=
begin output_active:=true;
incr(dead_cycles);
push_nest; mode:=-vmode; prev_depth:=pdf_ignored_dimen; mode_line:=-line;
begin_token_list(output_routine,output_text);
new_save_level(output_group); normal_paragraph;
scan_left_brace;
return;
end

@ When the user's output routine finishes, it has constructed a vlist
in internal vertical mode, and \TeX\ will do the following:

@<Resume the page builder after an output routine has come to an end@>=
begin if (iloc<>null) or
 ((token_type<>output_text)and(token_type<>backed_up)) then
  @<Recover from an unbalanced output routine@>;
end_token_list; {conserve stack space in case more outputs are triggered}
end_graf; unsave; output_active:=false; insert_penalties:=0;@/
@<Ensure that box |output_box| is empty after output@>;
if tail<>head then {current list goes after heldover insertions}
  begin vlink(page_tail):=vlink(head);
  page_tail:=tail;
  end;
if vlink(page_head)<>null then {and both go before heldover contributions}
  begin if vlink(contrib_head)=null then contrib_tail:=page_tail;
  vlink(page_tail):=vlink(contrib_head);
  vlink(contrib_head):=vlink(page_head);
  vlink(page_head):=null; page_tail:=page_head;
  end;
flush_node_list(page_disc); page_disc:=null;
pop_nest; check_filter('after_output'); build_page;
end

@ @<Recover from an unbalanced output routine@>=
begin print_err('Unbalanced output routine');
@.Unbalanced output routine@>
help2('Your sneaky output routine has problematic {''s and/or }''s.',
'I can''t handle that very well; good luck.'); error;
repeat get_token;
until iloc=null;
end {loops forever if reading from a file, since |null=min_halfword<=0|}

@ @<Ensure that box |output_box| is empty after output@>=
if box(output_box)<>null then
  begin print_err('Output routine didn''t use all of ');
  print_esc("box"); print_int(output_box);
@.Output routine didn't use...@>
  help3('Your \output commands should empty \box\outputbox,',
    'e.g., by saying `\shipout\box\outputbox''.',
    'Proceed; I''ll discard its present contents.');
  box_error(output_box);
  end

@* \[46] The chief executive.
We come now to the |main_control| routine, which contains the master
switch that causes all the various pieces of \TeX\ to do their things,
in the right order.

In a sense, this is the grand climax of the program: It applies all the
tools that we have worked so hard to construct. In another sense, this is
the messiest part of the program: It necessarily refers to other pieces
of code all over the place, so that a person can't fully understand what is
going on without paging back and forth to be reminded of conventions that
are defined elsewhere. We are now at the hub of the web, the central nervous
system that touches most of the other parts and ties them together.
@^brain@>

The structure of |main_control| itself is quite simple. There's a label
called |big_switch|, at which point the next token of input is fetched
using |get_x_token|. Then the program branches at high speed into one of
about 100 possible directions, based on the value of the current
mode and the newly fetched command code; the sum |abs(mode)+cur_cmd|
indicates what to do next. For example, the case `|vmode+letter|' arises
when a letter occurs in vertical mode (or internal vertical mode); this
case leads to instructions that initialize a new paragraph and enter
horizontal mode.

The big |case| statement that contains this multiway switch has been labeled
|reswitch|, so that the program can |goto reswitch| when the next token
has already been fetched. Most of the cases are quite short; they call
an ``action procedure'' that does the work for that case, and then they
either |goto reswitch| or they ``fall through'' to the end of the |case|
statement, which returns control back to |big_switch|. Thus, |main_control|
is not an extremely large procedure, in spite of the multiplicity of things
it must do; it is small enough to be handled by \PASCAL\ compilers that put
severe restrictions on procedure size.
@!@^action procedure@>

One case is singled out for special treatment, because it accounts for most
of \TeX's activities in typical applications. The process of reading simple
text and converting it into |char_node| records, while looking for ligatures
and kerns, is part of \TeX's ``inner loop''; the whole program runs
efficiently when its inner loop is fast, so this part has been written
with particular care.

@ We shall concentrate first on the inner loop of |main_control|, deferring
consideration of the other cases until later.
@^inner loop@>

@d big_switch=60 {go here to branch on the next token of input}

@p @t\4@>@<Declare action procedures for use by |main_control|@>@;
@t\4@>@<Declare the procedure called |handle_right_brace|@>@;
procedure main_control; {governs \TeX's activities}
label big_switch,reswitch,continue,exit;
var@!t:integer; {general-purpose temporary variable}
p:pointer; {for whatsit nodes and testing whether an auto kern should be inserted}
chr_stack:integer; { to temporarily save an |cur_chr| to be appended }
mval:mathcodeval; { to build up an argument to |set_math_char| }
begin t:=0; {for -Wall}
chr_stack:=-1;
if every_job<>null then begin_token_list(every_job,every_job_text);
big_switch: get_x_token;@/
reswitch: @<Give diagnostic information, if requested@>;
case abs(mode)+cur_cmd of
hmode+letter,hmode+other_char,hmode+char_given,hmode+char_num: begin
  if abs(mode)+cur_cmd=hmode+char_num then begin
    scan_char_num; cur_chr:=cur_val;
    end;
  if is_last_ocp(current_ocp_lstack,current_ocp_no) then begin
    @<Append character |cur_chr| and the following characters (if~any)
      to the current hlist in the current font; |goto reswitch| when
      a non-character has been fetched@>;
    end
  else begin
    @<Create a buffer with character |cur_chr| and the following
      characters (if~any) and then apply the current active OCP filter
      to this buffer@>;
    end;
  end;
hmode+no_boundary: begin @<Append a |cancel_boundary_node| @>;
  end;
hmode+char_ghost: begin t:=cur_chr; get_x_token;
  if (cur_cmd=letter)or(cur_cmd=other_char)or(cur_cmd=char_given)or
   (cur_cmd=char_num) then begin
        p:=new_glyph(cur_font,cur_chr);
    if t=0 then begin set_is_leftghost(p); end
    else begin set_is_rightghost(p); end;
    tail_append(p);
    end;
  end;
hmode+spacer,hmode+ex_space,mmode+ex_space:
if (abs(mode)+cur_cmd=hmode+spacer) and
   (not (space_factor = 1000)) then
  app_space
else begin
  @<Append a normal inter-word space to the current list@>;
  end;
@t\4@>@<Cases of |main_control| that are not part of the inner loop@>@;
end; {of the big |case| statement}
goto big_switch;
exit:end;

@ When a new token has just been fetched at |big_switch|, we have an
ideal place to monitor \TeX's activity.
@^debugging@>

@<Give diagnostic information, if requested@>=
if interrupt<>0 then if OK_to_interrupt then
  begin back_input; check_interrupt; goto big_switch;
  end;
if tracing_commands>0 then show_cur_cmd_chr

@ The following part of the program was first written in a structured
manner, according to the philosophy that ``premature optimization is
the root of all evil.'' Then it was rearranged into pieces of
spaghetti so that the most common actions could proceed with little or
no redundancy. And finally, it is replaced by a completely standalone
loop over the node list: luatex does not have a |main+loop| at all.
@^inner loop@>

@<Glob...@>=
@!main_p:pointer; {temporary register for list manipulation}
@!main_s:integer; {space factor value}

@ We leave the |space_factor| unchanged if |sf_code(cur_chr)=0|; otherwise we
set it equal to |sf_code(cur_chr)|, except that it should never change
from a value less than 1000 to a value exceeding 1000. The most common
case is |sf_code(cur_chr)=1000|, so we want that case to be fast.

@d adjust_space_factor==@t@>@;@/
  main_s:=get_sf_code(cur_chr);
  if main_s=1000 then space_factor:=1000
  else if main_s<1000 then
    begin if main_s>0 then space_factor:=main_s;
    end
  else if space_factor<1000 then space_factor:=1000
  else space_factor:=main_s

@<Append character |cur_chr|...@>=
continue: adjust_space_factor;@/
chr_stack:=cur_chr;
tail_append(new_char(cur_font,chr_stack));
get_x_token;
if (cur_cmd=letter)or(cur_cmd=other_char)or
   (cur_cmd=char_given)or(cur_cmd=char_num) then begin
  if cur_cmd=char_num then begin
    scan_char_num; cur_chr:=cur_val;
    end;
  if (chr_stack=ex_hyphen_char)and(cur_chr<>ex_hyphen_char)and(mode>0) then begin
    tail:=compound_word_break(tail,cur_lang);
    subtype(tail):=automatic_disc;
    end;
  goto continue;
  end
else begin
  if (chr_stack=ex_hyphen_char) and (mode>0) then begin
    tail:=compound_word_break(tail,cur_lang);
    subtype(tail):=automatic_disc;
    end;
  chr_stack:=-1;
  goto reswitch;
  end

@ The occurrence of blank spaces is almost part of \TeX's inner loop,
@^inner loop@>
since we usually encounter about one space for every five non-blank characters.
Therefore |main_control| gives second-highest priority to ordinary spaces.

When a glue parameter like \.{\\spaceskip} is set to `\.{0pt}', we will
see to it later that the corresponding glue specification is precisely
|zero_glue|, not merely a pointer to some specification that happens
to be full of zeroes. Therefore it is simple to test whether a glue parameter
is zero or~not.

@<Append a normal inter-word space...@>=
if space_skip=zero_glue then
  begin @<Find the glue specification, |main_p|, for
    text spaces in the current font@>;
  temp_ptr:=new_glue(main_p);
  end
else temp_ptr:=new_param_glue(space_skip_code);
vlink(tail):=temp_ptr; tail:=temp_ptr


@ From Knuth: ``Having |font_glue| allocated for each text font saves
both time and memory.''  That may be true, but it also punches through
the API wall for fonts, so I removed that -- Taco. But a bit of caching
is very welcome, which is why I need to have the next two globals:

@<Glob...@>=
space_spec_font:internal_font_number;
space_spec_cache:halfword;

@ @<Set init...@>=
space_spec_font:=0;
space_spec_cache:=zero_glue;

@ @<Find the glue specification...@>=
begin
if cur_font<>space_spec_font then begin
  if space_spec_cache<>zero_glue then
     delete_glue_ref(space_spec_cache);
  space_spec_cache:=new_spec(zero_glue);
  width(space_spec_cache):=space(cur_font);
  stretch(space_spec_cache):=space_stretch(cur_font);
  shrink(space_spec_cache):=space_shrink(cur_font);
  space_spec_font:=cur_font;
  end;
main_p:=space_spec_cache;
end

@ @<Declare act...@>=
procedure app_space; {handle spaces when |space_factor<>1000|}
var@!q:pointer; {glue node}
begin if (space_factor>=2000)and(xspace_skip<>zero_glue) then
  q:=new_param_glue(xspace_skip_code)
else begin if space_skip<>zero_glue then
    main_p:=new_spec(space_skip)
  else begin
    main_p:=new_spec(zero_glue);
    width(main_p):=space(cur_font);
    stretch(main_p):=space_stretch(cur_font);
    shrink(main_p):=space_shrink(cur_font);
  end;
  @<Modify the glue specification in |main_p| according to the space factor@>;
  q:=new_glue(main_p); glue_ref_count(main_p):=null;
  end;
vlink(tail):=q; tail:=q;
end;

@ @<Modify the glue specification in |main_p| according to the space factor@>=
if space_factor>=2000 then width(main_p):=width(main_p)+extra_space(cur_font);
stretch(main_p):=xn_over_d(stretch(main_p),space_factor,1000);
shrink(main_p):=xn_over_d(shrink(main_p),1000,space_factor)

@ Whew---that covers the main loop. We can now proceed at a leisurely
pace through the other combinations of possibilities.

@d any_mode(#)==vmode+#,hmode+#,mmode+# {for mode-independent commands}

@<Cases of |main_control| that are not part of the inner loop@>=
any_mode(relax),vmode+spacer,mmode+spacer,mmode+no_boundary:do_nothing;
any_mode(ignore_spaces): begin
  if cur_chr = 0 then begin
    @<Get the next non-blank non-call...@>;
    goto reswitch;
  end
  else begin
    t:=scanner_status;
    scanner_status:=normal;
    get_token_lua;
    scanner_status:=t;
    cur_cs  := prim_lookup(text(cur_cs));
    if cur_cs<>undefined_primitive then begin
      cur_cmd := get_prim_eq_type(cur_cs);
      cur_chr := get_prim_equiv(cur_cs);
      cur_tok := (cur_cmd*string_offset)+cur_chr;
      goto reswitch;
      end;
    end;
  end;
vmode+stop: if its_all_over then return; {this is the only way out}
@t\4@>@<Math cases in non-math modes@>;
@t\4@>@<Forbidden cases detected in |main_control|@>@+@,any_mode(mac_param):
  report_illegal_case;
@<Math-only cases in non-math modes, or vice versa@>: insert_dollar_sign;
@t\4@>@<Cases of |main_control| that build boxes and lists@>@;
@t\4@>@<Cases of |main_control| that don't depend on |mode|@>@;
@t\4@>@<Cases of |main_control| that are for extensions to \TeX@>@;

@ Here is a list of cases where the user has probably gotten into or out of math
mode by mistake. \TeX\ will insert a dollar sign and rescan the current token.

@d non_math(#)==vmode+#,hmode+#

@<Math-only cases in non-math modes...@>=
non_math(sup_mark), non_math(sub_mark),
non_math(super_sub_script), non_math(math_comp), non_math(delim_num),
non_math(left_right), non_math(above), non_math(radical),
non_math(math_style), non_math(math_choice), non_math(vcenter),
non_math(non_script), non_math(mkern), non_math(limit_switch),
non_math(mskip), non_math(math_accent),
mmode+endv, mmode+par_end, mmode+stop, mmode+vskip, mmode+un_vbox,
mmode+valign, mmode+hrule

@ @<Math cases in non-math modes@>=
vmode+math_char_num, vmode+math_given, vmode+omath_given, vmode+xmath_given: begin
    back_input; new_graf(true);
    end;
hmode+math_char_num: begin
    if cur_chr=0 then
      mval := scan_mathchar(tex_mathcode)
    else if cur_chr=1 then
      mval := scan_mathchar(aleph_mathcode)
    else if cur_chr=2 then
      mval := scan_mathchar(xetex_mathcode)
    else
      mval := scan_mathchar(xetexnum_mathcode);
    math_char_in_text(mval);
    end;
hmode+math_given: begin
    mval := mathchar_from_integer(cur_chr,tex_mathcode);
    math_char_in_text(mval);
    end;
hmode+omath_given: begin
    mval := mathchar_from_integer(cur_chr,aleph_mathcode);
    math_char_in_text(mval);
    end;
hmode+xmath_given: begin
    mval := mathchar_from_integer(cur_chr,xetex_mathcode);
    math_char_in_text(mval);
    end



@ @<Declare action...@>=
procedure insert_dollar_sign;
begin back_input; cur_tok:=math_shift_token+"$";
print_err('Missing $ inserted');
@.Missing \$ inserted@>
help2('I''ve inserted a begin-math/end-math symbol since I think',
'you left one out. Proceed, with fingers crossed.'); ins_error;
end;

@ When erroneous situations arise, \TeX\ usually issues an error message
specific to the particular error. For example, `\.{\\noalign}' should
not appear in any mode, since it is recognized by the |align_peek| routine
in all of its legitimate appearances; a special error message is given
when `\.{\\noalign}' occurs elsewhere. But sometimes the most appropriate
error message is simply that the user is not allowed to do what he or she
has attempted. For example, `\.{\\moveleft}' is allowed only in vertical mode,
and `\.{\\lower}' only in non-vertical modes.  Such cases are enumerated
here and in the other sections referred to under `See also \dots.'

@<Forbidden cases...@>=
vmode+vmove,hmode+hmove,mmode+hmove,any_mode(last_item),

@ The `|you_cant|' procedure prints a line saying that the current command
is illegal in the current mode; it identifies these things symbolically.

@<Declare action...@>=
procedure you_cant;
begin print_err('You can''t use `');
@.You can't use x in y mode@>
print_cmd_chr(cur_cmd,cur_chr);
print("' in "); print_mode(mode);
end;

@ @<Declare act...@>=
procedure report_illegal_case;
begin you_cant;
help4('Sorry, but I''m not programmed to handle this case;',
'I''ll just pretend that you didn''t ask for it.',
'If you''re in the wrong mode, you might be able to',
'return to the right one by typing `I}'' or `I$'' or `I\par''.');@/
error;
end;

@ Some operations are allowed only in privileged modes, i.e., in cases
that |mode>0|. The |privileged| function is used to detect violations
of this rule; it issues an error message and returns |false| if the
current |mode| is negative.

@<Declare act...@>=
function privileged:boolean;
begin if mode>0 then privileged:=true
else  begin report_illegal_case; privileged:=false;
  end;
end;

@ Either \.{\\dump} or \.{\\end} will cause |main_control| to enter the
endgame, since both of them have `|stop|' as their command code.

@<Put each...@>=
primitive_tex("end",stop,0,0);@/
@!@:end_}{\.{\\end} primitive@>
primitive_tex("dump",stop,1,0);@/
@!@:dump_}{\.{\\dump} primitive@>

@ We don't want to leave |main_control| immediately when a |stop| command
is sensed, because it may be necessary to invoke an \.{\\output} routine
several times before things really grind to a halt. (The output routine
might even say `\.{\\gdef\\end\{...\}}', to prolong the life of the job.)
Therefore |its_all_over| is |true| only when the current page
and contribution list are empty, and when the last output was not a
``dead cycle.''

@<Declare act...@>=
function its_all_over:boolean; {do this when \.{\\end} or \.{\\dump} occurs}
label exit;
begin if privileged then
  begin if (page_head=page_tail)and(head=tail)and(dead_cycles=0) then
    begin its_all_over:=true; return;
    end;
  back_input; {we will try to end again after ejecting residual material}
  tail_append(new_null_box);
  width(tail):=hsize;
  tail_append(new_glue(fill_glue));
  tail_append(new_penalty(-@'10000000000));@/
  check_filter('end'); build_page; {append \.{\\hbox to \\hsize\{\}\\vfill\\penalty-'10000000000}}
  end;
its_all_over:=false;
exit:end;

@* \[47] Building boxes and lists.
The most important parts of |main_control| are concerned with \TeX's
chief mission of box-making. We need to control the activities that put
entries on vlists and hlists, as well as the activities that convert
those lists into boxes. All of the necessary machinery has already been
developed; it remains for us to ``push the buttons'' at the right times.

@ As an introduction to these routines, let's consider one of the simplest
cases: What happens when `\.{\\hrule}' occurs in vertical mode, or
`\.{\\vrule}' in horizontal mode or math mode? The code in |main_control|
is short, since the |scan_rule_spec| routine already does most of what is
required; thus, there is no need for a special action procedure.

Note that baselineskip calculations are disabled after a rule in vertical
mode, by setting |prev_depth:=pdf_ignored_dimen|.

@<Cases of |main_control| that build...@>=
vmode+hrule,hmode+vrule,mmode+vrule: begin tail_append(scan_rule_spec);
  if abs(mode)=vmode then prev_depth:=pdf_ignored_dimen
  else if abs(mode)=hmode then space_factor:=1000;
  end;

@ The processing of things like \.{\\hskip} and \.{\\vskip} is slightly
more complicated. But the code in |main_control| is very short, since
it simply calls on the action routine |append_glue|. Similarly, \.{\\kern}
activates |append_kern|.

@<Cases of |main_control| that build...@>=
vmode+vskip,hmode+hskip,mmode+hskip,mmode+mskip: append_glue;
any_mode(kern),mmode+mkern: append_kern;

@ The |hskip| and |vskip| command codes are used for control sequences
like \.{\\hss} and \.{\\vfil} as well as for \.{\\hskip} and \.{\\vskip}.
The difference is in the value of |cur_chr|.

@d fil_code=0 {identifies \.{\\hfil} and \.{\\vfil}}
@d fill_code=1 {identifies \.{\\hfill} and \.{\\vfill}}
@d ss_code=2 {identifies \.{\\hss} and \.{\\vss}}
@d fil_neg_code=3 {identifies \.{\\hfilneg} and \.{\\vfilneg}}
@d skip_code=4 {identifies \.{\\hskip} and \.{\\vskip}}
@d mskip_code=5 {identifies \.{\\mskip}}

@<Put each...@>=
primitive_tex("hskip",hskip,skip_code,0);@/
@!@:hskip_}{\.{\\hskip} primitive@>
primitive_tex("hfil",hskip,fil_code,0);
@!@:hfil_}{\.{\\hfil} primitive@>
primitive_tex("hfill",hskip,fill_code,0);@/
@!@:hfill_}{\.{\\hfill} primitive@>
primitive_tex("hss",hskip,ss_code,0);
@!@:hss_}{\.{\\hss} primitive@>
primitive_tex("hfilneg",hskip,fil_neg_code,0);@/
@!@:hfil_neg_}{\.{\\hfilneg} primitive@>
primitive_tex("vskip",vskip,skip_code,0);@/
@!@:vskip_}{\.{\\vskip} primitive@>
primitive_tex("vfil",vskip,fil_code,0);
@!@:vfil_}{\.{\\vfil} primitive@>
primitive_tex("vfill",vskip,fill_code,0);@/
@!@:vfill_}{\.{\\vfill} primitive@>
primitive_tex("vss",vskip,ss_code,0);
@!@:vss_}{\.{\\vss} primitive@>
primitive_tex("vfilneg",vskip,fil_neg_code,0);@/
@!@:vfil_neg_}{\.{\\vfilneg} primitive@>
primitive_tex("mskip",mskip,mskip_code,0);@/
@!@:mskip_}{\.{\\mskip} primitive@>
primitive_tex("kern",kern,explicit,0);
@!@:kern_}{\.{\\kern} primitive@>
primitive_tex("mkern",mkern,mu_glue,0);@/
@!@:mkern_}{\.{\\mkern} primitive@>

@ All the work relating to glue creation has been relegated to the
following subroutine. It does not call |build_page|, because it is
used in at least one place where that would be a mistake.

@<Declare action...@>=
procedure append_glue;
var s:small_number; {modifier of skip command}
begin s:=cur_chr;
case s of
fil_code: cur_val:=fil_glue;
fill_code: cur_val:=fill_glue;
ss_code: cur_val:=ss_glue;
fil_neg_code: cur_val:=fil_neg_glue;
skip_code: scan_glue(glue_val_level);
mskip_code: scan_glue(mu_val_level);
end; {now |cur_val| points to the glue specification}
tail_append(new_glue(cur_val));
if s>=skip_code then
  begin decr(glue_ref_count(cur_val));
  if s>skip_code then subtype(tail):=mu_glue;
  end;
end;

@ @<Declare act...@>=
procedure append_kern;
var s:quarterword; {|subtype| of the kern node}
begin s:=cur_chr; scan_dimen(s=mu_glue,false,false);
tail_append(new_kern(cur_val)); subtype(tail):=s;
end;

@ Many of the actions related to box-making are triggered by the appearance
of braces in the input. For example, when the user says `\.{\\hbox}
\.{to} \.{100pt\{$\langle\,\hbox{hlist}\,\rangle$\}}' in vertical mode,
the information about the box size (100pt, |exactly|) is put onto |save_stack|
with a level boundary word just above it, and |cur_group:=adjusted_hbox_group|;
\TeX\ enters restricted horizontal mode to process the hlist. The right
brace eventually causes |save_stack| to be restored to its former state,
at which time the information about the box size (100pt, |exactly|) is
available once again; a box is packaged and we leave restricted horizontal
mode, appending the new box to the current list of the enclosing mode
(in this case to the current list of vertical mode), followed by any
vertical adjustments that were removed from the box by |hpack|.

The next few sections of the program are therefore concerned with the
treatment of left and right curly braces.

@ If a left brace occurs in the middle of a page or paragraph, it simply
introduces a new level of grouping, and the matching right brace will not have
such a drastic effect. Such grouping affects neither the mode nor the
current list.

@<Cases of |main_control| that build...@>=
non_math(left_brace): begin
  new_save_level(simple_group);
  eq_word_define(int_base+no_local_whatsits_code,0);
  eq_word_define(int_base+no_local_dirs_code,0);
  end;
any_mode(begin_group): begin
  new_save_level(semi_simple_group);
  eq_word_define(int_base+no_local_whatsits_code,0);
  eq_word_define(int_base+no_local_dirs_code,0);
  end;
any_mode(end_group):
  if cur_group=semi_simple_group then begin
    temp_no_whatsits:=no_local_whatsits;
    temp_no_dirs:=no_local_dirs;
    temporary_dir:=text_direction;
    if dir_level(text_dir_ptr)=cur_level then
      @<DIR: Remove from |text_dir_ptr|@>;
    unsave;
    if abs(mode)=hmode then begin
      if temp_no_dirs<>0 then begin
        @<DIR: Add local dir node@>;
        dir_dir(tail):=temporary_dir-64;
        end;
      if temp_no_whatsits<>0 then
        @<LOCAL: Add local paragraph node@>;
      end
    end
  else off_save;

@ We have to deal with errors in which braces and such things are not
properly nested. Sometimes the user makes an error of commission by
inserting an extra symbol, but sometimes the user makes an error of omission.
\TeX\ can't always tell one from the other, so it makes a guess and tries
to avoid getting into a loop.

The |off_save| routine is called when the current group code is wrong. It tries
to insert something into the user's input that will help clean off
the top level.

@<Declare act...@>=
procedure off_save;
var p,q:pointer; {inserted token}
begin if cur_group=bottom_level then
  @<Drop current token and complain that it was unmatched@>
else  begin back_input; p:=get_avail; set_token_link(temp_token_head,p);
  print_err('Missing ');
  @<Prepare to insert a token that matches |cur_group|,
    and print what it is@>;
  print(" inserted"); ins_list(link(temp_token_head));
  help5('I''ve inserted something that you may have forgotten.',
  '(See the <inserted text> above.)',
  'With luck, this will get me unwedged. But if you',
  'really didn''t forget anything, try typing `2'' now; then',
  'my insertion and my current dilemma will both disappear.');
  error;
  end;
end;

@ At this point, |link(temp_token_head)=p|, a pointer to an empty one-word node.

@<Prepare to insert a token that matches |cur_group|...@>=
case cur_group of
semi_simple_group: begin set_token_info(p,cs_token_flag+frozen_end_group);
  print_esc("endgroup");
@.Missing \\endgroup inserted@>
  end;
math_shift_group: begin set_token_info(p,math_shift_token+"$"); 
  print_char("$");
@.Missing \$ inserted@>
  end;
math_left_group: begin set_token_info(p,cs_token_flag+frozen_right); 
  q:=get_avail; set_token_link(p,q);
  p:=link(p); set_token_info(p,other_token+"."); print_esc("right.");
@.Missing \\right\hbox{.} inserted@>
@^null delimiter@>
  end;
othercases begin set_token_info(p,right_brace_token+"}"); print_char("}");
@.Missing \} inserted@>
  end
endcases

@ @<Drop current token and complain that it was unmatched@>=
begin print_err('Extra '); print_cmd_chr(cur_cmd,cur_chr);
@.Extra x@>
help1('Things are pretty mixed up, but I think the worst is over.');@/
error;
end

@ The routine for a |right_brace| character branches into many subcases,
since a variety of things may happen, depending on |cur_group|. Some
types of groups are not supposed to be ended by a right brace; error
messages are given in hopes of pinpointing the problem. Most branches
of this routine will be filled in later, when we are ready to understand
them; meanwhile, we must prepare ourselves to deal with such errors.

@<Cases of |main_control| that build...@>=
any_mode(right_brace): handle_right_brace;

@ @<Declare the procedure called |handle_right_brace|@>=
procedure handle_right_brace;
var p,@!q:pointer; {for short-term use}
@!d:scaled; {holds |split_max_depth| in |insert_group|}
@!f:integer; {holds |floating_penalty| in |insert_group|}
begin p:=null;
case cur_group of
simple_group: begin
  temp_no_whatsits:=no_local_whatsits;
  temp_no_dirs:=no_local_dirs;
  temporary_dir:=text_direction;
  if dir_level(text_dir_ptr)=cur_level then
    @<DIR: Remove from |text_dir_ptr|@>;
  unsave;
  if abs(mode)=hmode then begin
    if temp_no_dirs<>0 then begin
      @<DIR: Add local dir node@>;
      dir_dir(tail):=temporary_dir-64;
      end;
    if temp_no_whatsits<>0 then
      @<LOCAL: Add local paragraph node@>;
    end
  end;
bottom_level: begin print_err('Too many }''s');
@.Too many \}'s@>
  help2('You''ve closed more groups than you opened.',
  'Such booboos are generally harmless, so keep going.'); error;
  end;
semi_simple_group,math_shift_group,math_left_group: extra_right_brace;
@t\4@>@<Cases of |handle_right_brace| where a |right_brace| triggers
  a delayed action@>@;
othercases confusion('rightbrace')
@:this can't happen rightbrace}{\quad rightbrace@>
endcases;
end;

@ @<Declare act...@>=
procedure extra_right_brace;
begin print_err('Extra }, or forgotten ');
@.Extra \}, or forgotten x@>
case cur_group of
semi_simple_group: print_esc("endgroup");
math_shift_group: print_char("$");
math_left_group: print_esc("right");
end;@/
help5('I''ve deleted a group-closing symbol because it seems to be',
'spurious, as in `$x}$''. But perhaps the } is legitimate and',
'you forgot something else, as in `\hbox{$x}''. In such cases',
'the way to recover is to insert both the forgotten and the',
'deleted material, e.g., by typing `I$}''.'); error;
incr(align_state);
end;

@ Here is where we clear the parameters that are supposed to revert to their
default values after every paragraph and when internal vertical mode is entered.

@<Declare act...@>=
procedure normal_paragraph;
begin if looseness<>0 then eq_word_define(int_base+looseness_code,0);
if hang_indent<>0 then eq_word_define(dimen_base+hang_indent_code,0);
if hang_after<>1 then eq_word_define(int_base+hang_after_code,1);
if par_shape_ptr<>null then eq_define(par_shape_loc,shape_ref,null);
if inter_line_penalties_ptr<>null then
  eq_define(inter_line_penalties_loc,shape_ref,null);
end;

@ @<Put each...@>=
primitive_tex("moveleft",hmove,1,0);
@!@:move_left_}{\.{\\moveleft} primitive@>
primitive_tex("moveright",hmove,0,0);@/
@!@:move_right_}{\.{\\moveright} primitive@>
primitive_tex("raise",vmove,1,0);
@!@:raise_}{\.{\\raise} primitive@>
primitive_tex("lower",vmove,0,0);
@!@:lower_}{\.{\\lower} primitive@>
@#
primitive_tex("box",make_box,box_code,0);
@!@:box_}{\.{\\box} primitive@>
primitive_tex("copy",make_box,copy_code,0);
@!@:copy_}{\.{\\copy} primitive@>
primitive_tex("lastbox",make_box,last_box_code,0);
@!@:last_box_}{\.{\\lastbox} primitive@>
primitive_tex("vsplit",make_box,vsplit_code,0);
@!@:vsplit_}{\.{\\vsplit} primitive@>
primitive_tex("vtop",make_box,vtop_code,0);@/
@!@:vtop_}{\.{\\vtop} primitive@>
primitive_tex("vbox",make_box,vtop_code+vmode,0);
@!@:vbox_}{\.{\\vbox} primitive@>
primitive_tex("hbox",make_box,vtop_code+hmode,0);@/
@!@:hbox_}{\.{\\hbox} primitive@>
primitive_tex("shipout",leader_ship,a_leaders-1,0); {|ship_out_flag=leader_flag-1|}
@!@:ship_out_}{\.{\\shipout} primitive@>
primitive_tex("leaders",leader_ship,a_leaders,0);
@!@:leaders_}{\.{\\leaders} primitive@>
primitive_tex("cleaders",leader_ship,c_leaders,0);
@!@:c_leaders_}{\.{\\cleaders} primitive@>
primitive_tex("xleaders",leader_ship,x_leaders,0);
@!@:x_leaders_}{\.{\\xleaders} primitive@>;
primitive_aleph("boxdir",assign_box_dir,0,0);
@!@:box_dir}{\.{\\boxdir} primitive@>

@ Constructions that require a box are started by calling |scan_box| with
a specified context code. The |scan_box| routine verifies
that a |make_box| command comes next and then it calls |begin_box|.

@<Cases of |main_control| that build...@>=
vmode+hmove,hmode+vmove,mmode+vmove: begin t:=cur_chr;
  scan_normal_dimen;
  if t=0 then scan_box(cur_val)@+else scan_box(-cur_val);
  end;
any_mode(leader_ship): scan_box(leader_flag-a_leaders+cur_chr);
any_mode(make_box): begin_box(0);
any_mode(assign_box_dir): begin scan_register_num;
  cur_box:=box(cur_val);
  scan_optional_equals; scan_direction;
  if cur_box<>null then box_dir(cur_box):=cur_val;
  end;

@ The global variable |cur_box| will point to a newly-made box. If the box
is void, we will have |cur_box=null|. Otherwise we will have
|type(cur_box)=hlist_node| or |vlist_node| or |rule_node|; the |rule_node|
case can occur only with leaders.

@<Glob...@>=
@!cur_box:pointer; {box to be placed into its context}

@ The |box_end| procedure does the right thing with |cur_box|, if
|box_context| represents the context as explained above.

@<Declare act...@>=
procedure box_end(@!box_context:integer);
begin if box_context<box_flag then @<Append box |cur_box| to the current list,
    shifted by |box_context|@>
else if box_context<ship_out_flag then @<Store \(c)|cur_box| in a box register@>
else if cur_box<>null then begin
  if box_context>ship_out_flag then @<Append a new leader node that
      uses |cur_box|@>
  else ship_out(cur_box);
  end;
end;

@ The global variable |adjust_tail| will be non-null if and only if the
current box might include adjustments that should be appended to the
current vertical list.

@<Append box |cur_box| to the current...@>=
begin if cur_box<>null then
  begin shift_amount(cur_box):=box_context;
  if abs(mode)=vmode then
    begin
        if pre_adjust_tail <> null then begin
            if pre_adjust_head <> pre_adjust_tail then
                append_list(pre_adjust_head)(pre_adjust_tail);
            pre_adjust_tail := null;
        end;
        append_to_vlist(cur_box);
        if adjust_tail <> null then begin
            if adjust_head <> adjust_tail then
                append_list(adjust_head)(adjust_tail);
            adjust_tail := null;
        end;
    if mode>0 then begin check_filter('box'); build_page; end;
    end
  else  begin if abs(mode)=hmode then space_factor:=1000
    else cur_box:=new_sub_box(cur_box);
    vlink(tail):=cur_box; tail:=cur_box;
    end;
  end;
end

@ @<Store \(c)|cur_box| in a box register@>=
if box_context<global_box_flag then
  eq_define(box_base+box_context-box_flag,box_ref,cur_box)
else geq_define(box_base+box_context-global_box_flag,box_ref,cur_box)

@ @<Append a new leader node ...@>=
begin @<Get the next non-blank non-relax...@>;
if ((cur_cmd=hskip)and(abs(mode)<>vmode))or@|
   ((cur_cmd=vskip)and(abs(mode)=vmode)) then
  begin append_glue; subtype(tail):=box_context-(leader_flag-a_leaders);
  leader_ptr(tail):=cur_box;
  end
else  begin print_err('Leaders not followed by proper glue');
@.Leaders not followed by...@>
  help3('You should say `\leaders <box or rule><hskip or vskip>''.',
  'I found the <box or rule>, but there''s no suitable',
  '<hskip or vskip>, so I''m ignoring these leaders.'); back_error;
  flush_node_list(cur_box);
  end;
end

@ @<Declare act...@>=
procedure scan_box(@!box_context:integer);
  {the next input should specify a box or perhaps a rule}
begin @<Get the next non-blank non-relax...@>;
if cur_cmd=make_box then begin_box(box_context)
else if (box_context>=leader_flag)and((cur_cmd=hrule)or(cur_cmd=vrule)) then
  begin cur_box:=scan_rule_spec; box_end(box_context);
  end
else  begin@t@>@;@/
  print_err('A <box> was supposed to be here');@/
@.A <box> was supposed to...@>
  help3('I was expecting to see \hbox or \vbox or \copy or \box or',
  'something like that. So you might find something missing in',
  'your output. But keep trying; you can fix this later.'); back_error;
  end;
end;

@ When the right brace occurs at the end of an \.{\\hbox} or \.{\\vbox} or
\.{\\vtop} construction, the |package| routine comes into action. We might
also have to finish a paragraph that hasn't ended.

@<Cases of |handle...@>=
hbox_group: package(0);
adjusted_hbox_group: begin adjust_tail:=adjust_head;
    pre_adjust_tail:=pre_adjust_head; package(0);
  end;
vbox_group: begin line_break_context:=vbox_group; end_graf; package(0);
  end;
vtop_group: begin line_break_context:=vtop_group; end_graf; package(vtop_code);
  end;

@ @<Declare action...@>=
procedure package(@!c:small_number);
var h:scaled; {height of box}
@!p:pointer; {first node in a box}
@!d:scaled; {max depth}
@!grp:integer;
begin grp:=cur_group;
d:=box_max_depth; unsave; save_ptr:=save_ptr-6;
pack_direction:=saved(3);
if mode=-hmode then cur_box:=filtered_hpack(head,tail,saved(2),saved(1),grp)
else  begin cur_box:=filtered_vpackage(vlink(head),saved(2),saved(1),d,grp);
  if c=vtop_code then @<Readjust the height and depth of |cur_box|,
    for \.{\\vtop}@>;
  end;
if saved(4)<>null then
  @<DIR: Adjust back |text_dir_ptr| for |scan_spec|@>;
replace_attribute_list(cur_box, saved(5));
pop_nest; box_end(saved(0));
end;

@ The height of a `\.{\\vtop}' box is inherited from the first item on its list,
if that item is an |hlist_node|, |vlist_node|, or |rule_node|; otherwise
the \.{\\vtop} height is zero.


@<Readjust the height...@>=
begin h:=0; p:=list_ptr(cur_box);
if p<>null then if type(p)<=rule_node then h:=height(p);
depth(cur_box):=depth(cur_box)-h+height(cur_box); height(cur_box):=h;
end

@ Here is a really small patch to add a new primitive called
\.{\\quitvmode}. In vertical modes, it is identical to \.{\\indent},
but in horizontal and math modes it is really a no-op (as opposed to
\.{\\indent}, which executes the |indent_in_hmode| procedure).

A paragraph begins when horizontal-mode material occurs in vertical mode,
or when the paragraph is explicitly started by `\.{\\quitvmode}',
`\.{\\indent}' or `\.{\\noindent}'.

@<Put each...@>=
primitive_tex("indent",start_par,1,0);
@!@:indent_}{\.{\\indent} primitive@>
primitive_tex("noindent",start_par,0,0);
@!@:no_indent_}{\.{\\noindent} primitive@>
primitive_pdftex("quitvmode",start_par,2,0);
@!@:quit_vmode_}{\.{\\quitvmode} primitive@>

@ @<Cases of |main_control| that build...@>=
vmode+start_par: new_graf(cur_chr>0);
vmode+letter,vmode+other_char,vmode+char_num,vmode+char_given,
   vmode+char_ghost,
   vmode+math_shift,vmode+math_shift_cs,vmode+un_hbox,vmode+vrule,
   vmode+accent,vmode+discretionary,vmode+hskip,vmode+valign,
   vmode+ex_space,vmode+no_boundary:@t@>@;@/
  begin back_input; new_graf(true);
  end;

@ @<Declare act...@>=
procedure new_graf(@!indented:boolean);
var p,q,dir_graf_tmp:pointer;
begin prev_graf:=0;
if (mode=vmode)or(head<>tail) then begin
  tail_append(new_param_glue(par_skip_code));
  end;
push_nest; mode:=hmode; space_factor:=1000;
@<LOCAL: Add local paragraph node@>;
if indented then begin
  p:=new_null_box; box_dir(p):=par_direction;
  width(p):=par_indent;@+
  tail_append(p);
  end;
q:=tail;
dir_rover:=text_dir_ptr;
while dir_rover<>null do
  begin
  if (vlink(dir_rover)<>null) or (dir_dir(dir_rover)<>par_direction) then
    begin
    dir_graf_tmp:=new_dir(dir_dir(dir_rover));
    vlink(dir_graf_tmp):=vlink(q); vlink(q):=dir_graf_tmp;
    end;
  dir_rover:=vlink(dir_rover);
  end;
q:=head;
while vlink(q)<>null do q:=vlink(q);
tail:=q;
if every_par<>null then begin_token_list(every_par,every_par_text);
if nest_ptr=1 then begin
  check_filter('new_graf'); build_page; {put |par_skip| glue on current page}
  end;
end;

@ @<Cases of |main_control| that build...@>=
hmode+start_par,mmode+start_par: if cur_chr<>2 then indent_in_hmode;

@ @<Declare act...@>=
procedure indent_in_hmode;
var p:pointer;
begin if cur_chr>0 then {\.{\\indent}}
  begin p:=new_null_box; width(p):=par_indent;
  if abs(mode)=hmode then space_factor:=1000
  else  p:=new_sub_box(p);
  tail_append(p);
  end;
end;

@ A paragraph ends when a |par_end| command is sensed, or when we are in
horizontal mode when reaching the right brace of vertical-mode routines
like \.{\\vbox}, \.{\\insert}, or \.{\\output}.

@<Cases of |main_control| that build...@>=
vmode+par_end: begin normal_paragraph;
  if mode>0 then begin check_filter('vmode_par'); build_page; end;
  end;
hmode+par_end: begin if align_state<0 then off_save; {this tries to
    recover from an alignment that didn't end properly}
  if (mode>0) and (nest[(nest_ptr-1)].mode_field=vmode) then
          line_break_context:=bottom_level;
  end_graf; {this takes us to the enclosing mode, if |mode>0|}
  if mode=vmode then begin check_filter('hmode_par');  build_page; end;
  end;
hmode+stop,hmode+vskip,hmode+hrule,hmode+un_vbox,hmode+halign: head_for_vmode;

@ @<Declare act...@>=
procedure head_for_vmode;
begin if mode<0 then
  if cur_cmd<>hrule then off_save
  else  begin print_err('You can''t use `');
    print_esc("hrule"); print("' here except with leaders");
@.You can't use \\hrule...@>
    help2('To put a horizontal rule in an hbox or an alignment,',
      'you should use \leaders or \hrulefill (see The TeXbook).');
    error;
    end
else  begin back_input; cur_tok:=par_token; back_input; token_type:=inserted;
  end;
end;

@ TODO (BUG?): |dir_save| would have been set by |line_break| by means
of |post_line_break|, but this is not done right now, as it introduces
pretty heavy memory leaks. This means the current code is probably
wrong in some way that relates to in-paragraph displays.

@<Declare act...@>=
procedure end_graf;
begin if mode=hmode then
  begin if (head=tail) or (vlink(head)=tail) then pop_nest
        {null paragraphs are ignored, all contain a |local_paragraph| node}
  else line_break(false);
  if dir_save<>null then
    begin flush_node_list(dir_save); dir_save:=null;
    end;
  normal_paragraph;
  error_count:=0;
  end;
end;

@ Insertion and adjustment and mark nodes are constructed by the following
pieces of the program.

@<Cases of |main_control| that build...@>=
any_mode(insert),hmode+vadjust,mmode+vadjust: begin_insert_or_adjust;
any_mode(mark): handle_mark;

@ @<Forbidden...@>=
vmode+vadjust,

@ @<Declare act...@>=
procedure begin_insert_or_adjust;
begin if cur_cmd=vadjust then cur_val:=output_box
else  begin scan_register_num;
  if cur_val=output_box then
    begin print_err('You can''t '); print_esc("insert"); print_int(output_box);
@.You can't \\insert\\outputbox@>
    help1('I''m changing to \insert0; box \outputbox is special.');
    error; cur_val:=0;
    end;
  end;
saved(0) := cur_val;
if (cur_cmd = vadjust) and scan_keyword('pre') then
    saved(1) := 1
else
    saved(1) := 0;
save_ptr := save_ptr + 2;
new_save_level(insert_group); scan_left_brace; normal_paragraph;
push_nest; mode:=-vmode; prev_depth:=pdf_ignored_dimen;
end;

@ @<Cases of |handle...@>=
insert_group: begin
  line_break_context:=insert_group;
  end_graf; q:=split_top_skip; add_glue_ref(q);
  d:=split_max_depth; f:=floating_penalty; unsave; save_ptr := save_ptr - 2;
  {now |saved(0)| is the insertion number, or |output_box| for |vadjust|}
  p:=vpack(vlink(head),0,additional); pop_nest;
  if saved(0)<>output_box then
    begin tail_append(new_node(ins_node,saved(0)));
    height(tail):=height(p)+depth(p); ins_ptr(tail):=list_ptr(p);
    split_top_ptr(tail):=q; depth(tail):=d; float_cost(tail):=f;
    end
  else  begin tail_append(new_node(adjust_node,saved(1))); {the |subtype| is used for |adjust_pre|}
    adjust_ptr(tail):=list_ptr(p); delete_glue_ref(q);
    end;
  list_ptr(p):=null; flush_node(p);
  if nest_ptr=0 then begin check_filter('insert'); build_page; end;
  end;
output_group: @<Resume the page builder...@>;

@ I've renamed the |make_mark| procedure to this, because if the
current chr code is 1, then the actual command was \.{\\clearmarks},
which does not generate a mark node but instead destroys the current
mark tokenlists.

@<Declare act...@>=
procedure handle_mark;
var p:pointer; {new node}
@!c:halfword; {the mark class}
begin if cur_chr=clear_marks_code then begin
    scan_mark_num; c:=cur_val;
    delete_top_mark(c); delete_bot_mark(c); delete_first_mark(c);
    delete_split_first_mark(c); delete_split_bot_mark(c);
  end
else begin
if cur_chr=0 then c:=0
else begin scan_mark_num; c:=cur_val;
  if c > biggest_used_mark then biggest_used_mark := c;
  end;
p:=scan_toks(false,true);
p:=new_node(mark_node,0); {the |subtype| is not used}
mark_class(p):=c;
mark_ptr(p):=def_ref; vlink(tail):=p; tail:=p;
end;
end;

@ Penalty nodes get into a list via the |break_penalty| command.
@^penalties@>

@<Cases of |main_control| that build...@>=
any_mode(break_penalty): append_penalty;

@ @<Declare action...@>=
procedure append_penalty;
begin scan_int; tail_append(new_penalty(cur_val));
if mode=vmode then begin check_filter('penalty'); build_page; end;
end;

@ The |remove_item| command removes a penalty, kern, or glue node if it
appears at the tail of the current list, using a brute-force linear scan.
Like \.{\\lastbox}, this command is not allowed in vertical mode (except
internal vertical mode), since the current list in vertical mode is sent
to the page builder.  But if we happen to be able to implement it in
vertical mode, we do.

@<Cases of |main_control| that build...@>=
any_mode(remove_item): delete_last;

@ When |delete_last| is called, |cur_chr| is the |type| of node that
will be deleted, if present.

@<Declare action...@>=
procedure delete_last;
label exit;
var @!p,@!q:pointer; {run through the current list}
begin if (mode=vmode)and(tail=head) then
  @<Apologize for inability to do the operation now,
    unless \.{\\unskip} follows non-glue@>
else  begin if not is_char_node(tail) then if type(tail)=cur_chr then
    begin q:=head;
    repeat p:=q;
    if not is_char_node(q) then if type(q)=disc_node then
      begin
      if p=tail then return;
      end;
    q:=vlink(p);
    until q=tail;
    vlink(p):=null; flush_node_list(tail); tail:=p;
    end;
  end;
exit:end;

@ @<Apologize for inability to do the operation...@>=
begin if (cur_chr<>glue_node)or(last_glue<>max_halfword) then
  begin you_cant;
  if cur_chr=kern_node then
    help2('Sorry...I usually can''t take things from the current page.',
     'Try `I\kern-\lastkern'' instead.')
  else if cur_chr<>glue_node then
    help2('Sorry...I usually can''t take things from the current page.',
     'Perhaps you can make the output routine do it.')
  else
    help2('Sorry...I usually can''t take things from the current page.',
      'Try `I\vskip-\lastskip'' instead.');
  error;
  end;
end

@ @<Put each...@>=
primitive_tex("unpenalty",remove_item,penalty_node,0);@/
@!@:un_penalty_}{\.{\\unpenalty} primitive@>
primitive_tex("unkern",remove_item,kern_node,0);@/
@!@:un_kern_}{\.{\\unkern} primitive@>
primitive_tex("unskip",remove_item,glue_node,0);@/
@!@:un_skip_}{\.{\\unskip} primitive@>
primitive_tex("unhbox",un_hbox,box_code,0);@/
@!@:un_hbox_}{\.{\\unhbox} primitive@>
primitive_tex("unhcopy",un_hbox,copy_code,0);@/
@!@:un_hcopy_}{\.{\\unhcopy} primitive@>
primitive_tex("unvbox",un_vbox,box_code,0);@/
@!@:un_vbox_}{\.{\\unvbox} primitive@>
primitive_tex("unvcopy",un_vbox,copy_code,0);@/
@!@:un_vcopy_}{\.{\\unvcopy} primitive@>

@ The |un_hbox| and |un_vbox| commands unwrap one of the |number_regs| current boxes.

@<Cases of |main_control| that build...@>=
vmode+un_vbox,hmode+un_hbox,mmode+un_hbox: unpackage;

@ @<Declare act...@>=
procedure unpackage;
label done, exit;
var p:pointer; {the box}
    r: pointer; {to remove marginal kern nodes}
@!c:box_code..copy_code; {should we copy?}
@!s:pointer; {for varmem assignment }
begin if cur_chr>copy_code then @<Handle saved items and |goto done|@>;
c:=cur_chr; scan_register_num; p:=box(cur_val);
if p=null then return;
if (abs(mode)=mmode)or((abs(mode)=vmode)and(type(p)<>vlist_node))or@|
   ((abs(mode)=hmode)and(type(p)<>hlist_node)) then
  begin print_err('Incompatible list can''t be unboxed');
@.Incompatible list...@>
  help3('Sorry, Pandora. (You sneaky devil.)',
  'I refuse to unbox an \hbox in vertical mode or vice versa.',
  'And I can''t open any boxes in math mode.');@/
  error; return;
  end;
if c=copy_code then begin s:=copy_node_list(list_ptr(p)); vlink(tail):=s; end
else  begin vlink(tail):=list_ptr(p); box(cur_val):=null;
  list_ptr(p):=null; flush_node(p);
  end;
done:
while vlink(tail) <> null do begin
    r := vlink(tail);
    if not is_char_node(r) and (type(r) = margin_kern_node) then begin
        vlink(tail) := vlink(r);
        flush_node(r);
    end;
    tail:=vlink(tail);
end;
exit:end;

@ @<Forbidden...@>=vmode+ital_corr,

@ Italic corrections are converted to kern nodes when the |ital_corr| command
follows a character. In math mode the same effect is achieved by appending
a kern of zero here, since italic corrections are supplied later.

@<Cases of |main_control| that build...@>=
hmode+ital_corr: append_italic_correction;
mmode+ital_corr: tail_append(new_kern(0));

@ @<Declare act...@>=
procedure append_italic_correction;
label exit;
var p:pointer; {|char_node| at the tail of the current list}
@!f:internal_font_number; {the font in the |char_node|}
begin if tail<>head then
  begin if is_char_node(tail) then p:=tail
  else return;
  f:=font(p);
  tail_append(new_kern(char_italic(f,character(p))));
  subtype(tail):=explicit;
  end;
exit:end;

@ Discretionary nodes are easy in the common case `\.{\\-}', but in the
general case we must process three braces full of items.

There are four subtypes of discretionaries, but only the first two are
generated by primitive commands.

@d discretionary_disc=0
@d explicit_disc=1

@<Put each...@>=
primitive_tex("-",discretionary,explicit_disc,0);
@!@:Single-character primitives -}{\quad\.{\\-}@>
primitive_tex("discretionary",discretionary,discretionary_disc,0);
@!@:discretionary_}{\.{\\discretionary} primitive@>
primitive_omega("localleftbox",assign_local_box,0,0);
@!@:assign_local_box}{\.{\\localleftbox} primitive@>
primitive_omega("localrightbox",assign_local_box,1,0);
@!@:assign_local_box}{\.{\\localrightbox} primitive@>

@ @<Cases of |main_control| that build...@>=
hmode+discretionary,mmode+discretionary: append_discretionary;
any_mode(assign_local_box): append_local_box(cur_chr);

@ The space factor does not change when we append a discretionary node,
but it starts out as 1000 in the subsidiary lists.

@<Declare act...@>=
procedure append_local_box(kind:integer);
begin
incr(save_ptr); saved(-1):=kind; new_save_level(local_box_group);
scan_left_brace; push_nest; mode:=-hmode; space_factor:=1000;
end;

procedure append_discretionary;
var c:integer;
begin tail_append(new_disc);
subtype(tail):=cur_chr;
if cur_chr=explicit_disc then begin
    c:=get_pre_hyphen_char(cur_lang);
    if c<>0 then begin
          vlink(pre_break(tail)):=new_char(cur_font,c);
      alink(vlink(pre_break(tail))):=pre_break(tail);
          tlink(pre_break(tail)):=vlink(pre_break(tail));
      end;
    c:=get_post_hyphen_char(cur_lang);
    if c<>0 then begin
       vlink(post_break(tail)):=new_char(cur_font,c);
       alink(vlink(post_break(tail))):=post_break(tail);
       tlink(post_break(tail)):=vlink(post_break(tail));
       end;
    end
else  begin incr(save_ptr); saved(-1):=0; new_save_level(disc_group);
  scan_left_brace; push_nest; mode:=-hmode; space_factor:=1000;
  end;
end;

@ The three discretionary lists are constructed somewhat as if they were
hboxes. A~subroutine called |build_discretionary| handles the transitions.
(This is sort of fun.)

@<Cases of |handle...@>=
disc_group: build_discretionary;
local_box_group: build_local_box;

@ @<Declare act...@>=
procedure build_local_box;
var p:pointer;
    kind:integer;
begin
unsave;
kind:=saved(-1);
decr(save_ptr);
p:=vlink(head); pop_nest;
if p<>null then
  p:=hpack(p,0,additional);
if kind=0 then
    eq_define(local_left_box_base,box_ref,p)
else
  eq_define(local_right_box_base,box_ref,p);
if abs(mode)=hmode then
  @<LOCAL: Add local paragraph node@>;
eq_word_define(int_base+no_local_whatsits_code,no_local_whatsits+1);
end;

procedure build_discretionary;
label done,exit;
var p,@!q:pointer; {for link manipulation}
@!n:integer; {length of discretionary list}
begin unsave;
@<Prune the current list, if necessary, until it contains only
  |char_node|, |kern_node|, |hlist_node|, |vlist_node| and
  |rule_node| items; set |n| to the length of the list,
  and set |q| to the list's tail@>;
p:=vlink(head); pop_nest;
case saved(-1) of
0: if (n>0) then begin
   vlink(pre_break(tail)):=p;
   alink(p):=pre_break(tail);
   tlink(pre_break(tail)):=q;
   end;
1: if (n>0) then begin
   vlink(post_break(tail)):=p;
   alink(p):=post_break(tail);
   tlink(post_break(tail)):=q;
   end;
2:@<Attach list |p| to the current list, and record its length;
  then finish up and |return|@>;
end; {there are no other cases}
incr(saved(-1)); new_save_level(disc_group); scan_left_brace;
push_nest; mode:=-hmode; space_factor:=1000;
exit:end;

@ @<Attach list |p| to the current...@>=
begin if (n>0)and(abs(mode)=mmode) then
  begin print_err('Illegal math '); print_esc("discretionary");
@.Illegal math \\disc...@>
  help2('Sorry: The third part of a discretionary break must be',
  'empty, in math formulas. I had to delete your third part.');
  flush_node_list(p); error;
  end
else begin
  if (n>0) then begin
    vlink(no_break(tail)):=p;
    alink(p):=no_break(tail);
    tlink(no_break(tail)):=q;
    end;
  end;
decr(save_ptr); return;
end

@ During this loop, |p=vlink(q)| and there are |n| items preceding |p|.

@<Prune the current list, if necessary...@>=
q:=head; p:=vlink(q); n:=0;
while p<>null do
  begin if not is_char_node(p) then
    if type(p)>rule_node then if type(p)<>kern_node then
      begin print_err('Improper discretionary list');
@.Improper discretionary list@>
      help1('Discretionary lists must contain only boxes and kerns.');@/
      error;
      begin_diagnostic;
      print_nl("The following discretionary sublist has been deleted:");
@.The following...deleted@>
      show_box(p);
      end_diagnostic(true);
      flush_node_list(p); vlink(q):=null; goto done;
      end;
  alink(p):=q; q:=p; p:=vlink(q); incr(n);
  end;
done:

@ We need only one more thing to complete the horizontal mode routines, namely
the \.{\\accent} primitive.

@<Cases of |main_control| that build...@>=
hmode+accent: make_accent;

@ The positioning of accents is straightforward but tedious. Given an accent
of width |a|, designed for characters of height |x| and slant |s|;
and given a character of width |w|, height |h|, and slant |t|: We will shift
the accent down by |x-h|, and we will insert kern nodes that have the effect of
centering the accent over the character and shifting the accent to the
right by $\delta={1\over2}(w-a)+h\cdot t-x\cdot s$.  If either character is
absent from the font, we will simply use the other, without shifting.

@<Declare act...@>=
procedure make_accent;
var s,@!t: real; {amount of slant}
@!p,@!q,@!r:pointer; {character, box, and kern nodes}
@!f:internal_font_number; {relevant font}
@!a,@!h,@!x,@!w,@!delta:scaled; {heights and widths, as explained above}
begin scan_char_num; f:=cur_font; p:=new_glyph(f,cur_val);
if p<>null then
  begin x:=x_height(f); s:=slant(f)/float_constant(65536);
@^real division@>
  a:=glyph_width(p);@/
  do_assignments;@/
  @<Create a character node |q| for the next character,
    but set |q:=null| if problems arise@>;
  if q<>null then @<Append the accent with appropriate kerns,
      then set |p:=q|@>;
  vlink(tail):=p; tail:=p; space_factor:=1000;
  end;
end;

@ @<Create a character node |q| for the next...@>=
q:=null; f:=cur_font;
if (cur_cmd=letter)or(cur_cmd=other_char)or(cur_cmd=char_given) then
  q:=new_glyph(f,cur_chr)
else if cur_cmd=char_num then
  begin scan_char_num; q:=new_glyph(f,cur_val);
  end
else back_input

@ The kern nodes appended here must be distinguished from other kerns, lest
they be wiped away by the hyphenation algorithm or by a previous line break.

The two kerns are computed with (machine-dependent) |real| arithmetic, but
their sum is machine-independent; the net effect is machine-independent,
because the user cannot remove these nodes nor access them via \.{\\lastkern}.

@<Append the accent with appropriate kerns...@>=
begin t:=slant(f)/float_constant(65536);
@^real division@>
w:=glyph_width(q);
h:=glyph_height(q);
if h<>x then {the accent must be shifted up or down}
  begin p:=hpack(p,0,additional); shift_amount(p):=x-h;
  end;
delta:=round((w-a)/float_constant(2)+h*t-x*s);
@^real multiplication@>
@^real addition@>
r:=new_kern(delta); subtype(r):=acc_kern; vlink(tail):=r; vlink(r):=p;
tail:=new_kern(-a-delta); subtype(tail):=acc_kern; vlink(p):=tail; p:=q;
end

@ When `\.{\\cr}' or `\.{\\span}' or a tab mark comes through the scanner
into |main_control|, it might be that the user has foolishly inserted
one of them into something that has nothing to do with alignment. But it is
far more likely that a left brace or right brace has been omitted, since
|get_next| takes actions appropriate to alignment only when `\.{\\cr}'
or `\.{\\span}' or tab marks occur with |align_state=0|. The following
program attempts to make an appropriate recovery.

@<Cases of |main_control| that build...@>=
any_mode(car_ret), any_mode(tab_mark): align_error;
any_mode(no_align): no_align_error;
any_mode(omit): omit_error;

@ @<Declare act...@>=
procedure align_error;
begin if abs(align_state)>2 then
  @<Express consternation over the fact that no alignment is in progress@>
else  begin back_input;
  if align_state<0 then
    begin print_err('Missing { inserted');
@.Missing \{ inserted@>
    incr(align_state); cur_tok:=left_brace_token+"{";
    end
  else  begin print_err('Missing } inserted');
@.Missing \} inserted@>
    decr(align_state); cur_tok:=right_brace_token+"}";
    end;
  help3('I''ve put in what seems to be necessary to fix',
    'the current column of the current alignment.',
    'Try to go on, since this might almost work.'); ins_error;
  end;
end;

@ @<Express consternation...@>=
begin print_err('Misplaced '); print_cmd_chr(cur_cmd,cur_chr);
@.Misplaced \&@>
@.Misplaced \\span@>
@.Misplaced \\cr@>
if cur_tok=tab_token+"&" then
  begin help6('I can''t figure out why you would want to use a tab mark',
  'here. If you just want an ampersand, the remedy is',
  'simple: Just type `I\&'' now. But if some right brace',
  'up above has ended a previous alignment prematurely,',
  'you''re probably due for more error messages, and you',
  'might try typing `S'' now just to see what is salvageable.');
  end
else  begin help5('I can''t figure out why you would want to use a tab mark',
  'or \cr or \span just now. If something like a right brace',
  'up above has ended a previous alignment prematurely,',
  'you''re probably due for more error messages, and you',
  'might try typing `S'' now just to see what is salvageable.');
  end;
error;
end

@ The help messages here contain a little white lie, since \.{\\noalign}
and \.{\\omit} are allowed also after `\.{\\noalign\{...\}}'.

@<Declare act...@>=
procedure no_align_error;
begin print_err('Misplaced '); print_esc("noalign");
@.Misplaced \\noalign@>
help2('I expect to see \noalign only after the \cr of',
  'an alignment. Proceed, and I''ll ignore this case.'); error;
end;
procedure omit_error;
begin print_err('Misplaced '); print_esc("omit");
@.Misplaced \\omit@>
help2('I expect to see \omit only after tab marks or the \cr of',
  'an alignment. Proceed, and I''ll ignore this case.'); error;
end;

@ We've now covered most of the abuses of \.{\\halign} and \.{\\valign}.
Let's take a look at what happens when they are used correctly.

@<Cases of |main_control| that build...@>=
vmode+halign,hmode+valign:init_align;
mmode+halign: if privileged then begin
  if cur_group=math_shift_group then init_align
  else off_save;
  end;
vmode+endv,hmode+endv: do_endv;

@ An |align_group| code is supposed to remain on the |save_stack|
during an entire alignment, until |fin_align| removes it.

A devious user might force an |endv| command to occur just about anywhere;
we must defeat such hacks.

@<Declare act...@>=
procedure do_endv;
begin base_ptr:=input_ptr; input_stack[base_ptr]:=cur_input;
while (input_stack[base_ptr].index_field<>v_template) and
      (input_stack[base_ptr].loc_field=null) and
      (input_stack[base_ptr].state_field=token_list) do decr(base_ptr);
if (input_stack[base_ptr].index_field<>v_template) or
      (input_stack[base_ptr].loc_field<>null) or
      (input_stack[base_ptr].state_field<>token_list) then
  fatal_error('(interwoven alignment preambles are not allowed)');
@.interwoven alignment preambles...@>
 if cur_group=align_group then
  begin line_break_context:=align_group; end_graf;
  if fin_col then fin_row;
  end
else off_save;
end;

@ @<Cases of |handle_right_brace|...@>=
align_group: begin back_input; cur_tok:=cs_token_flag+frozen_cr;
  print_err('Missing '); print_esc("cr"); print(" inserted");
@.Missing \\cr inserted@>
  help1('I''m guessing that you meant to end an alignment here.');
  ins_error;
  end;

@ @<Cases of |handle_right_brace|...@>=
no_align_group: begin line_break_context:=no_align_group; end_graf; unsave; align_peek;
  end;

@ Finally, \.{\\endcsname} is not supposed to get through to |main_control|.

@<Cases of |main_control| that build...@>=
any_mode(end_cs_name): cs_error;

@ @<Declare act...@>=
procedure cs_error;
begin print_err('Extra '); print_esc("endcsname");
@.Extra \\endcsname@>
help1('I''m ignoring this, since I wasn''t doing a \csname.');
error;
end;

@* \[48] Building math lists.

@ Almost all of this section is now in C, see |math.c|. Let here are just
the definitions of the primitives and the infrastructure hooks into |main_control|,
|print_cmd_chr| and |handle_right_brace|.

@<Put each...@>=
primitive_luatex("Ustartmath",math_shift_cs,text_style,0);
@!@:math_shift_cs_}{\.{\\Ustartmath} primitive@>
primitive_luatex("Ustopmath",math_shift_cs,cramped_text_style,0);
@!@:math_shift_cs_}{\.{\\Ustopmath} primitive@>
primitive_luatex("Ustartdisplaymath",math_shift_cs,display_style,0);
@!@:math_shift_cs_}{\.{\\Ustartdisplaymath} primitive@>
primitive_luatex("Ustopdisplaymath",math_shift_cs,cramped_display_style,0);
@!@:math_shift_cs_}{\.{\\Ustopdisplaymath} primitive@>

@

@<Cases of |main_control| that build...@>=
hmode+math_shift, hmode+math_shift_cs:init_math;
mmode+eq_no: if privileged then begin
  if cur_group=math_shift_group then start_eq_no
  else off_save;
  end;

@ @<Put each...@>=
primitive_tex("eqno",eq_no,0,0);
@!@:eq_no_}{\.{\\eqno} primitive@>
primitive_tex("leqno",eq_no,1,0);
@!@:leq_no_}{\.{\\leqno} primitive@>

@ @<Forbidden...@>=non_math(eq_no),

@ @<Cases of |main_control| that build...@>=
mmode+left_brace: math_left_brace;
mmode+letter,mmode+other_char,mmode+char_given:
  set_math_char(get_math_code(cur_chr));
mmode+char_num: begin scan_char_num; cur_chr:=cur_val;
  set_math_char(get_math_code(cur_chr));
  end;
mmode+math_char_num: begin
   if cur_chr=0 then
     mval := scan_mathchar(tex_mathcode)
   else if cur_chr=1 then
     mval := scan_mathchar(aleph_mathcode)
   else if cur_chr=2 then
     mval := scan_mathchar(xetex_mathcode)
   else
     mval := scan_mathchar(xetexnum_mathcode);
  set_math_char(mval);
  end;
mmode+math_given: begin
  mval := mathchar_from_integer(cur_chr,tex_mathcode);
  set_math_char(mval);
  end;
mmode+omath_given: begin
  mval := mathchar_from_integer(cur_chr,aleph_mathcode);
  set_math_char(mval);
  end;
mmode+xmath_given: begin
  mval := mathchar_from_integer(cur_chr,xetex_mathcode);
  set_math_char(mval);
  end;
mmode+delim_num: begin
  if cur_chr=0 then
    mval := scan_delimiter_as_mathchar(tex_mathcode)
  else if cur_chr=1 then
    mval := scan_delimiter_as_mathchar(aleph_mathcode)
  else
    mval := scan_delimiter_as_mathchar(xetex_mathcode);
  set_math_char(mval);
  end;

@ Primitive math operators like \.{\\mathop} and \.{\\underline} are given
the command code |math_comp|, supplemented by the noad type that they
generate.

@<Put each...@>=
primitive_tex("mathord",math_comp,ord_noad_type,0);
@!@:math_ord_}{\.{\\mathord} primitive@>
primitive_tex("mathop",math_comp,op_noad_type_normal,0);
@!@:math_op_}{\.{\\mathop} primitive@>
primitive_tex("mathbin",math_comp,bin_noad_type,0);
@!@:math_bin_}{\.{\\mathbin} primitive@>
primitive_tex("mathrel",math_comp,rel_noad_type,0);
@!@:math_rel_}{\.{\\mathrel} primitive@>
primitive_tex("mathopen",math_comp,open_noad_type,0);
@!@:math_open_}{\.{\\mathopen} primitive@>
primitive_tex("mathclose",math_comp,close_noad_type,0);
@!@:math_close_}{\.{\\mathclose} primitive@>
primitive_tex("mathpunct",math_comp,punct_noad_type,0);
@!@:math_punct_}{\.{\\mathpunct} primitive@>
primitive_tex("mathinner",math_comp,inner_noad_type,0);
@!@:math_inner_}{\.{\\mathinner} primitive@>
primitive_tex("underline",math_comp,under_noad_type,0);
@!@:underline_}{\.{\\underline} primitive@>
primitive_tex("overline",math_comp,over_noad_type,0);@/
@!@:overline_}{\.{\\overline} primitive@>
primitive_tex("displaylimits",limit_switch,op_noad_type_normal,0);
@!@:display_limits_}{\.{\\displaylimits} primitive@>
primitive_tex("limits",limit_switch,op_noad_type_limits,0);
@!@:limits_}{\.{\\limits} primitive@>
primitive_tex("nolimits",limit_switch,op_noad_type_no_limits,0);
@!@:no_limits_}{\.{\\nolimits} primitive@>

@ @<Cases of |main_control| that build...@>=
mmode+math_comp: math_math_comp;
mmode+limit_switch: math_limit_switch;
mmode+radical: math_radical;
mmode+accent,mmode+math_accent:math_ac;
mmode+vcenter: begin scan_spec(vcenter_group,false); normal_paragraph;
  push_nest; mode:=-vmode; prev_depth:=pdf_ignored_dimen;
  if every_vbox<>null then begin_token_list(every_vbox,every_vbox_text);
  end;

@ @<Cases of |handle...@>=
vcenter_group: begin line_break_context:=vcenter_group; end_graf; unsave; save_ptr:=save_ptr-2;
  p:=vpack(vlink(head),saved(1),saved(0)); pop_nest;
  p:=math_vcenter_group(p);
  tail_append(p);
  end;

@ The routine that inserts a |style_node| holds no surprises.

@<Put each...@>=
primitive_tex("displaystyle",math_style,display_style,0);
@!@:display_style_}{\.{\\displaystyle} primitive@>
primitive_tex("textstyle",math_style,text_style,0);
@!@:text_style_}{\.{\\textstyle} primitive@>
primitive_tex("scriptstyle",math_style,script_style,0);
@!@:script_style_}{\.{\\scriptstyle} primitive@>
primitive_tex("scriptscriptstyle",math_style,script_script_style,0);
@!@:script_script_style_}{\.{\\scriptscriptstyle} primitive@>
primitive_luatex("crampeddisplaystyle",math_style,cramped_display_style,0);
@!@:cramped_display_style_}{\.{\\crampeddisplaystyle} primitive@>
primitive_luatex("crampedtextstyle",math_style,cramped_text_style,0);
@!@:cramped_text_style_}{\.{\\crampedtextstyle} primitive@>
primitive_luatex("crampedscriptstyle",math_style,cramped_script_style,0);
@!@:cramped_script_style_}{\.{\\crampedscriptstyle} primitive@>
primitive_luatex("crampedscriptscriptstyle",math_style,cramped_script_script_style,0);
@!@:cramped_script_script_style_}{\.{\\crampedscriptscriptstyle} primitive@>

@ @<Cases of |main_control| that build...@>=
mmode+math_style: tail_append(new_style(cur_chr));
mmode+non_script: begin tail_append(new_glue(zero_glue));
  subtype(tail):=cond_math_glue;
  end;
mmode+math_choice: if cur_chr=0 then append_choices else setup_math_style;

@ @<Cases of |handle_right_brace|...@>=
math_choice_group: build_choices;

@ Here are two primives for explicit super- or subscript choice.

@<Put each...@>=
primitive_luatex("Usuperscript",super_sub_script,sup_mark,sup_mark);
@!@:super_sub_script_}{\.{\\Usuperscript} primitive@>
primitive_luatex("Usubscript",super_sub_script,sub_mark,sup_mark);
@!@:super_sub_script_}{\.{\\Usubscript} primitive@>

@ @<Cases of |main_control| that build...@>=
mmode+sub_mark,mmode+sup_mark,mmode+super_sub_script: sub_sup;

@
@d above_code=0 { `\.{\\above}' }
@d over_code=1 { `\.{\\over}' }
@d atop_code=2 { `\.{\\atop}' }
@d delimited_code=3 { `\.{\\abovewithdelims}', etc.}

@<Put each...@>=
primitive_tex("above",above,above_code,0);@/
@!@:above_}{\.{\\above} primitive@>
primitive_tex("over",above,over_code,0);@/
@!@:over_}{\.{\\over} primitive@>
primitive_tex("atop",above,atop_code,0);@/
@!@:atop_}{\.{\\atop} primitive@>
primitive_tex("abovewithdelims",above,delimited_code+above_code,0);@/
@!@:above_with_delims_}{\.{\\abovewithdelims} primitive@>
primitive_tex("overwithdelims",above,delimited_code+over_code,0);@/
@!@:over_with_delims_}{\.{\\overwithdelims} primitive@>
primitive_tex("atopwithdelims",above,delimited_code+atop_code,0);
@!@:atop_with_delims_}{\.{\\atopwithdelims} primitive@>

@ @<Cases of |main_control| that build...@>=
mmode+above: math_fraction;

@ @<Cases of |handle...@>=
math_group: close_math_group(p);

@

@<Put each...@>=
primitive_tex("left",left_right,left_noad_side,0);
@!@:left_}{\.{\\left} primitive@>
primitive_tex("right",left_right,right_noad_side,0);
@!@:right_}{\.{\\right} primitive@>
primitive_tex("middle",left_right,middle_noad_side,0);
@!@:middle_}{\.{\\middle} primitive@>
text(frozen_right):="right"; eqtb[frozen_right]:=eqtb[cur_val];

@ @<Cases of |main_control| that build...@>=
mmode+left_right: math_left_right;

@ Here is the only way out of math mode.

@<Cases of |main_control| that build...@>=
mmode+math_shift,mmode+math_shift_cs: if cur_group=math_shift_group then after_math
  else off_save;


@* \[49] Mode-independent processing.
The long |main_control| procedure has now been fully specified, except for
certain activities that are independent of the current mode. These activities
do not change the current vlist or hlist or mlist; if they change anything,
it is the value of a parameter or the meaning of a control sequence.

Assignments to values in |eqtb| can be global or local. Furthermore, a
control sequence can be defined to be `\.{\\long}', `\.{\\protected}',
or `\.{\\outer}', and it might or might not be expanded. The prefixes
`\.{\\global}', `\.{\\long}', `\.{\\protected}',
and `\.{\\outer}' can occur in any order. Therefore we assign binary numeric
codes, making it possible to accumulate the union of all specified prefixes
by adding the corresponding codes.  (\PASCAL's |set| operations could also
have been used.)

@<Put each...@>=
primitive_tex("long",prefix,1,0);
@!@:long_}{\.{\\long} primitive@>
primitive_tex("outer",prefix,2,0);
@!@:outer_}{\.{\\outer} primitive@>
primitive_tex("global",prefix,4,0);
@!@:global_}{\.{\\global} primitive@>
primitive_tex("def",def,0,0);
@!@:def_}{\.{\\def} primitive@>
primitive_tex("gdef",def,1,0);
@!@:gdef_}{\.{\\gdef} primitive@>
primitive_tex("edef",def,2,0);
@!@:edef_}{\.{\\edef} primitive@>
primitive_tex("xdef",def,3,0);
@!@:xdef_}{\.{\\xdef} primitive@>

@ Every prefix, and every command code that might or might not be prefixed,
calls the action procedure |prefixed_command|. This routine accumulates
a sequence of prefixes until coming to a non-prefix, then it carries out
the command.

@<Cases of |main_control| that don't...@>=
any_mode(toks_register),
any_mode(assign_toks),
any_mode(assign_int),
any_mode(assign_attr),
any_mode(assign_dir),
any_mode(assign_dimen),
any_mode(assign_glue),
any_mode(assign_mu_glue),
any_mode(assign_font_dimen),
any_mode(assign_font_int),
any_mode(set_aux),
any_mode(set_prev_graf),
any_mode(set_page_dimen),
any_mode(set_page_int),
any_mode(set_box_dimen),
any_mode(set_tex_shape),
any_mode(set_etex_shape),
any_mode(def_char_code),
any_mode(def_del_code),
any_mode(extdef_math_code),
any_mode(extdef_del_code),
any_mode(def_family),
any_mode(set_math_param),
any_mode(set_font),
any_mode(def_font),
any_mode(letterspace_font),
any_mode(pdf_copy_font),
any_mode(register),
any_mode(advance),
any_mode(multiply),
any_mode(divide),
any_mode(prefix),
any_mode(let),
any_mode(shorthand_def),
any_mode(read_to_cs),
any_mode(def),
any_mode(set_box),
any_mode(hyph_data),
any_mode(set_interaction),
any_mode(set_ocp),
any_mode(def_ocp),
any_mode(set_ocp_list),
any_mode(def_ocp_list),
any_mode(clear_ocp_lists),
any_mode(push_ocp_list),
any_mode(pop_ocp_list),
any_mode(ocp_list_op),
any_mode(ocp_trace_level) : prefixed_command;

@ If the user says, e.g., `\.{\\global\\global}', the redundancy is
silently accepted.

@<Declare act...@>=
@t\4@>@<Declare subprocedures for |prefixed_command|@>@t@>@;@/
procedure prefixed_command;
label done,exit;
var a:small_number; {accumulated prefix codes so far}
@!f:internal_font_number; {identifies a font}
@!j:halfword; {index into a \.{\\parshape} specification}
@!p,@!q:pointer; {for temporary short-term use}
@!n:integer; {ditto}
@!e:boolean; {should a definition be expanded? or was \.{\\let} not done?}
@!mval:mathcodeval; {for handling of \.{\\mathchardef}s}
begin a:=0;
while cur_cmd=prefix do
  begin if not odd(a div cur_chr) then a:=a+cur_chr;
  @<Get the next non-blank non-relax...@>;
  if cur_cmd<=max_non_prefixed_command then
    @<Discard erroneous prefixes and |return|@>;
  if tracing_commands>2 then show_cur_cmd_chr;
  end;
@<Discard the prefixes \.{\\long} and \.{\\outer} if they are irrelevant@>;
@<Adjust \(f)for the setting of \.{\\globaldefs}@>;
case cur_cmd of
@t\4@>@<Assignments@>@;
othercases confusion('prefix')
@:this can't happen prefix}{\quad prefix@>
endcases;
done: @<Insert a token saved by \.{\\afterassignment}, if any@>;
exit:end;

@ @<Discard erroneous...@>=
begin print_err('You can''t use a prefix with `');
@.You can't use a prefix with x@>
print_cmd_chr(cur_cmd,cur_chr); print_char("'");
help2('I''ll pretend you didn''t say \long or \outer or \global or',
'\protected.');
back_error; return;
end

@ @<Discard the prefixes...@>=
if a>=8 then
  begin j:=protected_token; a:=a-8;
  end
else j:=0;
if (cur_cmd<>def)and((a mod 4<>0)or(j<>0)) then
  begin print_err('You can''t use `'); print_esc("long"); print("' or `");
  print_esc("outer"); print("' with `");
@.You can't use \\long...@>
  print_cmd_chr(cur_cmd,cur_chr); print_char("'");
  help1('I''ll pretend you didn''t say \long or \outer here.');
  error;
  end

@ The previous routine does not have to adjust |a| so that |a mod 4=0|,
since the following routines test for the \.{\\global} prefix as follows.

@d global==(a>=4)
@d define(#)==begin if global then geq_define(#)@+else eq_define(#); end
@d word_define(#)==begin if global then geq_word_define(#)@+else eq_word_define(#); end
@d define_lc_code(#)==begin if global
   then set_lc_code(#,level_one)@+else set_lc_code(#,cur_level); end
@d define_uc_code(#)==begin if global
   then set_uc_code(#,level_one)@+else set_uc_code(#,cur_level); end
@d define_sf_code(#)==begin if global
   then set_sf_code(#,level_one)@+else set_sf_code(#,cur_level); end
@d define_cat_code(#)==begin if global
   then set_cat_code(cat_code_table,#,level_one)@+else set_cat_code(cat_code_table,#,cur_level); end
@d define_fam_fnt(#)==begin if global
   then def_fam_fnt(#,level_one)@+else def_fam_fnt(#,cur_level); end
@d define_math_param(#)==begin if global
   then def_math_param(#,level_one)@+else def_math_param(#,cur_level); end


@<Adjust \(f)for the setting of \.{\\globaldefs}@>=
if global_defs<>0 then begin
  if global_defs<0 then
    begin if global then a:=a-4;
    end
  else  begin if not global then a:=a+4;
    end;
  end

@ When a control sequence is to be defined, by \.{\\def} or \.{\\let} or
something similar, the |get_r_token| routine will substitute a special
control sequence for a token that is not redefinable.

@<Declare subprocedures for |prefixed_command|@>=
procedure get_r_token;
label restart;
begin restart: repeat get_token;
until cur_tok<>space_token;
if (cur_cs=0)or(cur_cs>frozen_control_sequence) then
  begin print_err('Missing control sequence inserted');
@.Missing control...@>
  help5('Please don''t say `\def cs{...}'', say `\def\cs{...}''.',
  'I''ve inserted an inaccessible control sequence so that your',
  'definition will be completed without mixing me up too badly.',
  'You can recover graciously from this error, if you''re',
  'careful; see exercise 27.2 in The TeXbook.');
@:TeXbook}{\sl The \TeX book@>
  if cur_cs=0 then back_input;
  cur_tok:=cs_token_flag+frozen_protection; ins_error; goto restart;
  end;
end;

@ @<Initialize table entries...@>=
text(frozen_protection):="inaccessible";

@ Assignments from Lua need helpers.

@p function is_int_assign(cmd:halfword):boolean;
begin
  is_int_assign := (cmd=assign_int);
end;
function is_dim_assign(cmd:halfword):boolean;
begin
  is_dim_assign := (cmd=assign_dimen);
end;
function is_toks_assign(cmd:halfword):boolean;
begin
  is_toks_assign := (cmd=assign_toks);
end;

@ @<Declare subprocedures for |prefixed_command|@>=
procedure assign_internal_value(a:small_number;p:halfword;cur_val:integer);
var  n:halfword;
begin
if (p>=int_base)and(p<attribute_base) then begin
  if p=(int_base+cat_code_table_code) then begin
    if valid_catcode_table(cur_val) then begin
      if cur_val<>cat_code_table then
        word_define(p,cur_val);
      end
    else begin
      print_err('Invalid \catcode table');
      help2('You can only switch to a \catcode table that is initialized',
           'using \savecatcodetable or \initcatcodetable, or to table 0');
      error;
      end;
    end
  else if (p=(int_base+output_box_code)and((cur_val>65535)or(cur_val<0))) then begin
    print_err('Invalid \outputbox');
    help1('The value for \outputbox has to be between 0 and 65535.');
    error;
    end
  else if ((p=new_line_char)and((cur_val>127)or(cur_val<0))) then begin
    print_err('Invalid \newlinechar');
    help1('The value for \newlinechar has to be between 0 and 127.');
    error;
    end
  else if p=end_line_char then begin
    if (cur_val<0)or(cur_val>biggest_char) then
      word_define(p,-1)
    else
      word_define(p,13);
    end
  else
   word_define(p,cur_val);
{If we are defining subparagraph penalty levels while we are
in hmode, then we put out a whatsit immediately, otherwise
we leave it alone.  This mechanism might not be sufficiently
powerful, and some other algorithm, searching down the stack,
might be necessary.  Good first step.}
  if (abs(mode)=hmode) and
     ((p=(int_base+local_inter_line_penalty_code)) or
      (p=(int_base+local_broken_penalty_code))) then begin
    @<LOCAL: Add local paragraph node@>;
    eq_word_define(int_base+no_local_whatsits_code,no_local_whatsits+1);
    end;
  if p=int_base+language_code then word_define(int_base+cur_lang_code,cur_val);
  end
else if (p>=dimen_base)and(p<eqtb_size) then begin
  if p=(dimen_base+page_left_offset_code) then begin
    n:=cur_val - one_true_inch;
    word_define(dimen_base+h_offset_code, n);
    end
  else if p=(dimen_base+h_offset_code) then begin
    n:=cur_val + one_true_inch;
    word_define(dimen_base+page_left_offset_code, n);
    end
  else if p=(dimen_base+page_top_offset_code) then begin
    n:=cur_val - one_true_inch;
    word_define(dimen_base+v_offset_code, n);
    end
  else if p=(dimen_base+v_offset_code) then begin
    n:=cur_val + one_true_inch;
    word_define(dimen_base+page_top_offset_code, n);
    end;
  word_define(p,cur_val);
  end
else if (p>=local_base)and(p<toks_base) then {internal locals }
  define(p,call,cur_val)
else
  confusion('assign internal value');
end;


@ Here's an example of the way many of the following routines operate.
(Unfortunately, they aren't all as simple as this.)

@<Assignments@>=
set_font: define(cur_font_loc,data,cur_chr);

@ When a |def| command has been scanned,
|cur_chr| is odd if the definition is supposed to be global, and
|cur_chr>=2| if the definition is supposed to be expanded.

@<Assignments@>=
def: begin if odd(cur_chr)and not global and(global_defs>=0) then a:=a+4;
  e:=(cur_chr>=2); get_r_token; p:=cur_cs;
  q:=scan_toks(true,e);
  if j<>0 then
    begin q:=get_avail; set_token_info(q,j); set_token_link(q,link(def_ref));
    set_token_link(def_ref,q);
    end;
  define(p,call+(a mod 4),def_ref);
  end;

@ Both \.{\\let} and \.{\\futurelet} share the command code |let|.

@<Put each...@>=
primitive_tex("let",let,normal,0);@/
@!@:let_}{\.{\\let} primitive@>
primitive_tex("futurelet",let,normal+1,0);@/
@!@:future_let_}{\.{\\futurelet} primitive@>

@ @<Assignments@>=
let:  begin n:=cur_chr;
  get_r_token; p:=cur_cs;
  if n=normal then
    begin repeat get_token;
    until cur_cmd<>spacer;
    if cur_tok=other_token+"=" then
      begin get_token;
      if cur_cmd=spacer then get_token;
      end;
    end
  else  begin get_token; q:=cur_tok; get_token; back_input;
    cur_tok:=q; back_input; {look ahead, then back up}
    end; {note that |back_input| doesn't affect |cur_cmd|, |cur_chr|}
  if cur_cmd>=call then add_token_ref(cur_chr);
  define(p,cur_cmd,cur_chr);
  end;

@ A \.{\\chardef} creates a control sequence whose |cmd| is |char_given|;
a \.{\\mathchardef} creates a control sequence whose |cmd| is |math_given|;
and the corresponding |chr| is the character code or math code. A \.{\\countdef}
or \.{\\dimendef} or \.{\\skipdef} or \.{\\muskipdef} creates a control
sequence whose |cmd| is |assign_int| or \dots\ or |assign_mu_glue|, and the
corresponding |chr| is the |eqtb| location of the internal register in question.

@d char_def_code=0 {|shorthand_def| for \.{\\chardef}}
@d math_char_def_code=1 {|shorthand_def| for \.{\\mathchardef}}
@d omath_char_def_code=2 {|shorthand_def| for \.{\\omathchardef}}
@d xmath_char_def_code=3 {|shorthand_def| for \.{\\Umathchardef}}
@d count_def_code=4 {|shorthand_def| for \.{\\countdef}}
@d attribute_def_code=5 {|shorthand_def| for \.{\\attributedef}}
@d dimen_def_code=6 {|shorthand_def| for \.{\\dimendef}}
@d skip_def_code=7 {|shorthand_def| for \.{\\skipdef}}
@d mu_skip_def_code=8 {|shorthand_def| for \.{\\muskipdef}}
@d toks_def_code=9 {|shorthand_def| for \.{\\toksdef}}

@<Put each...@>=
primitive_tex("chardef",shorthand_def,char_def_code,0);@/
@!@:char_def_}{\.{\\chardef} primitive@>
primitive_tex("mathchardef",shorthand_def,math_char_def_code,0);@/
@!@:math_char_def_}{\.{\\mathchardef} primitive@>
primitive_omega("omathchardef",shorthand_def,omath_char_def_code,0);@/
@!@:math_char_def_}{\.{\\omathchardef} primitive@>
primitive_luatex("Umathchardef",shorthand_def,xmath_char_def_code,0);@/
@!@:math_char_def_}{\.{\\Umathchardef} primitive@>
primitive_tex("countdef",shorthand_def,count_def_code,0);@/
@!@:count_def_}{\.{\\countdef} primitive@>
primitive_luatex("attributedef",shorthand_def,attribute_def_code,0);@/
@!@:attribute_def_}{\.{\\attributedef} primitive@>
primitive_tex("dimendef",shorthand_def,dimen_def_code,0);@/
@!@:dimen_def_}{\.{\\dimendef} primitive@>
primitive_tex("skipdef",shorthand_def,skip_def_code,0);@/
@!@:skip_def_}{\.{\\skipdef} primitive@>
primitive_tex("muskipdef",shorthand_def,mu_skip_def_code,0);@/
@!@:mu_skip_def_}{\.{\\muskipdef} primitive@>
primitive_tex("toksdef",shorthand_def,toks_def_code,0);@/
@!@:toks_def_}{\.{\\toksdef} primitive@>

@ We temporarily define |p| to be |relax|, so that an occurrence of |p|
while scanning the definition will simply stop the scanning instead of
producing an ``undefined control sequence'' error or expanding the
previous meaning.  This allows, for instance, `\.{\\chardef\\foo=123\\foo}'.

@<Assignments@>=
shorthand_def: begin n:=cur_chr; get_r_token; p:=cur_cs;
  define(p,relax,too_big_char); scan_optional_equals;
  case n of
  char_def_code: begin scan_char_num; define(p,char_given,cur_val);
    end;
  math_char_def_code: begin
    mval:=scan_mathchar(tex_mathcode);
    cur_val:=(mval.class_value*16+mval.family_value)*256+mval.character_value;
    define(p,math_given,cur_val);
    end;
  omath_char_def_code: begin
    mval:=scan_mathchar(aleph_mathcode);
    cur_val:=(mval.class_value*256+mval.family_value)*65536+mval.character_value;
    define(p,omath_given,cur_val);
    end;
  xmath_char_def_code: begin
    mval:=scan_mathchar(xetex_mathcode);
    cur_val:=(mval.class_value+(8*mval.family_value))*(65536*32)+mval.character_value;
    define(p,xmath_given,cur_val);
    end;
  othercases begin scan_register_num;
    case n of
    count_def_code: define(p,assign_int,count_base+cur_val);
    attribute_def_code: define(p,assign_attr,attribute_base+cur_val);
    dimen_def_code: define(p,assign_dimen,scaled_base+cur_val);
    skip_def_code: define(p,assign_glue,skip_base+cur_val);
    mu_skip_def_code: define(p,assign_mu_glue,mu_skip_base+cur_val);
    toks_def_code: define(p,assign_toks,toks_base+cur_val);
    end; {there are no other cases}
    end
  endcases;
  end;

@ @<Assignments@>=
read_to_cs: begin j:=cur_chr; scan_int; n:=cur_val;
  if not scan_keyword('to') then
@.to@>
    begin print_err('Missing `to'' inserted');
@.Missing `to'...@>
    help2('You should have said `\read<number> to \cs''.',
    'I''m going to look for the \cs now.'); error;
    end;
  get_r_token;
  p:=cur_cs; read_toks(n,p,j); define(p,call,cur_val);
  end;

@ The token-list parameters, \.{\\output} and \.{\\everypar}, etc., receive
their values in the following way. (For safety's sake, we place an
enclosing pair of braces around an \.{\\output} list.)

@<Assignments@>=
toks_register,assign_toks: begin q:=cur_cs;
  if cur_cmd=toks_register then
    begin scan_register_num; p:=toks_base+cur_val;
    end
  else p:=cur_chr; {|p=every_par_loc| or |output_routine_loc| or \dots}
  scan_optional_equals;
  @<Get the next non-blank non-relax non-call token@>;
  if cur_cmd<>left_brace then @<If the right-hand side is a token parameter
      or token register, finish the assignment and |goto done|@>;
  back_input; cur_cs:=q; q:=scan_toks(false,false);
  if link(def_ref)=null then {empty list: revert to the default}
    begin define(p,undefined_cs,null); free_avail(def_ref);
    end
  else  begin if p=output_routine_loc then {enclose in curlies}
      begin p:=get_avail; set_token_link(q,p); p:=output_routine_loc;
      q:=link(q); set_token_info(q,right_brace_token+"}");
      q:=get_avail;
      set_token_info(q,left_brace_token+"{");
      set_token_link(q,link(def_ref)); 
      set_token_link(def_ref,q);
      end;
    define(p,call,def_ref);
    end;
  end;

@ @<If the right-hand side is a token parameter...@>=
begin if cur_cmd=toks_register then
  begin scan_register_num; cur_cmd:=assign_toks; cur_chr:=toks_base+cur_val;
  end;
if cur_cmd=assign_toks then
  begin q:=equiv(cur_chr);
  if q=null then define(p,undefined_cs,null)
  else  begin add_token_ref(q); define(p,call,q);
    end;
  goto done;
  end;
end

@ Similar routines are used to assign values to the numeric parameters.

@<Assignments@>=
assign_int: begin p:=cur_chr; scan_optional_equals; scan_int;
   assign_internal_value(a,p,cur_val);
   end;
assign_attr: begin p:=cur_chr; scan_optional_equals; scan_int;
  if (p-attribute_base)>max_used_attr then max_used_attr:=(p-attribute_base);
  attr_list_cache:=cache_disabled;
  word_define(p,cur_val); end;
assign_dir: begin
  @<DIR: Assign direction codes@>
  end;
assign_dimen: begin p:=cur_chr; scan_optional_equals;
  scan_normal_dimen; assign_internal_value(a,p,cur_val);
  end;
assign_glue,assign_mu_glue: begin p:=cur_chr; n:=cur_cmd; scan_optional_equals;
  if n=assign_mu_glue then scan_glue(mu_val_level)@+else scan_glue(glue_val_level);
  trap_zero_glue;
  define(p,glue_ref,cur_val);
  end;

@ When a glue register or parameter becomes zero, it will always point to
|zero_glue| because of the following procedure. (Exception: The tabskip
glue isn't trapped while preambles are being scanned.)

@<Declare subprocedures for |prefixed_command|@>=
procedure trap_zero_glue;
begin if (width(cur_val)=0)and(stretch(cur_val)=0)and(shrink(cur_val)=0) then
  begin add_glue_ref(zero_glue);
  delete_glue_ref(cur_val); cur_val:=zero_glue;
  end;
end;

@ The various character code tables are changed by the |def_code| commands,
and the font families are declared by |def_family|.

@<Put each...@>=
primitive_tex("catcode",def_char_code,cat_code_base,cat_code_base);
@!@:cat_code_}{\.{\\catcode} primitive@>
primitive_tex("mathcode",def_char_code,math_code_base,cat_code_base);
@!@:math_code_}{\.{\\mathcode} primitive@>
primitive_tex("lccode",def_char_code,lc_code_base,cat_code_base);
@!@:lc_code_}{\.{\\lccode} primitive@>
primitive_tex("uccode",def_char_code,uc_code_base,cat_code_base);
@!@:uc_code_}{\.{\\uccode} primitive@>
primitive_tex("sfcode",def_char_code,sf_code_base,cat_code_base);
@!@:sf_code_}{\.{\\sfcode} primitive@>
primitive_tex("delcode",def_del_code,del_code_base,del_code_base);
@!@:del_code_}{\.{\\delcode} primitive@>
primitive_tex("textfont",def_family,text_size,0);
@!@:text_font_}{\.{\\textfont} primitive@>
primitive_tex("scriptfont",def_family,script_size,0);
@!@:script_font_}{\.{\\scriptfont} primitive@>
primitive_tex("scriptscriptfont",def_family,script_script_size,0);
@!@:script_script_font_}{\.{\\scriptscriptfont} primitive@>
primitive_luatex("Umathquad",             set_math_param, math_param_quad,0);
primitive_luatex("Umathaxis",             set_math_param, math_param_axis,0);
primitive_luatex("Umathoperatorsize",     set_math_param, math_param_operator_size,0);
primitive_luatex("Umathoverbarkern",      set_math_param, math_param_overbar_kern,0);
primitive_luatex("Umathoverbarrule",      set_math_param, math_param_overbar_rule,0);
primitive_luatex("Umathoverbarvgap",      set_math_param, math_param_overbar_vgap,0);
primitive_luatex("Umathunderbarkern",     set_math_param, math_param_underbar_kern,0);
primitive_luatex("Umathunderbarrule",     set_math_param, math_param_underbar_rule,0);
primitive_luatex("Umathunderbarvgap",     set_math_param, math_param_underbar_vgap,0);
primitive_luatex("Umathradicalkern",      set_math_param, math_param_radical_kern,0);
primitive_luatex("Umathradicalrule",      set_math_param, math_param_radical_rule,0);
primitive_luatex("Umathradicalvgap",      set_math_param, math_param_radical_vgap,0);
primitive_luatex("Umathradicaldegreebefore",set_math_param, math_param_radical_degree_before,0);
primitive_luatex("Umathradicaldegreeafter", set_math_param, math_param_radical_degree_after,0);
primitive_luatex("Umathradicaldegreeraise", set_math_param, math_param_radical_degree_raise,0);
primitive_luatex("Umathstackvgap",        set_math_param, math_param_stack_vgap,0);
primitive_luatex("Umathstacknumup",       set_math_param, math_param_stack_num_up,0);
primitive_luatex("Umathstackdenomdown",   set_math_param, math_param_stack_denom_down,0);
primitive_luatex("Umathfractionrule",     set_math_param, math_param_fraction_rule,0);
primitive_luatex("Umathfractionnumvgap",  set_math_param, math_param_fraction_num_vgap,0);
primitive_luatex("Umathfractionnumup",    set_math_param, math_param_fraction_num_up,0);
primitive_luatex("Umathfractiondenomvgap",set_math_param, math_param_fraction_denom_vgap,0);
primitive_luatex("Umathfractiondenomdown",set_math_param, math_param_fraction_denom_down,0);
primitive_luatex("Umathfractiondelsize",  set_math_param, math_param_fraction_del_size,0);
primitive_luatex("Umathlimitabovevgap",   set_math_param, math_param_limit_above_vgap,0);
primitive_luatex("Umathlimitabovebgap",   set_math_param, math_param_limit_above_bgap,0);
primitive_luatex("Umathlimitabovekern",   set_math_param, math_param_limit_above_kern,0);
primitive_luatex("Umathlimitbelowvgap",    set_math_param, math_param_limit_below_vgap,0);
primitive_luatex("Umathlimitbelowbgap",    set_math_param, math_param_limit_below_bgap,0);
primitive_luatex("Umathlimitbelowkern",    set_math_param, math_param_limit_below_kern,0);
primitive_luatex("Umathunderdelimitervgap", set_math_param, math_param_under_delimiter_vgap,0);
primitive_luatex("Umathunderdelimiterbgap", set_math_param, math_param_under_delimiter_bgap,0);
primitive_luatex("Umathoverdelimitervgap",set_math_param, math_param_over_delimiter_vgap,0);
primitive_luatex("Umathoverdelimiterbgap",set_math_param, math_param_over_delimiter_bgap,0);
primitive_luatex("Umathsubshiftdrop",     set_math_param, math_param_sub_shift_drop,0);
primitive_luatex("Umathsupshiftdrop",     set_math_param, math_param_sup_shift_drop,0);
primitive_luatex("Umathsubshiftdown",     set_math_param, math_param_sub_shift_down,0);
primitive_luatex("Umathsubsupshiftdown",  set_math_param, math_param_sub_sup_shift_down,0);
primitive_luatex("Umathsubtopmax",        set_math_param, math_param_sub_top_max,0);
primitive_luatex("Umathsupshiftup",       set_math_param, math_param_sup_shift_up,0);
primitive_luatex("Umathsupbottommin",     set_math_param, math_param_sup_bottom_min,0);
primitive_luatex("Umathsupsubbottommax",  set_math_param, math_param_sup_sub_bottom_max,0);
primitive_luatex("Umathsubsupvgap",       set_math_param, math_param_subsup_vgap,0);
primitive_luatex("Umathspaceafterscript", set_math_param, math_param_space_after_script,0);
primitive_luatex("Umathconnectoroverlapmin", set_math_param, math_param_connector_overlap_min,0);
primitive_luatex("Umathordordspacing",    set_math_param, math_param_ord_ord_spacing,0);
primitive_luatex("Umathordopspacing",     set_math_param, math_param_ord_op_spacing,0);
primitive_luatex("Umathordbinspacing",    set_math_param, math_param_ord_bin_spacing,0);
primitive_luatex("Umathordrelspacing",    set_math_param, math_param_ord_rel_spacing,0);
primitive_luatex("Umathordopenspacing",   set_math_param, math_param_ord_open_spacing,0);
primitive_luatex("Umathordclosespacing",  set_math_param, math_param_ord_close_spacing,0);
primitive_luatex("Umathordpunctspacing",  set_math_param, math_param_ord_punct_spacing,0);
primitive_luatex("Umathordinnerspacing",  set_math_param, math_param_ord_inner_spacing,0);
primitive_luatex("Umathopordspacing",     set_math_param, math_param_op_ord_spacing,0);
primitive_luatex("Umathopopspacing",      set_math_param, math_param_op_op_spacing,0);
primitive_luatex("Umathopbinspacing",     set_math_param, math_param_op_bin_spacing,0);
primitive_luatex("Umathoprelspacing",     set_math_param, math_param_op_rel_spacing,0);
primitive_luatex("Umathopopenspacing",    set_math_param, math_param_op_open_spacing,0);
primitive_luatex("Umathopclosespacing",   set_math_param, math_param_op_close_spacing,0);
primitive_luatex("Umathoppunctspacing",   set_math_param, math_param_op_punct_spacing,0);
primitive_luatex("Umathopinnerspacing",   set_math_param, math_param_op_inner_spacing,0);
primitive_luatex("Umathbinordspacing",    set_math_param, math_param_bin_ord_spacing,0);
primitive_luatex("Umathbinopspacing",     set_math_param, math_param_bin_op_spacing,0);
primitive_luatex("Umathbinbinspacing",    set_math_param, math_param_bin_bin_spacing,0);
primitive_luatex("Umathbinrelspacing",    set_math_param, math_param_bin_rel_spacing,0);
primitive_luatex("Umathbinopenspacing",   set_math_param, math_param_bin_open_spacing,0);
primitive_luatex("Umathbinclosespacing",  set_math_param, math_param_bin_close_spacing,0);
primitive_luatex("Umathbinpunctspacing",  set_math_param, math_param_bin_punct_spacing,0);
primitive_luatex("Umathbininnerspacing",  set_math_param, math_param_bin_inner_spacing,0);
primitive_luatex("Umathrelordspacing",    set_math_param, math_param_rel_ord_spacing,0);
primitive_luatex("Umathrelopspacing",     set_math_param, math_param_rel_op_spacing,0);
primitive_luatex("Umathrelbinspacing",    set_math_param, math_param_rel_bin_spacing,0);
primitive_luatex("Umathrelrelspacing",    set_math_param, math_param_rel_rel_spacing,0);
primitive_luatex("Umathrelopenspacing",   set_math_param, math_param_rel_open_spacing,0);
primitive_luatex("Umathrelclosespacing",  set_math_param, math_param_rel_close_spacing,0);
primitive_luatex("Umathrelpunctspacing",  set_math_param, math_param_rel_punct_spacing,0);
primitive_luatex("Umathrelinnerspacing",  set_math_param, math_param_rel_inner_spacing,0);
primitive_luatex("Umathopenordspacing",   set_math_param, math_param_open_ord_spacing,0);
primitive_luatex("Umathopenopspacing",    set_math_param, math_param_open_op_spacing,0);
primitive_luatex("Umathopenbinspacing",   set_math_param, math_param_open_bin_spacing,0);
primitive_luatex("Umathopenrelspacing",   set_math_param, math_param_open_rel_spacing,0);
primitive_luatex("Umathopenopenspacing",  set_math_param, math_param_open_open_spacing,0);
primitive_luatex("Umathopenclosespacing", set_math_param, math_param_open_close_spacing,0);
primitive_luatex("Umathopenpunctspacing", set_math_param, math_param_open_punct_spacing,0);
primitive_luatex("Umathopeninnerspacing", set_math_param, math_param_open_inner_spacing,0);
primitive_luatex("Umathcloseordspacing",  set_math_param, math_param_close_ord_spacing,0);
primitive_luatex("Umathcloseopspacing",   set_math_param, math_param_close_op_spacing,0);
primitive_luatex("Umathclosebinspacing",  set_math_param, math_param_close_bin_spacing,0);
primitive_luatex("Umathcloserelspacing",  set_math_param, math_param_close_rel_spacing,0);
primitive_luatex("Umathcloseopenspacing", set_math_param, math_param_close_open_spacing,0);
primitive_luatex("Umathcloseclosespacing",set_math_param, math_param_close_close_spacing,0);
primitive_luatex("Umathclosepunctspacing",set_math_param, math_param_close_punct_spacing,0);
primitive_luatex("Umathcloseinnerspacing",set_math_param, math_param_close_inner_spacing,0);
primitive_luatex("Umathpunctordspacing",  set_math_param, math_param_punct_ord_spacing,0);
primitive_luatex("Umathpunctopspacing",   set_math_param, math_param_punct_op_spacing,0);
primitive_luatex("Umathpunctbinspacing",  set_math_param, math_param_punct_bin_spacing,0);
primitive_luatex("Umathpunctrelspacing",  set_math_param, math_param_punct_rel_spacing,0);
primitive_luatex("Umathpunctopenspacing", set_math_param, math_param_punct_open_spacing,0);
primitive_luatex("Umathpunctclosespacing",set_math_param, math_param_punct_close_spacing,0);
primitive_luatex("Umathpunctpunctspacing",set_math_param, math_param_punct_punct_spacing,0);
primitive_luatex("Umathpunctinnerspacing",set_math_param, math_param_punct_inner_spacing,0);
primitive_luatex("Umathinnerordspacing",  set_math_param, math_param_inner_ord_spacing,0);
primitive_luatex("Umathinneropspacing",   set_math_param, math_param_inner_op_spacing,0);
primitive_luatex("Umathinnerbinspacing",  set_math_param, math_param_inner_bin_spacing,0);
primitive_luatex("Umathinnerrelspacing",  set_math_param, math_param_inner_rel_spacing,0);
primitive_luatex("Umathinneropenspacing", set_math_param, math_param_inner_open_spacing,0);
primitive_luatex("Umathinnerclosespacing",set_math_param, math_param_inner_close_spacing,0);
primitive_luatex("Umathinnerpunctspacing",set_math_param, math_param_inner_punct_spacing,0);
primitive_luatex("Umathinnerinnerspacing",set_math_param, math_param_inner_inner_spacing,0);
primitive_omega("omathcode",extdef_math_code,math_code_base,math_code_base);
@!@:math_code_}{\.{\\omathcode} primitive@>
primitive_omega("odelcode",extdef_del_code,del_code_base,del_code_base);
@!@:del_code_}{\.{\\odelcode} primitive@>
primitive_luatex("Umathcode",extdef_math_code,math_code_base+1,math_code_base);
@!@:math_code_}{\.{\\Umathcode} primitive@>
primitive_luatex("Udelcode",extdef_del_code,del_code_base+1,del_code_base);
@!@:del_code_}{\.{\\Udelcode} primitive@>
primitive_luatex("Umathcodenum",extdef_math_code,math_code_base+2,math_code_base);
@!@:math_code_}{\.{\\Umathcodenum} primitive@>
primitive_luatex("Udelcodenum",extdef_del_code,del_code_base+2,del_code_base);
@!@:del_code_}{\.{\\Udelcodenum} primitive@>


@ The different types of code values have different legal ranges; the
following program is careful to check each case properly.

@d check_def_code(#)== if ((cur_val<0)and(p<#))or(cur_val>n) then
      begin print_err('Invalid code ('); print_int(cur_val);
      if p<# then print("), should be in the range 0..")
      else print("), should be at most ");
      print_int(n);
      help1('I''m going to use 0 instead of that illegal code value.');@/
      error; cur_val:=0;
     end
@.Invalid code@>


@<Assignments@>=
def_char_code,def_del_code: begin
  @<Let |n| be the largest legal code value, based on |cur_chr|@>;
  p:=cur_chr;
  if cur_chr=math_code_base then begin
    if global then cur_val1:=level_one else cur_val1:=cur_level;
    scan_extdef_math_code(cur_val1,tex_mathcode);
    end
  else if cur_chr=lc_code_base then begin
    scan_char_num; p:= cur_val;
    scan_optional_equals;
    scan_int;
    check_def_code(lc_code_base);
    define_lc_code(p,cur_val);
    end
  else if cur_chr=uc_code_base then begin
    scan_char_num; p:= cur_val;
    scan_optional_equals;
    scan_int;
    check_def_code(uc_code_base);
    define_uc_code(p,cur_val);
    end
  else if cur_chr=sf_code_base then begin
    scan_char_num; p:= cur_val;
    scan_optional_equals;
    scan_int;
    check_def_code(sf_code_base);
    define_sf_code(p,cur_val);
    end
  else if cur_chr=cat_code_base then begin
    scan_char_num; p:= cur_val;
    scan_optional_equals;
    scan_int;
    check_def_code(cat_code_base);
    define_cat_code(p,cur_val);
    end
  else if cur_chr=del_code_base then begin
    if global then cur_val1:=level_one else cur_val1:=cur_level;
    scan_extdef_del_code(cur_val1,tex_mathcode);
    end;
  end;
extdef_math_code, extdef_del_code: begin
  if global then cur_val1:=level_one else cur_val1:=cur_level;
  if cur_chr=math_code_base  then
    scan_extdef_math_code(cur_val1,aleph_mathcode)
  else if cur_chr=math_code_base+1 then
    scan_extdef_math_code(cur_val1,xetex_mathcode)
  else if cur_chr=math_code_base+2 then
    scan_extdef_math_code(cur_val1,xetexnum_mathcode)
  else if cur_chr=del_code_base  then
    scan_extdef_del_code(cur_val1,aleph_mathcode)
  else if cur_chr=del_code_base+1  then
    scan_extdef_del_code(cur_val1,xetex_mathcode)
  else if cur_chr=del_code_base+2  then
    scan_extdef_del_code(cur_val1,xetexnum_mathcode);
  end;


@ @<Let |n| be the largest...@>=
if cur_chr=cat_code_base then n:=max_char_code
else if cur_chr=lc_code_base then n:=biggest_char
else if cur_chr=uc_code_base then n:=biggest_char
else if cur_chr=sf_code_base then n:=@'77777
else n:=biggest_char

@ @<Assignments@>=
def_family: begin p:=cur_chr; scan_math_family_int; cur_val1:=cur_val;
  scan_optional_equals; scan_font_ident;
  define_fam_fnt(cur_val1,p,cur_val);
  end;
set_math_param: begin p:=cur_chr; get_token;
   if cur_cmd<>math_style then begin
   print_err('Missing math style, treated as \displaystyle');
@.Missing number...@>
    help1('A style should have been here; I inserted `\displaystyle''.');
    cur_val1:=display_style;
    back_error;
    end
  else
    cur_val1:=cur_chr;
  scan_optional_equals;
  if p<math_param_first_mu_glue then begin
    if p=math_param_radical_degree_raise then
       scan_int
    else
       scan_dimen(false, false, false);
    end
  else begin
    scan_glue(mu_val_level); trap_zero_glue;
    if cur_val=thin_mu_skip then cur_val:=thin_mu_skip_code
    else if cur_val=med_mu_skip then cur_val:=med_mu_skip_code
    else if cur_val=thick_mu_skip then cur_val:=thick_mu_skip_code
    end;
  define_math_param(p,cur_val1,cur_val);
  end;

@ Next we consider changes to \TeX's numeric registers.

@<Assignments@>=
register,advance,multiply,divide: do_register_command(a);

@ We use the fact that |register<advance<multiply<divide|.

@<Declare subprocedures for |prefixed_command|@>=
procedure do_register_command(@!a:small_number);
label found,exit;
var l,@!q,@!r,@!s:pointer; {for list manipulation}
@!p:integer; {type of register involved}
begin q:=cur_cmd;
@<Compute the register location |l| and its type |p|; but |return| if invalid@>;
if q=register then scan_optional_equals
else if scan_keyword('by') then do_nothing; {optional `\.{by}'}
@.by@>
arith_error:=false;
if q<multiply then @<Compute result of |register| or
    |advance|, put it in |cur_val|@>
else @<Compute result of |multiply| or |divide|, put it in |cur_val|@>;
if arith_error then
  begin print_err('Arithmetic overflow');
@.Arithmetic overflow@>
  help2('I can''t carry out that multiplication or division,',
    'since the result is out of range.');
  if p>=glue_val then delete_glue_ref(cur_val);
  error; return;
  end;
if p<glue_val then begin
   if p=attr_val_level then begin
     if (l-attribute_base)>max_used_attr then max_used_attr:=(l-attribute_base);
     attr_list_cache:=cache_disabled;
     end;
  if (p=int_val_level) or (p=dimen_val_level) then
    assign_internal_value(a,l,cur_val)
  else
    word_define(l,cur_val);
  end
else  begin trap_zero_glue; define(l,glue_ref,cur_val);
  end;
exit: end;

@ Here we use the fact that the consecutive codes |int_val..mu_val| and
|assign_int..assign_mu_glue| correspond to each other nicely.

@<Compute the register location |l| and its type |p|...@>=
begin l:=0;
if q<>register then
  begin get_x_token;
  if (cur_cmd>=assign_int)and(cur_cmd<=assign_mu_glue) then
    begin l:=cur_chr; p:=cur_cmd-assign_int; goto found;
    end;
  if cur_cmd<>register then
    begin print_err('You can''t use `'); print_cmd_chr(cur_cmd,cur_chr);
@.You can't use x after ...@>
    print("' after "); print_cmd_chr(q,0);
    help1('I''m forgetting what you said and not changing anything.');
    error; return;
    end;
  end;
p:=cur_chr; scan_register_num;
if p=int_val_level then l:=cur_val+count_base
else if p=attr_val_level then l:=cur_val+attribute_base
else if p=dimen_val_level then l:=cur_val+scaled_base
else if p=glue_val_level then l:=cur_val+skip_base
else if p=mu_val_level then l:=cur_val+mu_skip_base;
end;
found:

@ @<Compute result of |register| or |advance|...@>=
if p<glue_val then
  begin if (p=int_val_level) or (p=attr_val_level) then scan_int@+else scan_normal_dimen;
  if q=advance then cur_val:=cur_val+eqtb[l].int;
  end
else  begin scan_glue(p);
  if q=advance then @<Compute the sum of two glue specs@>;
  end

@ @<Compute the sum of two glue specs@>=
begin q:=new_spec(cur_val); r:=equiv(l);
delete_glue_ref(cur_val);
width(q):=width(q)+width(r);
if stretch(q)=0 then stretch_order(q):=normal;
if stretch_order(q)=stretch_order(r) then stretch(q):=stretch(q)+stretch(r)
else if (stretch_order(q)<stretch_order(r))and(stretch(r)<>0) then
  begin stretch(q):=stretch(r); stretch_order(q):=stretch_order(r);
  end;
if shrink(q)=0 then shrink_order(q):=normal;
if shrink_order(q)=shrink_order(r) then shrink(q):=shrink(q)+shrink(r)
else if (shrink_order(q)<shrink_order(r))and(shrink(r)<>0) then
  begin shrink(q):=shrink(r); shrink_order(q):=shrink_order(r);
  end;
cur_val:=q;
end

@ @<Compute result of |multiply| or |divide|...@>=
begin scan_int;
if p<glue_val then
  if q=multiply then
    if (p=int_val_level)or(p=attr_val_level) then cur_val:=mult_integers(eqtb[l].int,cur_val)
    else cur_val:=nx_plus_y(eqtb[l].int,cur_val,0)
  else cur_val:=x_over_n(eqtb[l].int,cur_val)
else  begin s:=equiv(l); r:=new_spec(s);
  if q=multiply then
    begin width(r):=nx_plus_y(width(s),cur_val,0);
    stretch(r):=nx_plus_y(stretch(s),cur_val,0);
    shrink(r):=nx_plus_y(shrink(s),cur_val,0);
    end
  else  begin width(r):=x_over_n(width(s),cur_val);
    stretch(r):=x_over_n(stretch(s),cur_val);
    shrink(r):=x_over_n(shrink(s),cur_val);
    end;
  cur_val:=r;
  end;
end

@ The processing of boxes is somewhat different, because we may need
to scan and create an entire box before we actually change the value of the old
one.

@<Assignments@>=
set_box: begin scan_register_num;
  if global then n:=global_box_flag+cur_val@+else n:=box_flag+cur_val;
  scan_optional_equals;
  if set_box_allowed then scan_box(n)
  else begin print_err('Improper '); print_esc("setbox");
@.Improper \\setbox@>
    help2('Sorry, \setbox is not allowed after \halign in a display,',
    'or between \accent and an accented character.'); error;
    end;
  end;

@ The |space_factor| or |prev_depth| settings are changed when a |set_aux|
command is sensed. Similarly, |prev_graf| is changed in the presence of
|set_prev_graf|, and |dead_cycles| or |insert_penalties| in the presence of
|set_page_int|. These definitions are always global.

When some dimension of a box register is changed, the change isn't exactly
global; but \TeX\ does not look at the \.{\\global} switch.

@<Assignments@>=
set_aux:alter_aux;
set_prev_graf:alter_prev_graf;
set_page_dimen:alter_page_so_far;
set_page_int:alter_integer;
set_box_dimen:alter_box_dimen;

@ @<Declare subprocedures for |prefixed_command|@>=
procedure alter_aux;
var c:halfword; {|hmode| or |vmode|}
begin if cur_chr<>abs(mode) then report_illegal_case
else  begin c:=cur_chr; scan_optional_equals;
  if c=vmode then
    begin scan_normal_dimen; prev_depth:=cur_val;
    end
  else  begin scan_int;
    if (cur_val<=0)or(cur_val>32767) then
      begin print_err('Bad space factor');
@.Bad space factor@>
      help1('I allow only values in the range 1..32767 here.');
      int_error(cur_val);
      end
    else space_factor:=cur_val;
    end;
  end;
end;

@ @<Declare subprocedures for |prefixed_command|@>=
procedure alter_prev_graf;
var p:0..nest_size; {index into |nest|}
begin nest[nest_ptr]:=cur_list; p:=nest_ptr;
while abs(nest[p].mode_field)<>vmode do decr(p);
scan_optional_equals; scan_int;
if cur_val<0 then
  begin print_err('Bad '); print_esc("prevgraf");
@.Bad \\prevgraf@>
  help1('I allow only nonnegative values here.');
  int_error(cur_val);
  end
else  begin nest[p].pg_field:=cur_val; cur_list:=nest[nest_ptr];
  end;
end;

@ @<Declare subprocedures for |prefixed_command|@>=
procedure alter_page_so_far;
var c:0..7; {index into |page_so_far|}
begin c:=cur_chr; scan_optional_equals; scan_normal_dimen;
page_so_far[c]:=cur_val;
end;

@ @<Declare subprocedures for |prefixed_command|@>=
procedure alter_integer;
var c:small_number;
  {0 for \.{\\deadcycles}, 1 for \.{\\insertpenalties}, etc.}
begin c:=cur_chr; scan_optional_equals; scan_int;
if c=0 then dead_cycles:=cur_val
@/@<Cases for |alter_integer|@>@/
else insert_penalties:=cur_val;
end;

@ @<Declare subprocedures for |prefixed_command|@>=
procedure alter_box_dimen;
var c:small_number; {|width_offset| or |height_offset| or |depth_offset|}
@!b:integer; {box number}
begin c:=cur_chr; scan_register_num; b:=cur_val; scan_optional_equals;
scan_normal_dimen;
if box(b)<>null then vmem(box(b)+c).sc:=cur_val;
end;

@ Paragraph shapes are set up in an obvious way. It needs one word more than in
\TeX, though.

@<Assignments@>=
set_tex_shape: begin q:=cur_chr; scan_optional_equals; scan_int; n:=cur_val;
  if n<=0 then p:=null
  else begin p:=new_node(shape_node,2*(n+1)+1); vinfo(p+1):=n;
    for j:=1 to n do
      begin scan_normal_dimen;
      vmem(p+2*j).sc:=cur_val; {indentation}
      scan_normal_dimen;
      vmem(p+2*j+1).sc:=cur_val; {width}
      end;
    end;
  define(q,shape_ref,p);
  end;
set_etex_shape: begin q:=cur_chr; scan_optional_equals; scan_int; n:=cur_val;
  if n<=0 then p:=null
  else begin n:=(cur_val div 2)+1; p:=new_node(shape_node,2*n+1+1); vinfo(p+1):=n;
    n:=cur_val; vmem(p+2).int:=n; {number of penalties}
    for j:=p+3 to p+n+2 do
      begin scan_int; vmem(j).int:=cur_val; {penalty values}
      end;
    if not odd(n) then vmem(p+n+3).int:=0; {unused}
    end;
  define(q,shape_ref,p);
  end;

@ New language information data is loaded by the |hyph_data| command.

@<Put each...@>=
primitive_tex("hyphenation",hyph_data,0,0);
@!@:hyphenation_}{\.{\\hyphenation} primitive@>
primitive_tex("patterns",hyph_data,1,0);
@!@:patterns_}{\.{\\patterns} primitive@>
primitive_luatex("prehyphenchar",hyph_data,2,0);
@!@:prehyphenchar_}{\.{\\prehyphenchar} primitive@>
primitive_luatex("posthyphenchar",hyph_data,3,0);
@!@:posthyphenchar_}{\.{\\posthyphenchar} primitive@>
primitive_luatex("preexhyphenchar",hyph_data,4,0);
@!@:preexhyphenchar_}{\.{\\preexhyphenchar} primitive@>
primitive_luatex("postexhyphenchar",hyph_data,5,0);
@!@:postexhyphenchar_}{\.{\\postexhyphenchar} primitive@>

@ @<Assignments@>=
hyph_data: begin
   case cur_chr of
    0: new_hyph_exceptions;
    1: new_patterns;
    2: new_pre_hyphen_char;
    3: new_post_hyphen_char;
    4: new_pre_exhyphen_char;
    5: new_post_exhyphen_char;
    endcases;
  goto done;
  end;

@ All of \TeX's parameters are kept in |eqtb| except the font information,
the interaction mode, and the hyphenation tables; these are strictly global.

@<Assignments@>=
assign_font_dimen: set_font_dimen;
assign_font_int: begin
  n:=cur_chr; scan_font_ident; f:=cur_val;
  if n = no_lig_code then set_no_ligatures(f)
  else if n < lp_code_base then begin
    scan_optional_equals; scan_int;
    if n=0 then set_hyphen_char(f,cur_val)@+else set_skew_char(f,cur_val);
  end
  else begin
    scan_char_num; p := cur_val;
    scan_optional_equals; scan_int;
    case n of
    lp_code_base: set_lp_code(f, p, cur_val);
    rp_code_base: set_rp_code(f, p, cur_val);
    ef_code_base: set_ef_code(f, p, cur_val);
    tag_code:     set_tag_code(f, p, cur_val);
    end;
  end;
end;

@ @<Put each...@>=
primitive_tex("hyphenchar",assign_font_int,0,0);
@!@:hyphen_char_}{\.{\\hyphenchar} primitive@>
primitive_tex("skewchar",assign_font_int,1,0);
@!@:skew_char_}{\.{\\skewchar} primitive@>
primitive_pdftex("lpcode",assign_font_int,lp_code_base,0);
@!@:lp_code_}{\.{\\lpcode} primitive@>
primitive_pdftex("rpcode",assign_font_int,rp_code_base,0);
@!@:rp_code_}{\.{\\rpcode} primitive@>
primitive_pdftex("efcode",assign_font_int,ef_code_base,0);
@!@:ef_code_}{\.{\\efcode} primitive@>
primitive_pdftex("tagcode",assign_font_int,tag_code,0);
@!@:tag_code_}{\.{\\tagcode} primitive@>
primitive_pdftex("pdfnoligatures",assign_font_int,no_lig_code,0);
@!@:no_lig_code_}{\.{\\pdfnoligatures} primitive@>

@ Here is where the information for a new font gets loaded.

@<Assignments@>=
def_font: tex_def_font(a); {in C}
letterspace_font: new_letterspaced_font(a);
pdf_copy_font: make_font_copy(a);

@ @<Put each...@>=
primitive_tex("batchmode",set_interaction,batch_mode,0);
@!@:batch_mode_}{\.{\\batchmode} primitive@>
primitive_tex("nonstopmode",set_interaction,nonstop_mode,0);
@!@:nonstop_mode_}{\.{\\nonstopmode} primitive@>
primitive_tex("scrollmode",set_interaction,scroll_mode,0);
@!@:scroll_mode_}{\.{\\scrollmode} primitive@>
primitive_tex("errorstopmode",set_interaction,error_stop_mode,0);
@!@:error_stop_mode_}{\.{\\errorstopmode} primitive@>

@ @<Assignments@>=
set_interaction: new_interaction;

@ @<Declare subprocedures for |prefixed_command|@>=
procedure new_interaction;
begin print_ln;
interaction:=cur_chr;
fixup_selector(log_opened);
end;

@ The \.{\\afterassignment} command puts a token into the global
variable |after_token|. This global variable is examined just after
every assignment has been performed.

@<Glob...@>=
@!after_token:halfword; {zero, or a saved token}

@ @<Set init...@>=
after_token:=0;

@ @<Cases of |main_control| that don't...@>=
any_mode(after_assignment):begin get_token; after_token:=cur_tok;
  end;

@ @<Insert a token saved by \.{\\afterassignment}, if any@>=
if after_token<>0 then
  begin cur_tok:=after_token; back_input; after_token:=0;
  end

@ Here is a procedure that might be called `Get the next non-blank non-relax
non-call non-assignment token'.

@<Declare act...@>=
procedure do_assignments;
label exit;
begin loop begin @<Get the next non-blank non-relax...@>;
  if cur_cmd<=max_non_prefixed_command then return;
  set_box_allowed:=false; prefixed_command; set_box_allowed:=true;
  end;
exit:end;

@ @<Cases of |main_control| that don't...@>=
any_mode(after_group):begin get_token; save_for_after(cur_tok);
  end;

@ Files for \.{\\read} are opened and closed by the |in_stream| command.

@<Put each...@>=
primitive_tex("openin",in_stream,1,0);
@!@:open_in_}{\.{\\openin} primitive@>
primitive_tex("closein",in_stream,0,0);
@!@:close_in_}{\.{\\closein} primitive@>

@ @<Cases of |main_control| that don't...@>=
any_mode(in_stream): open_or_close_in;

@ @<Declare act...@>=
procedure open_or_close_in;
var c:0..1; {1 for \.{\\openin}, 0 for \.{\\closein}}
@!n:0..15; {stream number}
begin c:=cur_chr; scan_four_bit_int; n:=cur_val;
if read_open[n]<>closed then
  begin lua_a_close_in(read_file[n],(n+1)); read_open[n]:=closed;
  end;
if c<>0 then
  begin scan_optional_equals; scan_file_name;
  if cur_ext="" then cur_ext:=".tex";
  pack_cur_name;
  if lua_a_open_in(read_file[n],(n+1)) then begin
     read_file[n]:= name_file_pointer;
     read_open[n]:=just_open;
     end;
  end;
end;

@ The user can issue messages to the terminal, regardless of the
current mode.

@<Cases of |main_control| that don't...@>=
any_mode(message):issue_message;

@ @<Put each...@>=
primitive_tex("message",message,0,0);
@!@:message_}{\.{\\message} primitive@>
primitive_tex("errmessage",message,1,0);
@!@:err_message_}{\.{\\errmessage} primitive@>

@ @<Declare act...@>=
procedure issue_message;
var old_setting:0..max_selector; {holds |selector| setting}
junk:pointer;
@!c:0..1; {identifies \.{\\message} and \.{\\errmessage}}
@!s:str_number; {the message}
begin c:=cur_chr; junk:=scan_toks(false,true);
old_setting:=selector; selector:=new_string;
token_show(def_ref); selector:=old_setting;
flush_list(def_ref);
str_room(1); s:=make_string;
if c=0 then @<Print string |s| on the terminal@>
else @<Print string |s| as an error message@>;
flush_string;
end;

@ @<Print string |s| on the terminal@>=
begin if term_offset+length(s)>max_print_line-2 then print_ln
else if (term_offset>0)or(file_offset>0) then print_char(" ");
slow_print(s); update_terminal;
end

@ If \.{\\errmessage} occurs often in |scroll_mode|, without user-defined
\.{\\errhelp}, we don't want to give a long help message each time. So we
give a verbose explanation only once.

@<Glob...@>=
@!long_help_seen:boolean; {has the long \.{\\errmessage} help been used?}

@ @<Set init...@>=long_help_seen:=false;

@ @<Print string |s| as an error message@>=
begin print_err(''); slow_print(s);
if err_help<>null then use_err_help:=true
else if long_help_seen then help1('(That was another \errmessage.)')
else  begin if interaction<error_stop_mode then long_help_seen:=true;
  help4('This error message was generated by an \errmessage',
  'command, so I can''t give any explicit help.',
  'Pretend that you''re Hercule Poirot: Examine all clues,',
  'and deduce the truth by order and method.');
@^Poirot, Hercule@>
  end;
error; use_err_help:=false;
end

@ The |error| routine calls on |give_err_help| if help is requested from
the |err_help| parameter.

@p procedure give_err_help;
begin token_show(err_help);
end;

@ The \.{\\uppercase} and \.{\\lowercase} commands are implemented by
building a token list and then changing the cases of the letters in it.

@<Cases of |main_control| that don't...@>=
any_mode(case_shift):shift_case;

@ @<Put each...@>=
primitive_tex("lowercase",case_shift,lc_code_base,lc_code_base);
@!@:lowercase_}{\.{\\lowercase} primitive@>
primitive_tex("uppercase",case_shift,uc_code_base,lc_code_base);
@!@:uppercase_}{\.{\\uppercase} primitive@>

@ @<Declare act...@>=
procedure shift_case;
var b:pointer; {|lc_code_base| or |uc_code_base|}
@!p:pointer; {runs through the token list}
@!t:halfword; {token}
@!c:halfword; {character code}
@!i:halfword; {inbetween}
begin b:=cur_chr; p:=scan_toks(false,false); p:=link(def_ref);
while p<>null do
  begin @<Change the case of the token in |p|, if a change is appropriate@>;
  p:=link(p);
  end;
back_list(link(def_ref)); free_avail(def_ref); {omit reference count}
end;

@ When the case of a |chr_code| changes, we don't change the |cmd|.
We also change active characters.

@<Change the case of the token in |p|, if a change is appropriate@>=
t:=info(p);
if t<cs_token_flag then begin
  c:=t mod string_offset;
  if b=uc_code_base then
    i:=get_uc_code(c)
  else
    i:=get_lc_code(c);
  if i<>0 then set_token_info(p,t-c+i);
  end
else if is_active_cs(text(t-cs_token_flag)) then begin
  c:=active_cs_value(text(t-cs_token_flag));
  if b=uc_code_base then
     i:=get_uc_code(c)
  else
     i:= get_lc_code(c);
  if i<>0 then set_token_info(p,active_to_cs(i,true)+cs_token_flag);
end

@ We come finally to the last pieces missing from |main_control|, namely the
`\.{\\show}' commands that are useful when debugging.

@<Cases of |main_control| that don't...@>=
any_mode(xray): show_whatever;

@ @d show_code=0 { \.{\\show} }
@d show_box_code=1 { \.{\\showbox} }
@d show_the_code=2 { \.{\\showthe} }
@d show_lists=3 { \.{\\showlists} }

@<Put each...@>=
primitive_tex("show",xray,show_code,0);
@!@:show_}{\.{\\show} primitive@>
primitive_tex("showbox",xray,show_box_code,0);
@!@:show_box_}{\.{\\showbox} primitive@>
primitive_tex("showthe",xray,show_the_code,0);
@!@:show_the_}{\.{\\showthe} primitive@>
primitive_tex("showlists",xray,show_lists,0);
@!@:show_lists_}{\.{\\showlists} primitive@>

@ @<Declare act...@>=
procedure show_whatever;
label common_ending;
var p:pointer; {tail of a token list to show}
@!t:small_number; {type of conditional being shown}
@!m:normal..or_code; {upper bound on |fi_or_else| codes}
@!l:integer; {line where that conditional began}
@!n:integer; {level of \.{\\if...\\fi} nesting}
begin case cur_chr of
show_lists: begin begin_diagnostic; show_activities;
  end;
show_box_code: @<Show the current contents of a box@>;
show_code: @<Show the current meaning of a token, then |goto common_ending|@>;
@<Cases for |show_whatever|@>@;@/
othercases @<Show the current value of some parameter or register,
  then |goto common_ending|@>
endcases;@/
@<Complete a potentially long \.{\\show} command@>;
common_ending: if interaction<error_stop_mode then
  begin help0; decr(error_count);
  end
else if tracing_online>0 then
  begin@t@>@;@/
  help3('This isn''t an error message; I''m just \showing something.',
  'Type `I\show...'' to show more (e.g., \show\cs,',
  '\showthe\count10, \showbox255, \showlists).');
  end
else  begin@t@>@;@/
  help5('This isn''t an error message; I''m just \showing something.',
  'Type `I\show...'' to show more (e.g., \show\cs,',
  '\showthe\count10, \showbox255, \showlists).',
  'And type `I\tracingonline=1\show...'' to show boxes and',
  'lists on your terminal as well as in the transcript file.');
  end;
error;
end;

@ @<Show the current meaning of a token...@>=
begin get_token;
if interaction=error_stop_mode then wake_up_terminal;
print_nl("> ");
if cur_cs<>0 then
  begin sprint_cs(cur_cs); print_char("=");
  end;
print_meaning; goto common_ending;
end

@ @<Show the current contents of a box@>=
begin scan_register_num; begin_diagnostic;
print_nl("> \box"); print_int(cur_val); print_char("=");
if box(cur_val)=null then print("void")
else show_box(box(cur_val));
end

@ @<Show the current value of some parameter...@>=
begin p:=the_toks;
if interaction=error_stop_mode then wake_up_terminal;
print_nl("> "); token_show(temp_token_head);
flush_list(link(temp_token_head)); goto common_ending;
end

@ @<Complete a potentially long \.{\\show} command@>=
end_diagnostic(true); print_err('OK');
@.OK@>
if selector=term_and_log then if tracing_online<=0 then
  begin selector:=term_only; print(" (see the transcript file)");
  selector:=term_and_log;
  end

@* \[50] Dumping and undumping the tables.
After \.{INITEX} has seen a collection of fonts and macros, it
can write all the necessary information on an auxiliary file so
that production versions of \TeX\ are able to initialize their
memory at high speed. The present section of the program takes
care of such output and input. We shall consider simultaneously
the processes of storing and restoring,
so that the inverse relation between them is clear.
@.INITEX@>

The global variable |format_ident| is a string that is printed right
after the |banner| line when \TeX\ is ready to start. For \.{INITEX} this
string says simply `\.{(INITEX)}'; for other versions of \TeX\ it says,
for example, `\.{(preloaded format=plain 1982.11.19)}', showing the year,
month, and day that the format file was created. We have |format_ident=0|
before \TeX's tables are loaded.

@<Glob...@>=
@!format_ident:str_number;
@!format_name:str_number; {principal file name}

@ @<Set init...@>=
format_ident:=0;
format_name:="";

@ @<Initialize table entries...@>=
format_ident:=" (INITEX)";

@ @<Declare act...@>=
@!init procedure store_fmt_file;
label found1,found2,done1,done2;
var j,@!k,@!l:integer; {all-purpose indices}
@!p: pointer; {all-purpose pointer}
@!x: integer; {something to dump}
@!w: four_quarters; {four ASCII codes}
begin @<If dumping is not allowed, abort@>;
@<Create the |format_ident|, open the format file,
  and inform the user that dumping has begun@>;
@<Dump constants for consistency check@>;
@<Dump the string pool@>;
@<Dump the dynamic memory@>;
@<Dump the table of equivalents@>;
@<Dump the font information@>;
@<Dump the ocp information@>;
@<Dump the hyphenation tables@>;
@<Dump pdftex data@>;
@<Dump a couple more things and the closing check word@>;
@<Dump the lua bytecodes@>;
@<Close the format file@>;
end;
tini

@ Corresponding to the procedure that dumps a format file, we have a function
that reads one in. The function returns |false| if the dumped format is
incompatible with the present \TeX\ table sizes, etc.

@d bad_fmt=6666 {go here if the format file is unacceptable}
@d too_small(#)==begin wake_up_terminal;
  wterm_cr;
  fprintf(term_out,'---! Must increase the %s',#);
@.Must increase the x@>
  goto bad_fmt;
  end

@p 
function load_fmt_file:boolean;
label bad_fmt,exit;
var j,@!k:integer; {all-purpose indices}
@!p: pointer; {all-purpose pointer}
@!x: integer; {something undumped}
@!w: four_quarters; {four ASCII codes}
begin @<Undump constants for consistency check@>;
@<Undump the string pool@>;
@<Undump the dynamic memory@>;
@<Undump the table of equivalents@>;
@<Undump the font information@>;
@<Undump the ocp information@>;
@<Undump the hyphenation tables@>;
@<Undump pdftex data@>;
@<Undump a couple more things and the closing check word@>;
@<Undump the lua bytecodes@>;
prev_depth := pdf_ignored_dimen;
load_fmt_file:=true; return; {it worked!}
bad_fmt: wake_up_terminal;
  wterm_cr;
  fprintf(term_out, '(Fatal format file error; I''m stymied)');
@.Fatal format file error@>
load_fmt_file:=false;
exit:end;

@ The user is not allowed to dump a format file unless |save_ptr=0|.
This condition implies that |cur_level=level_one|, hence
the |xeq_level| array is constant and it need not be dumped.

@<If dumping is not allowed, abort@>=
if save_ptr<>0 then
  begin print_err('You can''t dump inside a group');
@.You can't dump...@>
  help1('`{...\dump}'' is a no-no.'); succumb;
  end

@ Format files consist of |memory_word| items, and we use the following
macros to dump words of different types:

@d dump_wd(#)==begin fmt_file^:=#; put(fmt_file);@+end
@d dump_int(#)==begin fmt_file^.int:=#; put(fmt_file);@+end
@d dump_hh(#)==begin fmt_file^.hh:=#; put(fmt_file);@+end
@d dump_qqqq(#)==begin fmt_file^.qqqq:=#; put(fmt_file);@+end

@<Glob...@>=
@!fmt_file:word_file; {for input or output of format information}

@ The inverse macros are slightly more complicated, since we need to check
the range of the values we are reading in. We say `|undump(a)(b)(x)|' to
read an integer value |x| that is supposed to be in the range |a<=x<=b|.

@d undump_wd(#)==begin get(fmt_file); #:=fmt_file^;@+end
@d undump_int(#)==begin get(fmt_file); #:=fmt_file^.int;@+end
@d undump_hh(#)==begin get(fmt_file); #:=fmt_file^.hh;@+end
@d undump_qqqq(#)==begin get(fmt_file); #:=fmt_file^.qqqq;@+end
@d undump_end_end(#)==#:=x;@+end
@d undump_end(#)==(x>#) then goto bad_fmt@+else undump_end_end
@d undump(#)==begin undump_int(x); if (x<#) or undump_end
@d undump_size_end_end(#)==too_small(#)@+else undump_end_end
@d undump_size_end(#)==if x># then undump_size_end_end
@d undump_size(#)==begin undump_int(x);
  if x<# then goto bad_fmt; undump_size_end

@ The next few sections of the program should make it clear how we use the
dump/undump macros.

@<Dump constants for consistency check@>=
dump_int(@$);@/
dump_int(eqtb_size);@/
dump_int(hash_prime)

@ Sections of a \.{WEB} program that are ``commented out'' still contribute
strings to the string pool; therefore \.{INITEX} and \TeX\ will have
the same strings. (And it is, of course, a good thing that they do.)
@.WEB@>
@^string pool@>

@<Undump constants for consistency check@>=
x:=fmt_file^.int;
if x<>@$ then goto bad_fmt; {check that strings are the same}
undump_int(x);@/
if x<>eqtb_size then goto bad_fmt;
undump_int(x);
if x<>hash_prime then goto bad_fmt

@ @d dump_four_ASCII==
  w.b0:=qi(str_pool[k]); w.b1:=qi(str_pool[k+1]);
  w.b2:=qi(str_pool[k+2]); w.b3:=qi(str_pool[k+3]);
  dump_qqqq(w)

@<Dump the string pool@>=
dump_int(pool_ptr);
dump_int(str_ptr);
for k:=string_offset to str_ptr do dump_int(str_start_macro(k));
k:=0;
while k+4<pool_ptr do
  begin dump_four_ASCII; k:=k+4;
  end;
k:=pool_ptr-4; dump_four_ASCII;
print_ln; print_int(str_ptr-string_offset); print(" strings of total length ");
print_int(pool_ptr)

@ @d undump_four_ASCII==
  undump_qqqq(w);
  str_pool[k]:=qo(w.b0); str_pool[k+1]:=qo(w.b1);
  str_pool[k+2]:=qo(w.b2); str_pool[k+3]:=qo(w.b3)

@<Undump the string pool@>=
undump_size(0)(pool_size)('string pool size')(pool_ptr);
undump_size(0)(max_strings)('max strings')(str_ptr);
for k:=string_offset to str_ptr do undump(0)(pool_ptr)(str_start_macro(k));
k:=0;
while k+4<pool_ptr do
  begin undump_four_ASCII; k:=k+4;
  end;
k:=pool_ptr-4; undump_four_ASCII;
init_str_ptr:=str_ptr; init_pool_ptr:=pool_ptr

@ By sorting the list of available spaces in the variable-size portion of
|mem|, we are usually able to get by without having to dump very much
of the dynamic memory.

We recompute |var_used| and |dyn_used|, so that \.{INITEX} dumps valid
information even when it has not been gathering statistics.

@<Dump the dynamic memory@>=
dump_node_mem;
@#
dump_int(temp_token_head); dump_int(hold_token_head);
dump_int(omit_template); dump_int(null_list);
dump_int(backup_head); dump_int(garbage);
dump_int(fix_mem_min); dump_int(fix_mem_max);
dump_int(fix_mem_end);
dump_int(avail);
dyn_used:=fix_mem_end+1;
for k:=fix_mem_min to fix_mem_end do dump_wd(fixmem[k]);
x:=x+(fix_mem_end+1-fix_mem_min);
p:=avail;
while p<>null do
  begin decr(dyn_used); p:=link(p);
  end;
dump_int(dyn_used);
print_ln; print_int(x);
print(" memory locations dumped; current usage is ");
print_int(var_used); print_char("&"); print_int(dyn_used)

@ @<Undump the dynamic memory@>=
undump_node_mem;
@#
undump_int(temp_token_head); undump_int(hold_token_head);
undump_int(omit_template); undump_int(null_list);
undump_int(backup_head); undump_int(garbage);
undump_int(fix_mem_min);undump_int(fix_mem_max);
fixmem:= xmallocarray (smemory_word, fix_mem_max+1);
memset (voidcast(fixmem),0,(fix_mem_max+1)*sizeof(smemory_word));
undump_int(fix_mem_end);
undump_int(avail);
for k:=fix_mem_min to fix_mem_end do undump_wd(fixmem[k]);
undump_int(dyn_used)

@ @<Dump the table of equivalents@>=
@<Dump regions 1 to 4 of |eqtb|@>;
@<Dump regions 5 and 6 of |eqtb|@>;
dump_int(par_loc); dump_int(write_loc);@/
dump_math_codes;
dump_text_codes;
@<Dump the hash table@>

@ @<Undump the table of equivalents@>=
@<Undump regions 1 to 6 of |eqtb|@>;
undump(hash_base)(frozen_control_sequence)(par_loc);
par_token:=cs_token_flag+par_loc;@/
undump(hash_base)(frozen_control_sequence)(write_loc);@/
undump_math_codes;
undump_text_codes;
@<Undump the hash table@>

@ The table of equivalents usually contains repeated information, so we dump it
in compressed form: The sequence of $n+2$ values $(n,x_1,\ldots,x_n,m)$ in the
format file represents $n+m$ consecutive entries of |eqtb|, with |m| extra
copies of $x_n$, namely $(x_1,\ldots,x_n,x_n,\ldots,x_n)$.

@<Dump regions 1 to 4 of |eqtb|@>=
k:=null_cs;
repeat j:=k;
while j<int_base-1 do
  begin if (equiv(j)=equiv(j+1))and(eq_type(j)=eq_type(j+1))and@|
    (eq_level(j)=eq_level(j+1)) then goto found1;
  incr(j);
  end;
l:=int_base; goto done1; {|j=int_base-1|}
found1: incr(j); l:=j;
while j<int_base-1 do
  begin if (equiv(j)<>equiv(j+1))or(eq_type(j)<>eq_type(j+1))or@|
    (eq_level(j)<>eq_level(j+1)) then goto done1;
  incr(j);
  end;
done1:
dump_int(l-k);
while k<l do
  begin dump_wd(eqtb[k]); incr(k);
  end;
k:=j+1; dump_int(k-l);
until k=int_base

@ @<Dump regions 5 and 6 of |eqtb|@>=
repeat j:=k;
while j<eqtb_size do
  begin if eqtb[j].int=eqtb[j+1].int then goto found2;
  incr(j);
  end;
l:=eqtb_size+1; goto done2; {|j=eqtb_size|}
found2: incr(j); l:=j;
while j<eqtb_size do
  begin if eqtb[j].int<>eqtb[j+1].int then goto done2;
  incr(j);
  end;
done2:dump_int(l-k);
while k<l do
  begin dump_wd(eqtb[k]); incr(k);
  end;
k:=j+1; dump_int(k-l);
until k>eqtb_size

@ @<Undump regions 1 to 6 of |eqtb|@>=
k:=null_cs;
repeat undump_int(x);
if (x<1)or(k+x>eqtb_size+1) then goto bad_fmt;
for j:=k to k+x-1 do undump_wd(eqtb[j]);
k:=k+x;
undump_int(x);
if (x<0)or(k+x>eqtb_size+1) then goto bad_fmt;
for j:=k to k+x-1 do eqtb[j]:=eqtb[k-1];
k:=k+x;
until k>eqtb_size

@ A different scheme is used to compress the hash table, since its lower
region is usually sparse. When |text(p)<>0| for |p<=hash_used|, we output
two words, |p| and |hash[p]|. The hash table is, of course, densely packed
for |p>=hash_used|, so the remaining entries are output in a~block.

@<Dump the hash table@>=
dump_primitives;
dump_int(hash_used); cs_count:=frozen_control_sequence-1-hash_used;
for p:=hash_base to hash_used do if text(p)<>0 then
  begin dump_int(p); dump_hh(hash[p]); incr(cs_count);
  end;
for p:=hash_used+1 to undefined_control_sequence-1 do dump_hh(hash[p]);
dump_int(cs_count);@/
print_ln; print_int(cs_count); print(" multiletter control sequences")

@ @<Undump the hash table@>=
undump_primitives;
undump(hash_base)(frozen_control_sequence)(hash_used); p:=hash_base-1;
repeat undump(p+1)(hash_used)(p); undump_hh(hash[p]);
until p=hash_used;
for p:=hash_used+1 to undefined_control_sequence-1 do undump_hh(hash[p]);
undump_int(cs_count)

@ @<Dump the font information@>=
dump_int(max_font_id);
for k:=0 to max_font_id do
  @<Dump the array info for internal font number |k|@>;
print_ln; print_int(max_font_id); print(" preloaded font");
if max_font_id<>1 then print_char("s");
dump_math_data

@ @<Undump the font information@>=
undump_int(x);
set_max_font_id(x);
for k:=0 to max_font_id do
  @<Undump the array info for internal font number |k|@>;
undump_math_data

@ @<Dump the array info for internal font number |k|@>=
begin dump_font(k);
print_nl("\font"); print_esc(font_id_text(k)); print_char("=");
print_file_name(tex_font_name(k),tex_font_area(k),"");
flush_string; flush_string;
if font_size(k)<>font_dsize(k) then
  begin print(" at "); print_scaled(font_size(k)); print("pt");
  end;
end

@ @<Undump the array info for internal font number |k|@>=
begin undump_font(k);@/
end

@ @<Dump the ocp information@>=
dump_active_ocp_info;
dump_ocp_info;
dump_ocplist_info;

@ @<Undump the ocp information@>=
undump_active_ocp_info;
undump_ocp_info;
undump_ocplist_info;

@ @<Dump the hyphenation tables@>=
dump_language_data

@ @<Undump the hyphenation tables@>=
undump_language_data

@ @<Dump pdftex data@>=
dump_pdftex_data(static_pdf)

@ @<Undump pdftex data@>=
undump_pdftex_data(static_pdf)

@ @<Dump the lua bytecodes@>=
dump_luac_registers;

@ @<Undump the lua bytecodes@>=
undump_luac_registers;

@ We have already printed a lot of statistics, so we set |tracing_stats:=0|
to prevent them from appearing again.

@<Dump a couple more things and the closing check word@>=
dump_int(interaction); dump_int(format_ident); dump_int(format_name); dump_int(69069);
tracing_stats:=0

@ @<Undump a couple more things and the closing check word@>=
undump(batch_mode)(error_stop_mode)(interaction);
undump(0)(str_ptr)(format_ident);
undump(0)(str_ptr)(format_name);
undump_int(x);
if (x<>69069)or eof(fmt_file) then goto bad_fmt

@ @<Create the |format_ident|...@>=
selector:=new_string;
print(" (preloaded format="); print(job_name); print_char(" ");
print_int(year); print_char(".");
print_int(month); print_char("."); print_int(day); print_char(")");
str_room(2);
format_ident:=make_string;
print(job_name);
format_name:=make_string;
if interaction=batch_mode then selector:=log_only
else selector:=term_and_log;
pack_job_name(format_extension);
while not w_open_out(fmt_file) do
  prompt_file_name('format file name',format_extension);
print_nl("Beginning to dump on file ");
@.Beginning to dump...@>
slow_print(w_make_name_string(fmt_file)); flush_string;
print_nl(""); slow_print(format_ident)

@ @<Close the format file@>=
w_close(fmt_file)

@* \[51] The main program.
This is it: the part of \TeX\ that executes all those procedures we have
written.

Well---almost. Let's leave space for a few more routines that we may
have forgotten.

@p @<Last-minute procedures@>

@ We have noted that there are two versions of \TeX82. One, called \.{INITEX},
@.INITEX@>
has to be run first; it initializes everything from scratch, without
reading a format file, and it has the capability of dumping a format file.
The other one is called `\.{VIRTEX}'; it is a ``virgin'' program that needs
@.VIRTEX@>
to input a format file in order to get started. \.{VIRTEX} typically has
more memory capacity than \.{INITEX}, because it does not need the space
consumed by the auxiliary hyphenation tables and the numerous calls on
|primitive|, etc.

The \.{VIRTEX} program cannot read a format file instantaneously, of course;
the best implementations therefore allow for production versions of \TeX\ that
not only avoid the loading routine for \PASCAL\ object code, they also have
a format file pre-loaded. This is impossible to do if we stick to standard
\PASCAL; but there is a simple way to fool many systems into avoiding the
initialization, as follows:\quad(1)~We declare a global integer variable
called |ready_already|. The probability is negligible that this
variable holds any particular value like 314159 when \.{VIRTEX} is first
loaded.\quad(2)~After we have read in a format file and initialized
everything, we set |ready_already:=314159|.\quad(3)~Soon \.{VIRTEX}
will print `\.*', waiting for more input; and at this point we
interrupt the program and save its core image in some form that the
operating system can reload speedily.\quad(4)~When that core image is
activated, the program starts again at the beginning; but now
|ready_already=314159| and all the other global variables have
their initial values too. The former chastity has vanished!

In other words, if we allow ourselves to test the condition
|ready_already=314159|, before |ready_already| has been
assigned a value, we can avoid the lengthy initialization. Dirty tricks
rarely pay off so handsomely.
@^dirty \PASCAL@>
@^system dependencies@>

On systems that allow such preloading, the standard program called \.{TeX}
should be the one that has \.{plain} format preloaded, since that agrees
with {\sl The \TeX book}. Other versions, e.g., \.{AmSTeX}, should also
@:TeXbook}{\sl The \TeX book@>
@.AmSTeX@>
@.plain@>
be provided for commonly used formats.

@<Glob...@>=
@!ready_already:integer; {a sacrifice of purity for economy}

@ Now this is really it: \TeX\ starts and ends here.

The initial test involving |ready_already| should be deleted if the
\PASCAL\ runtime system is smart enough to detect such a ``mistake.''
@^system dependencies@>

@p begin @!{|start_here|}
history:=fatal_error_stop; {in case we quit during initialization}
t_open_out; {open the terminal for output}
if ready_already=314159 then goto start_of_TEX;
@<Check the ``constant'' values...@>@;
if bad>0 then
  begin wterm_cr;
  fprintf(term_out,'Ouch---my internal constants have been clobbered! ---case %d',bad:1);
@.Ouch...clobbered@>
  goto final_end;
  end;
initialize; {set global variables to their starting values}
@!init if not get_strings_started then goto final_end;
init_prim; {call |primitive| for each primitive}
init_str_ptr:=str_ptr; init_pool_ptr:=pool_ptr; fix_date_and_time;
tini@/
ready_already:=314159;
start_of_TEX: print_banner(luatex_version_string,extra_version_info);
@<Get the first line of input and prepare to start@>;
history:=spotless; {ready to go!}
@<Initialize synctex primitive@>
main_control; {come to life}
final_cleanup; {prepare for death}
end_of_TEX: close_files_and_terminate;
final_end: ready_already:=0;
end.

@ Here we do whatever is needed to complete \TeX's job gracefully on the
local operating system. The code here might come into play after a fatal
error; it must therefore consist entirely of ``safe'' operations that
cannot produce error messages. For example, it would be a mistake to call
|str_room| or |make_string| at this time, because a call on |overflow|
might lead to an infinite loop.
@^system dependencies@>

Actually there's one way to get error messages, via |prepare_mag|;
but that can't cause infinite recursion.
@^recursion@>

This program doesn't bother to close the input files that may still be open.

@<Last-minute...@>=
procedure close_files_and_terminate;
label done, done1;
var k: integer; {all-purpose index}
    callback_id:integer;
begin
callback_id:=callback_defined(stop_run_callback);
@<Finish the extensions@>;
@!stat if tracing_stats>0 then
  if callback_id=0 then @<Output statistics about this job@>;@;@+tats@/
wake_up_terminal;
if not fixed_pdfoutput_set then {else there will be an infinite loop in error case}
    fix_pdfoutput;
if fixed_pdfoutput > 0 then begin
    if history = fatal_error_stop then begin
        remove_pdffile(static_pdf);
        print_err(' ==> Fatal error occurred, no output PDF file produced!')
    end
    else begin
	finish_pdf_file(static_pdf, luatex_version, luatex_revision);
    end;
end
else begin
    finish_dvi_file(luatex_version, luatex_revision);
end;
@<Close {\sl Sync\TeX} file and write status@>;
free_text_codes;
free_math_codes;
if log_opened then
  begin wlog_cr; selector:=selector-2;
  if (selector=term_only)and(callback_id=0) then begin
     print_nl("Transcript written on ");
@.Transcript written...@>
     slow_print(texmf_log_name); print_char(".");
     print_ln;
    end;
  lua_a_close_out(log_file);
  end;
end;

@ The present section goes directly to the log file instead of using
|print| commands, because there's no need for these strings to take
up |str_pool| memory when a non-{\bf stat} version of \TeX\ is being used.

@<Output statistics...@>=
if log_opened then
  begin wlog_cr;
  fprintf(log_file, '  ');
  wlog_cr;
  fprintf(log_file, 'Here is how much of TeX''s memory you used:');
@.Here is how much...@>
  wlog_cr;
  fprintf(log_file, ' %d ', str_ptr-init_str_ptr);
  if str_ptr<>init_str_ptr+1 then fprintf(log_file, 'strings') 
  else fprintf(log_file, 'string');
  fprintf(log_file, ' out of %ld', max_strings-init_str_ptr+string_offset:1);@/
  wlog_cr;
  fprintf(log_file, ' %d string characters out of %d',pool_ptr-init_pool_ptr,
    pool_size-init_pool_ptr);@/
  wlog_cr;
  fprintf(log_file,  ' %d,%d words of node,token memory allocated', var_mem_max,fix_mem_max);
  print_node_mem_stats;
  wlog_cr;
  fprintf(log_file, ' %d multiletter control sequences out of %ld+%d',cs_count:1,
	hash_size:1, hash_extra:1);@/
  wlog_cr;
  fprintf(log_file,' %d ', max_font_id);
  if max_font_id<>1 then fprintf(log_file, 'fonts')
  else  fprintf(log_file, 'font');
  wlog_cr;
  fprintf(log_file,' using %d bytes', font_bytes);
  wlog_cr;
  fprintf(log_file,' %di,%dn,%dp,%db,%ds stack positions out of %di,%dn,%dp,%db,%ds',
  	max_in_stack,max_nest_stack,max_param_stack,max_buf_stack, max_save_stack+6,
	stack_size, nest_size,param_size,buf_size,save_size);
  end

@ We get to the |final_cleanup| routine when \.{\\end} or \.{\\dump} has
been scanned and |its_all_over|\kern-2pt.

@<Last-minute...@>=
procedure final_cleanup;
label exit;
var c:small_number; {0 for \.{\\end}, 1 for \.{\\dump}}
i:halfword; { for looping marks }
begin c:=cur_chr;
if job_name=0 then open_log_file;
while input_ptr>0 do
  if istate=token_list then end_token_list@+else end_file_reading;
while open_parens>0 do
  begin
        if tracefilenames then print(" )");
        decr(open_parens);
  end;
if cur_level>level_one then
  begin print_nl("("); print_esc("end occurred ");
  print("inside a group at level ");
@:end_}{\.{(\\end occurred...)}@>
  print_int(cur_level-level_one); print_char(")");
  show_save_groups;
  end;
while cond_ptr<>null do
  begin print_nl("("); print_esc("end occurred ");
  print("when "); print_cmd_chr(if_test,cur_if);
  if if_line<>0 then
    begin print(" on line "); print_int(if_line);
    end;
  print(" was incomplete)");
  if_line:=if_line_field(cond_ptr);
  cur_if:=subtype(cond_ptr); temp_ptr:=cond_ptr;
  cond_ptr:=vlink(cond_ptr); flush_node(temp_ptr);
  end;
if callback_defined(stop_run_callback)=0 then
  if history<>spotless then
    if ((history=warning_issued)or(interaction<error_stop_mode)) then
      if selector=term_and_log then
        begin selector:=term_only;
        print_nl("(see the transcript file for additional information)");
@.see the transcript file...@>
        selector:=term_and_log;
        end;
if c=1 then
  begin @!init for i:=0 to biggest_used_mark do begin
    delete_top_mark(i); delete_first_mark(i); delete_bot_mark(i);
    delete_split_first_mark(i); delete_split_bot_mark(i);
    end;
  for c:=last_box_code to vsplit_code do flush_node_list(disc_ptr[c]);
  if last_glue<>max_halfword then delete_glue_ref(last_glue);
  while pseudo_files<>null do pseudo_close; {flush pseudo files}
  store_fmt_file; return;@+tini@/
  print_nl("(\dump is performed only by INITEX)"); return;
@:dump_}{\.{\\dump...only by INITEX}@>
  end;
exit:end;

@ @<Last-minute...@>=
@!init procedure init_prim; {initialize all the primitives}
begin no_new_control_sequence:=false;
first:=0;
@<Put each...@>;
no_new_control_sequence:=true;
end;
tini

@ When we begin the following code, \TeX's tables may still contain garbage;
the strings might not even be present. Thus we must proceed cautiously to get
bootstrapped in.

But when we finish this part of the program, \TeX\ is ready to call on the
|main_control| routine to do its work.

@<Get the first line...@>=
begin @<Initialize the input routines@>;
@<Enable \eTeX, if requested@>@;@/
if (format_ident=0)or(buffer[iloc]="&") then
  begin if format_ident<>0 then initialize; {erase preloaded format}
  if not open_fmt_file then goto final_end;
  if not load_fmt_file then
    begin w_close(fmt_file); goto final_end;
    end;
  w_close(fmt_file);
  while (iloc<ilimit)and(buffer[iloc]=" ") do incr(iloc);
  end;
if (pdf_output_option <> 0) then pdf_output := pdf_output_value;
if (pdf_draftmode_option <> 0) then pdf_draftmode := pdf_draftmode_value;
pdf_init_map_file('pdftex.map');
if false then begin 
  wterm_cr; fprintf(term_out,'entering extended mode'); 
end;
if end_line_char_inactive then decr(ilimit)
else  buffer[ilimit]:=end_line_char;
fix_date_and_time;@/
random_seed :=(microseconds*1000)+(epochseconds mod 1000000);@/
init_randoms(random_seed);@/
initialize_math;
fixup_selector(log_opened);
check_texconfig_init;
if (iloc<ilimit)and(get_cat_code(cat_code_table,buffer[iloc])<>escape) then start_input;
  {\.{\\input} assumed}
@<DIR: Initialize |text_dir_ptr|@>;
end

@* \[52] Debugging.
Once \TeX\ is working, you should be able to diagnose most errors with
the \.{\\show} commands and other diagnostic features. But for the initial
stages of debugging, and for the revelation of really deep mysteries, you
can compile \TeX\ with a few more aids, including the \PASCAL\ runtime
checks and its debugger. An additional routine called |debug_help|
will also come into play when you type `\.D' after an error message;
|debug_help| also occurs just before a fatal error causes \TeX\ to succumb.
@^debugging@>
@^system dependencies@>

The interface to |debug_help| is primitive, but it is good enough when used
with a \PASCAL\ debugger that allows you to set breakpoints and to read
variables and change their values. After getting the prompt `\.{debug \#}', you
type either a negative number (this exits |debug_help|), or zero (this
goes to a location where you can set a breakpoint, thereby entering into
dialog with the \PASCAL\ debugger), or a positive number |m| followed by
an argument |n|. The meaning of |m| and |n| will be clear from the
program below. (If |m=13|, there is an additional argument, |l|.)
@.debug \#@>

@d breakpoint=888 {place where a breakpoint is desirable}

@<Last-minute...@>=
@!debug procedure debug_help; {routine to display various things}
label breakpoint,exit;
var k,@!l,@!m,@!n:integer;
begin loop begin wake_up_terminal;
  print_nl("debug # (-1 to exit):"); update_terminal;
@.debug \#@>
  read(term_in,m);
  if m<0 then return
  else if m=0 then
    begin goto breakpoint;@\ {go to every label at least once}
    breakpoint: m:=0; @{'BREAKPOINT'@}@\
    end
  else  begin read(term_in,n);
    case m of
    @t\4@>@<Numbered cases for |debug_help|@>@;
    othercases print("?")
    endcases;
    end;
  end;
exit:end;
gubed

@ @<Numbered cases...@>=
1: print_word(vmem(n)); {display |varmem[n]| in all forms}
2: print_int(info(n));
3: print_int(link(n));
4: print_word(eqtb[n]);
5: ;
6: print_word(save_stack[n]);
7: show_box(n);
  {show a box, abbreviated by |show_box_depth| and |show_box_breadth|}
8: begin breadth_max:=10000; depth_threshold:=pool_size-pool_ptr-10;
  show_node_list(n); {show a box in its entirety}
  end;
9: show_token_list(n,null,1000);
10: slow_print(n);
13: begin read(term_in,l); print_cmd_chr(n,l);
  end;
14: for k:=0 to n do print(buffer[k]);
15: begin font_in_short_display:=null_font; short_display(n);
  end;

@* \[53] Extensions.
The program above includes a bunch of ``hooks'' that allow further
capabilities to be added without upsetting \TeX's basic structure.
Most of these hooks are concerned with ``whatsit'' nodes, which are
intended to be used for special purposes; whenever a new extension to
\TeX\ involves a new kind of whatsit node, a corresponding change needs
to be made to the routines below that deal with such nodes,
but it will usually be unnecessary to make many changes to the
other parts of this program.

In order to demonstrate how extensions can be made, we shall treat
`\.{\\write}', `\.{\\openout}', `\.{\\closeout}', `\.{\\immediate}',
and `\.{\\special}' as if they were extensions.
These commands are actually primitives of \TeX, and they should
appear in all implementations of the system; but let's try to imagine
that they aren't. Then the program below illustrates how a person
could add them.

Sometimes, of course, an extension will require changes to \TeX\ itself;
no system of hooks could be complete enough for all conceivable extensions.
The features associated with `\.{\\write}' are almost all confined to the
following paragraphs, but there are small parts of the |print_ln| and
|print_char| procedures that were introduced specifically to \.{\\write}
characters. Furthermore one of the token lists recognized by the scanner
is a |write_text|; and there are a few other miscellaneous places where we
have already provided for some aspect of \.{\\write}.  The goal of a \TeX\
extender should be to minimize alterations to the standard parts of the
program, and to avoid them completely if possible. He or she should also
be quite sure that there's no easy way to accomplish the desired goals
with the standard features that \TeX\ already has. ``Think thrice before
extending,'' because that may save a lot of work, and it will also keep
incompatible extensions of \TeX\ from proliferating.
@^system dependencies@>
@^extensions to \TeX@>

@ First let's consider the format of whatsit nodes that are used to represent
the data associated with \.{\\write} and its relatives. Recall that a whatsit
has |type=whatsit_node|, and the |subtype| is supposed to distinguish
different kinds of whatsits. Each node occupies two or more words; the
exact number is immaterial, as long as it is readily determined from the
|subtype| or other data.

We shall introduce five |subtype| values here, corresponding to the
control sequences \.{\\openout}, \.{\\write}, \.{\\closeout}, and \.{\\special}.
The second word of I/O whatsits has a |write_stream| field
that identifies the write-stream number (0 to 15, or 16 for out-of-range and
positive, or 17 for out-of-range and negative).
In the case of \.{\\write} and \.{\\special}, there is also a field that
points to the reference count of a token list that should be sent. In the
case of \.{\\openout}, we need three words and three auxiliary subfields
to hold the string numbers for name, area, and extension.

@d open_node=0 {|subtype| in whatsits that represent files to \.{\\openout}}
@d write_node=1 {|subtype| in whatsits that represent things to \.{\\write}}
@d close_node=2 {|subtype| in whatsits that represent streams to \.{\\closeout}}
@d special_node=3 {|subtype| in whatsits that represent \.{\\special} things}
@d dir_dir(#)==vinfo(#+2) {keep the direction to be taken}
@d dir_level(#)==vlink(#+2) {the save level at which the direction was defined}
@d dir_dvi_ptr(#)==vinfo(#+3) {for reflecting dvi output}
@d dir_dvi_h(#)==vlink(#+3) {for reflecting dvi output}
@d dir_box_pos_h(#)==vinfo(#+4) {for reflecting dvi output}
@d dir_box_pos_v(#)==vlink(#+4) {for reflecting dvi output}
@d dir_cur_h(#)==vinfo(#+5) {for reflecting dvi output}
@d dir_cur_v(#)==vlink(#+5) {for reflecting dvi output}
@d what_lang(#)==vlink(#+2) {language number, in the range |0..255|}
@d what_lhm(#)==type(#+2) {minimum left fragment, in the range |1..63|}
@d what_rhm(#)==subtype(#+2) {minimum right fragment, in the range |1..63|}
@d write_tokens(#) == vlink(#+2) {reference count of token list to write}
@d write_stream(#) == vinfo(#+2) {stream number (0 to 17)}
@d open_name(#) == vlink(#+2) {string number of file name to open}
@d open_area(#) == vinfo(#+3) {string number of file area for |open_name|}
@d open_ext(#) == vlink(#+3) {string number of file extension for |open_name|}

@ The sixteen possible \.{\\write} streams are represented by the |write_file|
array. The |j|th file is open if and only if |write_open[j]=true|. The last
two streams are special; |write_open[16]| represents a stream number
greater than 15, while |write_open[17]| represents a negative stream number,
and both of these variables are always |false|.

@<Glob...@>=
@!write_file:array[0..15] of alpha_file;
@!write_file_mode:array[0..15] of halfword;
@!write_file_translation:array[0..15] of halfword;
@!write_open:array[0..17] of boolean;
@!neg_wd:scaled;
@!pos_wd:scaled;
@!neg_ht:scaled;

@ @<Set init...@>=
for k:=0 to 17 do write_open[k]:=false;
initialize_directions;

@ Extensions might introduce new command codes; but it's best to use
|extension| with a modifier, whenever possible, so that |main_control|
stays the same.

@d immediate_code=4 {command modifier for \.{\\immediate}}
@d local_par_node==6 {|subtype| in whatsits for local paragraph node}
{|local_par_node| has to be a macro, not numeric }
@d dir_node=7 {|subtype| in whatsits for change direction node}
@d pdftex_first_extension_code = 8
@d pdf_literal_node            == pdftex_first_extension_code + 0
@d pdf_obj_code                == pdftex_first_extension_code + 1
@d pdf_refobj_node             == pdftex_first_extension_code + 2
@d pdf_xform_code              == pdftex_first_extension_code + 3
@d pdf_refxform_node           == pdftex_first_extension_code + 4
@d pdf_ximage_code             == pdftex_first_extension_code + 5
@d pdf_refximage_node          == pdftex_first_extension_code + 6
@d pdf_annot_node              == pdftex_first_extension_code + 7
@d pdf_start_link_node         == pdftex_first_extension_code + 8
@d pdf_end_link_node           == pdftex_first_extension_code + 9
@d pdf_outline_code            == pdftex_first_extension_code + 10
@d pdf_dest_node               == pdftex_first_extension_code + 11
@d pdf_thread_node             == pdftex_first_extension_code + 12
@d pdf_start_thread_node       == pdftex_first_extension_code + 13
@d pdf_end_thread_node         == pdftex_first_extension_code + 14
@d pdf_save_pos_node           == pdftex_first_extension_code + 15
@d pdf_info_code               == pdftex_first_extension_code + 16
@d pdf_thread_data_node        == pdftex_first_extension_code + 16
@d pdf_catalog_code            == pdftex_first_extension_code + 17
@d pdf_link_data_node          == pdftex_first_extension_code + 17
@d pdf_names_code              == pdftex_first_extension_code + 18
@d pdf_font_attr_code          == pdftex_first_extension_code + 19
@d pdf_include_chars_code      == pdftex_first_extension_code + 20
@d pdf_map_file_code           == pdftex_first_extension_code + 21
@d pdf_map_line_code           == pdftex_first_extension_code + 22
@d pdf_trailer_code            == pdftex_first_extension_code + 23
@d pdf_font_expand_code        == pdftex_first_extension_code + 24
@d set_random_seed_code        == pdftex_first_extension_code + 25
@d pdf_glyph_to_unicode_code   == pdftex_first_extension_code + 26
@d late_lua_node               == pdftex_first_extension_code + 27
@d save_cat_code_table_code    == pdftex_first_extension_code + 29
@d init_cat_code_table_code    == pdftex_first_extension_code + 30
@d pdf_colorstack_node         == pdftex_first_extension_code + 31
@d pdf_setmatrix_node          == pdftex_first_extension_code + 32
@d pdf_save_node               == pdftex_first_extension_code + 33
@d pdf_restore_node            == pdftex_first_extension_code + 34
@d pdftex_last_extension_code  == pdftex_first_extension_code + 34

@<Put each...@>=
primitive_tex("openout",extension,open_node,0);@/
@!@:open_out_}{\.{\\openout} primitive@>
primitive_tex("write",extension,write_node,0); write_loc:=cur_val;@/
@!@:write_}{\.{\\write} primitive@>
primitive_tex("closeout",extension,close_node,0);@/
@!@:close_out_}{\.{\\closeout} primitive@>
primitive_tex("special",extension,special_node,0);@/
@!@:special_}{\.{\\special} primitive@>
text(frozen_special):="special"; eqtb[frozen_special]:=eqtb[cur_val];@/
primitive_tex("immediate",extension,immediate_code,0);@/
@!@:immediate_}{\.{\\immediate} primitive@>
primitive_omega("localinterlinepenalty",assign_int,int_base+local_inter_line_penalty_code,int_base);@/
primitive_omega("localbrokenpenalty",assign_int,int_base+local_broken_penalty_code,int_base);@/
primitive_omega("pagedir",assign_dir,dir_base+page_direction_code,dir_base);@/
primitive_omega("bodydir",assign_dir,dir_base+body_direction_code,dir_base);@/
primitive_omega("pardir",assign_dir,dir_base+par_direction_code,dir_base);@/
primitive_omega("textdir",assign_dir,dir_base+text_direction_code,dir_base);@/
primitive_omega("mathdir",assign_dir,dir_base+math_direction_code,dir_base);@/
primitive_luatex("pageleftoffset",assign_dimen,dimen_base+page_left_offset_code,dimen_base);
primitive_luatex("pagetopoffset",assign_dimen,dimen_base+page_top_offset_code,dimen_base);
primitive_aleph("pagerightoffset",assign_dimen,dimen_base+page_right_offset_code,dimen_base);
primitive_aleph("pagebottomoffset",assign_dimen,dimen_base+page_bottom_offset_code,dimen_base);
primitive_pdftex("pdfliteral",extension,pdf_literal_node,0);@/
@!@:pdf_literal_}{\.{\\pdfliteral} primitive@>
primitive_pdftex("pdfcolorstack",extension,pdf_colorstack_node,0);@/
@!@:pdf_colorstack_}{\.{\\pdfcolorstack} primitive@>
primitive_pdftex("pdfsetmatrix",extension,pdf_setmatrix_node,0);@/
@!@:pdf_setmatrix_}{\.{\\pdfsetmatrix} primitive@>
primitive_pdftex("pdfsave",extension,pdf_save_node,0);@/
@!@:pdf_save_}{\.{\\pdfsave} primitive@>
primitive_pdftex("pdfrestore",extension,pdf_restore_node,0);@/
@!@:pdf_restore_}{\.{\\pdfrestore} primitive@>
primitive_pdftex("pdfobj",extension,pdf_obj_code,0);@/
@!@:pdf_obj_}{\.{\\pdfobj} primitive@>
primitive_pdftex("pdfrefobj",extension,pdf_refobj_node,0);@/
@!@:pdf_refobj_}{\.{\\pdfrefobj} primitive@>
primitive_pdftex("pdfxform",extension,pdf_xform_code,0);@/
@!@:pdf_xform_}{\.{\\pdfxform} primitive@>
primitive_pdftex("pdfrefxform",extension,pdf_refxform_node,0);@/
@!@:pdf_refxform_}{\.{\\pdfrefxform} primitive@>
primitive_pdftex("pdfximage",extension,pdf_ximage_code,0);@/
@!@:pdf_ximage_}{\.{\\pdfximage} primitive@>
primitive_pdftex("pdfrefximage",extension,pdf_refximage_node,0);@/
@!@:pdf_refximage_}{\.{\\pdfrefximage} primitive@>
primitive_pdftex("pdfannot",extension,pdf_annot_node,0);@/
@!@:pdf_annot_}{\.{\\pdfannot} primitive@>
primitive_pdftex("pdfstartlink",extension,pdf_start_link_node,0);@/
@!@:pdf_start_link_}{\.{\\pdfstartlink} primitive@>
primitive_pdftex("pdfendlink",extension,pdf_end_link_node,0);@/
@!@:pdf_end_link_}{\.{\\pdfendlink} primitive@>
primitive_pdftex("pdfoutline",extension,pdf_outline_code,0);@/
@!@:pdf_outline_}{\.{\\pdfoutline} primitive@>
primitive_pdftex("pdfdest",extension,pdf_dest_node,0);@/
@!@:pdf_dest_}{\.{\\pdfdest} primitive@>
primitive_pdftex("pdfthread",extension,pdf_thread_node,0);@/
@!@:pdf_thread_}{\.{\\pdfthread} primitive@>
primitive_pdftex("pdfstartthread",extension,pdf_start_thread_node,0);@/
@!@:pdf_start_thread_}{\.{\\pdfstartthread} primitive@>
primitive_pdftex("pdfendthread",extension,pdf_end_thread_node,0);@/
@!@:pdf_end_thread_}{\.{\\pdfendthread} primitive@>
primitive_pdftex("pdfsavepos",extension,pdf_save_pos_node,0);@/
@!@:pdf_save_pos_}{\.{\\pdfsavepos} primitive@>
primitive_pdftex("pdfinfo",extension,pdf_info_code,0);@/
@!@:pdf_info_}{\.{\\pdfinfo} primitive@>
primitive_pdftex("pdfcatalog",extension,pdf_catalog_code,0);@/
@!@:pdf_catalog_}{\.{\\pdfcatalog} primitive@>
primitive_pdftex("pdfnames",extension,pdf_names_code,0);@/
@!@:pdf_names_}{\.{\\pdfnames} primitive@>
primitive_pdftex("pdfincludechars",extension,pdf_include_chars_code,0);@/
@!@:pdf_include_chars_}{\.{\\pdfincludechars} primitive@>
primitive_pdftex("pdffontattr",extension,pdf_font_attr_code,0);@/
@!@:pdf_font_attr_}{\.{\\pdffontattr} primitive@>
primitive_pdftex("pdfmapfile",extension,pdf_map_file_code,0);@/
@!@:pdf_map_file_}{\.{\\pdfmapfile} primitive@>
primitive_pdftex("pdfmapline",extension,pdf_map_line_code,0);@/
@!@:pdf_map_line_}{\.{\\pdfmapline} primitive@>
primitive_pdftex("pdftrailer",extension,pdf_trailer_code,0);@/
@!@:pdf_trailer_}{\.{\\pdftrailer} primitive@>
primitive_luatex("savecatcodetable",extension,save_cat_code_table_code,0);@/
@!@:save_cat_code_table_}{\.{\\savecatcodetable} primitive@>
primitive_luatex("initcatcodetable",extension,init_cat_code_table_code,0);@/
@!@:init_cat_code_table_}{\.{\\initcatcodetable} primitive@>
primitive_pdftex("pdfsetrandomseed",extension,set_random_seed_code,0);@/
@!@:set_random_seed_code}{\.{\\pdfsetrandomseed} primitive@>
primitive_luatex("latelua",extension,late_lua_node,0);@/
@!@:late_lua_node_}{\.{\\latelua} primitive@>
primitive_pdftex("pdffontexpand",extension,pdf_font_expand_code,0);@/
@!@:pdf_font_expand_}{\.{\\pdffontexpand} primitive@>
primitive_pdftex("pdfglyphtounicode",extension,pdf_glyph_to_unicode_code,0);@/
@!@:pdf_glyph_to_unicode_}{\.{\\pdfglyphtounicode} primitive@>

@ The variable |write_loc| just introduced is used to provide an
appropriate error message in case of ``runaway'' write texts.

@<Glob...@>=
@!write_loc:pointer; {|eqtb| address of \.{\\write}}

@ When an |extension| command occurs in |main_control|, in any mode,
the |do_extension| routine is called.

@<Cases of |main_control| that are for extensions...@>=
any_mode(extension):do_extension;

@ @<Declare act...@>=
@t\4@>@<Declare procedures needed in |do_extension|@>@;
procedure do_extension;
var i,@!j,@!k:integer; {all-purpose integers}
@!p:pointer; {all-purpose pointer}
@!sn:integer; {a potential lua state name}
begin case cur_chr of
  open_node:@<Implement \.{\\openout}@>;
  write_node:@<Implement \.{\\write}@>;
  close_node:@<Implement \.{\\closeout}@>;
  special_node:@<Implement \.{\\special}@>;
  immediate_code:@<Implement \.{\\immediate}@>;
  pdf_annot_node: @<Implement \.{\\pdfannot}@>;
  pdf_catalog_code: @<Implement \.{\\pdfcatalog}@>;
  pdf_dest_node: @<Implement \.{\\pdfdest}@>;
  pdf_end_link_node: @<Implement \.{\\pdfendlink}@>;
  pdf_end_thread_node: @<Implement \.{\\pdfendthread}@>;
  pdf_font_attr_code: @<Implement \.{\\pdffontattr}@>;
  pdf_font_expand_code: @<Implement \.{\\pdffontexpand}@>;
  pdf_include_chars_code: @<Implement \.{\\pdfincludechars}@>;
  pdf_info_code: @<Implement \.{\\pdfinfo}@>;
  pdf_literal_node: @<Implement \.{\\pdfliteral}@>;
  pdf_colorstack_node: @<Implement \.{\\pdfcolorstack}@>;
  pdf_setmatrix_node: @<Implement \.{\\pdfsetmatrix}@>;
  pdf_save_node: @<Implement \.{\\pdfsave}@>;
  pdf_restore_node: @<Implement \.{\\pdfrestore}@>;
  pdf_map_file_code: @<Implement \.{\\pdfmapfile}@>;
  pdf_map_line_code: @<Implement \.{\\pdfmapline}@>;
  pdf_names_code: @<Implement \.{\\pdfnames}@>;
  pdf_obj_code: @<Implement \.{\\pdfobj}@>;
  pdf_outline_code: @<Implement \.{\\pdfoutline}@>;
  pdf_refobj_node: @<Implement \.{\\pdfrefobj}@>;
  pdf_refxform_node: @<Implement \.{\\pdfrefxform}@>;
  pdf_refximage_node: @<Implement \.{\\pdfrefximage}@>;
  pdf_save_pos_node: @<Implement \.{\\pdfsavepos}@>;
  pdf_start_link_node: @<Implement \.{\\pdfstartlink}@>;
  pdf_start_thread_node: @<Implement \.{\\pdfstartthread}@>;
  pdf_thread_node: @<Implement \.{\\pdfthread}@>;
  pdf_trailer_code: @<Implement \.{\\pdftrailer}@>;
  pdf_xform_code: @<Implement \.{\\pdfxform}@>;
  pdf_ximage_code: @<Implement \.{\\pdfximage}@>;
  save_cat_code_table_code: @<Implement \.{\\savecatcodetable}@>;
  init_cat_code_table_code: @<Implement \.{\\initcatcodetable}@>;
  set_random_seed_code: @<Implement \.{\\pdfsetrandomseed}@>;
  pdf_glyph_to_unicode_code: @<Implement \.{\\pdfglyphtounicode}@>;
  late_lua_node: @<Implement \.{\\latelua}@>;
othercases confusion('ext1')
@:this can't happen ext1}{\quad ext1@>
endcases;
end;

@ Here is a subroutine that creates a whatsit node having a given |subtype|
and a given number of words. It initializes only the first word of the whatsit,
and appends it to the current list.

@<Declare procedures needed in |do_extension|@>=
procedure new_whatsit(@!s:small_number);
var p:pointer; {the new node}
begin p:=new_node(whatsit_node,s);
vlink(tail):=p; tail:=p;
end;

@ The next subroutine uses |cur_chr| to decide what sort of whatsit is
involved, and also inserts a |write_stream| number.

@<Declare procedures needed in |do_ext...@>=
procedure new_write_whatsit(@!w:small_number);
begin new_whatsit(cur_chr);
if w<>write_node_size then scan_four_bit_int
else  begin scan_int;
  if cur_val<0 then cur_val:=17
  else if cur_val>15 then cur_val:=16;
  end;
write_stream(tail):=cur_val;
end;

@ @<Implement \.{\\openout}@>=
begin new_write_whatsit(open_node_size);
scan_optional_equals; scan_file_name;@/
open_name(tail):=cur_name; open_area(tail):=cur_area; open_ext(tail):=cur_ext;
end

@ When `\.{\\write 12\{...\}}' appears, we scan the token list `\.{\{...\}}'
without expanding its macros; the macros will be expanded later when this
token list is rescanned.

@<Implement \.{\\write}@>=
begin k:=cur_cs; new_write_whatsit(write_node_size);@/
cur_cs:=k; p:=scan_toks(false,false); write_tokens(tail):=def_ref;
end

@ @<Implement \.{\\closeout}@>=
begin new_write_whatsit(write_node_size); write_tokens(tail):=null;
end

@ When `\.{\\special\{...\}}' appears, we expand the macros in the token
list as in \.{\\xdef} and \.{\\mark}.

@<Implement \.{\\special}@>=
begin new_whatsit(special_node); write_stream(tail):=null;
p:=scan_toks(false,true); write_tokens(tail):=def_ref;
end

@ @<Implement \.{\\pdffontexpand}@>=
    read_expand_font

@ We have to check whether \.{\\pdfoutput} is set for using \pdfTeX{}
  extensions.
@<Declare procedures needed in |do_ext...@>=
procedure scan_pdf_ext_toks;
begin
    call_func(scan_toks(false, true)); {like \.{\\special}}
end;

@ @<Implement \.{\\pdfliteral}@>=
begin
    check_pdfoutput('\pdfliteral', true);
    new_whatsit(pdf_literal_node);
    if scan_keyword('direct') then
        set_pdf_literal_mode(tail,direct_always)
    else if scan_keyword('page') then
        set_pdf_literal_mode(tail,direct_page)
    else
        set_pdf_literal_mode(tail,set_origin);
    scan_pdf_ext_toks;
    set_pdf_literal_type(tail, normal);
    set_pdf_literal_data(tail, def_ref);
end

@ @<Implement \.{\\pdfcolorstack}@>=
begin
    check_pdfoutput('\pdfcolorstack', true);
    {Scan and check the stack number and store in |cur_val|}
    scan_int;
    if cur_val >= colorstackused then begin
        print_err('Unknown color stack number ');
        print_int(cur_val);
@.Unknown color stack@>
        help3('Allocate and initialize a color stack with \pdfcolorstackinit.',
        'I''ll use default color stack 0 here.',
        'Proceed, with fingers crossed.');
        error;
        cur_val := 0;
    end;
    if cur_val < 0 then begin
        print_err('Invalid negative color stack number');
@.Invalid negative color stack number@>
        help2('I''ll use default color stack 0 here.',
        'Proceed, with fingers crossed.');
        error;
        cur_val := 0;
    end;
    if scan_keyword('set') then begin
        i := colorstack_set;
    end
    else if scan_keyword('push') then begin
        i := colorstack_push;
    end
    else if scan_keyword('pop') then begin
        i := colorstack_pop;
    end
    else if scan_keyword('current') then begin
        i := colorstack_current;
    end
    else begin
        i := -1; {error}
    end;
    if i >= 0 then begin
        new_whatsit(pdf_colorstack_node);
        set_pdf_colorstack_stack(tail, cur_val);
        set_pdf_colorstack_cmd(tail, i);
        set_pdf_colorstack_data(tail, null);
        if i <= colorstack_data then begin
            scan_pdf_ext_toks;
            set_pdf_colorstack_data(tail,def_ref);
        end;
    end
    else begin
        print_err('Color stack action is missing');
@.Color stack action is missing@>
        help3('The expected actions for \pdfcolorstack:',
        '    set, push, pop, current',
        'I''ll ignore the color stack command.');
        error;
    end
end

@ @<Implement \.{\\pdfsetmatrix}@>=
begin
    check_pdfoutput('\pdfsetmatrix', true);
    new_whatsit(pdf_setmatrix_node);
    scan_pdf_ext_toks;
    set_pdf_setmatrix_data(tail, def_ref);
end

@ @<Implement \.{\\pdfsave}@>=
begin
    check_pdfoutput('\pdfsave', true);
    new_whatsit(pdf_save_node);
end

@ @<Implement \.{\\pdfrestore}@>=
begin
    check_pdfoutput('\pdfrestore', true);
    new_whatsit(pdf_restore_node);
end


@ @<Implement \.{\\latelua}@>=
begin
    check_pdfoutput('\latelua', true);
    new_whatsit(late_lua_node);
    if scan_keyword('name') then begin
       scan_pdf_ext_toks;
       late_lua_name(tail) := def_ref;
    end;
    sn:=0;
    @<Parse optional lua state...@>;
    if sn then late_lua_name(tail) := sn;
    call_func(scan_toks(false, false));
    late_lua_data(tail) := def_ref;
end

@ @<Implement \.{\\pdfobj}@>=
begin
    check_pdfoutput('\pdfobj', true);
    scan_obj(static_pdf);
end

@ We need to check whether the referenced object exists.

@<Declare procedures that need to be declared forward for \pdfTeX@>=
function prev_rightmost(s, e: pointer): pointer;
{finds the node preceding the rightmost node |e|; |s| is some node
before |e|}
var p: pointer;
begin
    prev_rightmost := null;
    p := s;
    if p = null then
        return;
    while vlink(p) <> e do begin
        p := vlink(p);
        if p = null then
            return;
    end;
    prev_rightmost := p;
end;

@ @<Implement \.{\\pdfrefobj}@>=
begin
    check_pdfoutput('\pdfrefobj', true);
    scan_int;
    pdf_check_obj(static_pdf, obj_type_obj, cur_val);
    new_whatsit(pdf_refobj_node);
    set_pdf_obj_objnum(tail, cur_val);
end

@ \.{\\pdfxform} and \.{\\pdfrefxform} are similiar to \.{\\pdfobj} and
  \.{\\pdfrefobj}

@<Glob...@>=
@!pdf_last_xform: integer;

@ @<Implement \.{\\pdfxform}@>=
begin
    check_pdfoutput('\pdfxform', true);
    scan_pdfxform(static_pdf, box_base);
end

@ @<Implement \.{\\pdfrefxform}@>=
begin
    check_pdfoutput('\pdfrefxform', true);
    scan_pdfrefxform(static_pdf);
end

@ \.{\\pdfximage} and \.{\\pdfrefximage} are similiar to \.{\\pdfxform} and
  \.{\\pdfrefxform}. As we have to scan |<rule spec>| quite often, it is better
  have a |rule_node| that holds the most recently scanned |<rule spec>|.

@<Glob...@>=
@!pdf_last_ximage: integer;
@!pdf_last_ximage_pages: integer;
@!pdf_last_ximage_colordepth: integer;

@ @<Implement \.{\\pdfximage}@>=
begin
    check_pdfoutput('\pdfximage', true);
    check_pdfminorversion(static_pdf);
    scan_image(static_pdf);
end

@ @<Implement \.{\\pdfrefximage}@>=
begin
    check_pdfoutput('\pdfrefximage', true);
    scan_int;
    pdf_check_obj(static_pdf, obj_type_ximage, cur_val);
    new_whatsit(pdf_refximage_node);
    j := obj_data_ptr(static_pdf, cur_val);
    set_pdf_ximage_idx(tail, j);
    set_pdf_width(tail, image_width(j));
    set_pdf_height(tail, image_height(j));
    set_pdf_depth(tail, image_depth(j));
end

@ 

@d flushable(#) == (# = str_ptr - 1)

@<Declare procedures that need to be declared forward for \pdfTeX@>=
procedure flush_str(s: str_number); {flush a string if possible}
begin
    if flushable(s) then
        flush_string;
end;

@ @<Glob...@>=
@!pdf_last_annot: integer;

@ @<Implement \.{\\pdfannot}@>=
begin
    check_pdfoutput('\pdfannot', true);
    scan_annot(static_pdf);
end

@ pdflastlink needs an extra global variable
@<Glob...@>=
@!pdf_last_link: integer;

@ @<Implement \.{\\pdfstartlink}@>=
begin
    check_pdfoutput('\pdfstartlink', true);
    scan_startlink(static_pdf);
end

@ @<Implement \.{\\pdfendlink}@>=
begin
    check_pdfoutput('\pdfendlink', true);
    if abs(mode) = vmode then
        pdf_error('ext1', '\pdfendlink cannot be used in vertical mode');
    new_whatsit(pdf_end_link_node);
end

@ @<Implement \.{\\pdfoutline}@>=
begin
    check_pdfoutput('\pdfoutline', true);
    scan_pdfoutline(static_pdf);
end

@ @<Implement \.{\\pdfdest}@>=
begin
    check_pdfoutput('\pdfdest', true);
    scan_pdfdest(static_pdf);
end

@ @<Implement \.{\\pdfthread}@>=
begin
    check_pdfoutput('\pdfthread', true);
    new_annot_whatsit(pdf_thread_node);
    scan_thread_id;
end

@ @<Implement \.{\\pdfstartthread}@>=
begin
    check_pdfoutput('\pdfstartthread', true);
    new_annot_whatsit(pdf_start_thread_node);
    scan_thread_id;
end

@ @<Implement \.{\\pdfendthread}@>=
begin
    check_pdfoutput('\pdfendthread', true);
    new_whatsit(pdf_end_thread_node);
end

@ @<Glob...@>=
@!pdf_last_x_pos: integer;
@!pdf_last_y_pos: integer;

@ @<Implement \.{\\pdfsavepos}@>=
begin
    new_whatsit(pdf_save_pos_node);
end

@ To implement primitives as \.{\\pdfinfo}, \.{\\pdfcatalog} or
\.{\\pdfnames} we need to concatenate tokens lists.

@<Declare procedures needed in |do_ext...@>=
function concat_tokens(q, r: pointer): pointer; {concat |q| and |r| and
returns the result tokens list}
var p: pointer;
begin
    if q = null then begin
        concat_tokens := r;
        return;
    end;
    p := q;
    while link(p) <> null do
        p := link(p);
    set_token_link(p,link(r));
    free_avail(r);
    concat_tokens := q;
end;

@ @<Implement \.{\\pdfinfo}@>=
begin
    check_pdfoutput('\pdfinfo', false);
    scan_pdf_ext_toks;
    if pdf_output > 0 then
        pdf_info_toks := concat_tokens(pdf_info_toks, def_ref);
end

@ @<Implement \.{\\pdfcatalog}@>=
begin
    check_pdfoutput('\pdfcatalog', false);
    scan_pdfcatalog(static_pdf);
end

@ @<Implement \.{\\pdfnames}@>=
begin
    check_pdfoutput('\pdfnames', true);
    scan_pdf_ext_toks;
    pdf_names_toks := concat_tokens(pdf_names_toks, def_ref);
end

@ @<Implement \.{\\pdftrailer}@>=
begin
    check_pdfoutput('\pdftrailer', false);
    scan_pdf_ext_toks;
    if pdf_output > 0 then
        pdf_trailer_toks := concat_tokens(pdf_trailer_toks, def_ref);
end

@ @<Glob...@>=
@!pdf_retval: integer; {global multi-purpose return value}

@ @<Set initial values of key variables@>=
  seconds_and_micros(epochseconds,microseconds);
  init_start_time(static_pdf);

@ Negative random seed values are silently converted to positive ones

@<Implement \.{\\pdfsetrandomseed}@>=
begin
  scan_int;
  if cur_val<0 then negate(cur_val);
  random_seed := cur_val;
  init_randoms(random_seed);
end

@ @<Implement \.{\\savecatcodetable}@>=
begin
  scan_int;
  if (cur_val<0)or(cur_val>@"FFFF) then begin
        print_err('Invalid \catcode table');
        help1('All \catcode table ids must be between 0 and 0xFFFF');
        error;
    end
  else begin if cur_val=cat_code_table then begin
      print_err('Invalid \catcode table');
          help1('You cannot overwrite the current \catcode table');
      error;
      end
    else
      copy_cat_codes(cat_code_table,cur_val);
    end;
end

@ @<Implement \.{\\initcatcodetable}@>=
begin
  scan_int;
  if (cur_val<0)or(cur_val>@"FFFF) then begin
        print_err('Invalid \catcode table');
        help1('All \catcode table ids must be between 0 and 0xFFFF');
        error;
    end
  else begin if cur_val=cat_code_table then begin
    print_err('Invalid \catcode table');
        help1('You cannot overwrite the current \catcode table');
        error;
    end
  else
    initex_cat_codes(cur_val);
    end;
end

@ @<Implement \.{\\pdfincludechars}@>=
begin
    check_pdfoutput('\pdfincludechars', true);
    pdf_include_chars(static_pdf);
end

@ @<Implement \.{\\pdfglyphtounicode}@>=
begin
    glyph_to_unicode;
end

@ A change from \THANH's original code: the font attributes are simply
initialized to zero now, this is easier to deal with from C than an
empty \TeX{} string, and surely nobody will want to set
\.{\\pdffontattr} to a string containing a single zero, as that
would be nonsensical in the PDF output.

@<Implement \.{\\pdffontattr}@>=
begin
    check_pdfoutput('\pdffontattr', true);
    scan_font_ident;
    k := cur_val;
    if k = null_font then
        pdf_error('font', 'invalid font identifier');
    scan_pdf_ext_toks;
    set_pdf_font_attr(k, tokens_to_string(def_ref));
    if length(pdf_font_attr(k)) = 0 then begin
      flush_string;
      set_pdf_font_attr(k,0);
      end;
end

@ @<Implement \.{\\pdfmapfile}@>=
begin
    check_pdfoutput('\pdfmapfile', true);
    scan_pdf_ext_toks;
    pdfmapfile(def_ref);
    delete_token_ref(def_ref);
end

@ @<Implement \.{\\pdfmapline}@>=
begin
    check_pdfoutput('\pdfmapline', true);
    scan_pdf_ext_toks;
    pdfmapline(def_ref);
    delete_token_ref(def_ref);
end

@ Three extra node types carry information from |main_control|.

@ |cancel_boundary_nodes| indicate that the next left boundary be
ignored. These are created by the \.{\\noboundary} command in
horizontal mode.

@d cancel_boundary_node==pdf_restore_node+1
@d cancel_boundary_size==3

@<Append a |cancel_boundary_node| @>=
begin new_whatsit(cancel_boundary_node);
end

@ User defined whatsits can be inserted into node lists to pass data
along from one lua call to anotherb without interference from the
typesetting engine itself. Each has an id, a type, and a value. The
type of the value depends on the |user_node_type| field.

@d user_defined_node==cancel_boundary_node+1
@d user_node_id(#)==vlink(#+2)
@d user_node_type(#)==vinfo(#+2)
@d user_node_value(#)==vinfo(#+3)


@ @<Prepare to move whatsit |p| to the current page, then |goto contribute|@>=
begin
  if (subtype(p) = pdf_refxform_node) or (subtype(p) = pdf_refximage_node) then
  begin page_total:=page_total+page_depth+pdf_height(p);
  page_depth:=pdf_depth(p);
  end;
  goto contribute;
end

@ After all this preliminary shuffling, we come finally to the routines
that actually send out the requested data. 

@ To write a token list, we must run it through \TeX's scanner, expanding
macros and \.{\\the} and \.{\\number}, etc. This might cause runaways,
if a delimited macro parameter isn't matched, and runaways would be
extremely confusing since we are calling on \TeX's scanner in the middle
of a \.{\\shipout} command. Therefore we will put a dummy control sequence as
a ``stopper,'' right after the token list. This control sequence is
artificially defined to be \.{\\outer}.
@:end_write_}{\.{\\endwrite}@>

@<Initialize table...@>=
text(end_write):="endwrite"; eq_level(end_write):=level_one;
eq_type(end_write):=outer_call; equiv(end_write):=null;

@ The presence of `\.{\\immediate}' causes the |do_extension| procedure
to descend to one level of recursion. Nothing happens unless \.{\\immediate}
is followed by `\.{\\openout}', `\.{\\write}', or `\.{\\closeout}'.
@^recursion@>

@<Implement \.{\\immediate}@>=
begin get_x_token;
if cur_cmd=extension then begin
    if cur_chr<=close_node then
      begin p:=tail; do_extension; {append a whatsit node}
      out_what(tail); {do the action immediately}
      flush_node_list(tail); tail:=p; vlink(p):=null;
      end
    else case cur_chr of
        pdf_obj_code: begin
            do_extension; {scan object and set |pdf_last_obj|}
            if obj_data_ptr(static_pdf, pdf_last_obj) = 0 then {this object has not been initialized yet}
                pdf_error('ext1', '`\pdfobj reserveobjnum'' cannot be used with \immediate');
            pdf_write_obj(static_pdf, pdf_last_obj);
        end;
        pdf_xform_code: begin
            do_extension; {scan form and set |pdf_last_xform|}
            pdf_cur_form := pdf_last_xform;
            pdf_ship_out(static_pdf, obj_xform_box(static_pdf, pdf_last_xform), false);
        end;
        pdf_ximage_code: begin
            do_extension; {scan image and set |pdf_last_ximage|}
            pdf_write_image(static_pdf, pdf_last_ximage);
        end;
        othercases back_input
    endcases;
end
else
    back_input;
end

@ @<Finish the extensions@>=
for k:=0 to 15 do if write_open[k] then lua_a_close_out(write_file[k])

@
@d local_pen_inter(#)==vinfo(#+2) {\.{\\localinterlinepenalty}}
@d local_pen_broken(#)==vlink(#+2) {\.{\\localbrokenpenalty}}
@d local_box_left(#)==vlink(#+3) {\.{\\localleftbox}}
@d local_box_left_width(#)==vinfo(#+3)
@d local_box_right(#)==vlink(#+4) {\.{\\localleftbox}}
@d local_box_right_width(#)==vinfo(#+4)
@d local_par_dir(#)==vinfo(#+5)

@<LOCAL: Declare |make_local_par_node|@>=
function make_local_par_node:pointer;
{This function creates a |local_paragraph| node}
var p,q:pointer;
begin
p:=new_node(whatsit_node,local_par_node);
local_pen_inter(p):=local_inter_line_penalty;
local_pen_broken(p):=local_broken_penalty;
if local_left_box<>null then begin
  q:=copy_node_list(local_left_box); local_box_left(p):=q;
  local_box_left_width(p):=width(local_left_box);
  end;
if local_right_box<>null then begin
  q:=copy_node_list(local_right_box); local_box_right(p):=q;
  local_box_right_width(p):=width(local_right_box);
  end;
local_par_dir(p):=par_direction;
make_local_par_node:=p;
end

@ @<LOCAL: Add local paragraph node@>=
begin tail_append(make_local_par_node) end

@ @<DIR: Assign direction codes@>=
case cur_chr of
dir_base+page_direction_code: begin
    scan_direction;
    eq_word_define(dir_base+page_direction_code,cur_val);
  end;
dir_base+body_direction_code: begin
    scan_direction;
    eq_word_define(dir_base+body_direction_code,cur_val);
  end;
dir_base+par_direction_code: begin
  scan_direction;
  eq_word_define(dir_base+par_direction_code,cur_val);
  end;
dir_base+text_direction_code: begin scan_direction;
  if (no_local_dirs>0) and (abs(mode)=hmode) then begin
    @<DIR: Add local dir node@>;
    dir_dir(tail):=dir_dir(tail);
    end;
  if dir_level(text_dir_ptr)=cur_level then
    @<DIR: Remove from |text_dir_ptr|@>;
  eq_word_define(dir_base+text_direction_code,cur_val);
  @<DIR: Add to |text_dir_ptr|@>;
  if abs(mode)=hmode then
    begin
    @<DIR: Add local dir node@>;
    dir_level(tail):=cur_level;
    end;
  eq_word_define(int_base+no_local_dirs_code,no_local_dirs+1);
  eq_word_define(int_base+level_local_dir_code,cur_level);
  end;
dir_base+math_direction_code: begin scan_direction;
  eq_word_define(dir_base+math_direction_code,cur_val);
  end;
end;

@ @<DIR: Add local dir node@>=
tail_append(new_dir(text_direction))

@ @<DIR: Adjust back |text_dir_ptr| for |scan_spec|@>=
begin
flush_node_list(text_dir_ptr);
text_dir_ptr:=saved(4);
end

@ @<DIR: Add to |text_dir_ptr|@>=
begin
text_dir_tmp:=new_dir(text_direction);
vlink(text_dir_tmp):=text_dir_ptr;
text_dir_ptr:=text_dir_tmp;
end

@ @<DIR: Remove from |text_dir_ptr|@>=
begin
text_dir_tmp:=vlink(text_dir_ptr);
flush_node(text_dir_ptr);
text_dir_ptr:=text_dir_tmp;
end

@ @<DIR: Initialize |text_dir_ptr|@>=
begin
text_dir_ptr:=new_dir(0);
end

@* \[53a] The extended features of \eTeX.
The program has two modes of operation:  (1)~In \TeX\ compatibility mode
it fully deserves the name \TeX\ and there are neither extended features
nor additional primitive commands.  There are, however, a few
modifications that would be legitimate in any implementation of \TeX\
such as, e.g., preventing inadequate results of the glue to \.{DVI}
unit conversion during |ship_out|.  (2)~In extended mode there are
additional primitive commands and the extended features of \eTeX\ are
available.

The distinction between these two modes of operation initially takes
place when a `virgin' \.{eINITEX} starts without reading a format file.
Later on the values of all \eTeX\ state variables are inherited when
\.{eVIRTEX} (or \.{eINITEX}) reads a format file.

The code below is designed to work for cases where `$|init|\ldots|tini|$'
is a run-time switch.

@<Enable \eTeX, if requested@>=
@!init if format_ident=" (INITEX)" then
  begin no_new_control_sequence:=false;
  @<Generate all \eTeX\ primitives@>@;
  if buffer[iloc]="*" then incr(iloc);
  end;
tini@;@/
if not no_new_control_sequence then {just entered extended mode ?}
  no_new_control_sequence:=true@+else

@ The \eTeX\ features available in extended mode are grouped into two
categories:  (1)~Some of them are permanently enabled and have no
semantic effect as long as none of the additional primitives are
executed.  (2)~The remaining \eTeX\ features are optional and can be
individually enabled and disabled.  For each optional feature there is
an \eTeX\ state variable named \.{\\...state}; the feature is enabled,
resp.\ disabled by assigning a positive, resp.\ non-positive value to
that integer.


@d Aleph_version_code=Aleph_int {code for \.{\\Alephversion}}
@d Omega_version_code=Aleph_int+1 {code for \.{\\Omegaversion}}
@d Aleph_minor_version_code=Aleph_int+2 {code for \.{\\Alephminorversion}}
@d Omega_minor_version_code=Aleph_int+3 {code for \.{\\Omegaminorversion}}
@d eTeX_minor_version_code=Aleph_int+4 {code for \.{\\eTeXminorversion}}
@d eTeX_version_code=eTeX_int {code for \.{\\eTeXversion}}
@d Aleph_revision_code=job_name_code+1 {command code for \.{\\Alephrevision}}
@d Omega_revision_code=job_name_code+2 {command code for \.{\\Omegarevision}}
@d eTeX_revision_code=job_name_code+3 {command code for \.{\\eTeXrevision}}
@d font_identifier_code==job_name_code+4 {command code for \.{tex.fontidentifer} (lua)}

@<Generate all \eTeX...@>=
primitive_etex("lastnodetype",last_item,last_node_type_code,0);
@!@:last_node_type_}{\.{\\lastnodetype} primitive@>
primitive_aleph("Alephversion",last_item,Aleph_version_code,0);
@!@:eTeX_version_}{\.{\\Alephversion} primitive@>
primitive_aleph("Omegaversion",last_item,Omega_version_code,0);
@!@:eTeX_version_}{\.{\\Omegaversion} primitive@>
primitive_etex("eTeXversion",last_item,eTeX_version_code,0);
@!@:eTeX_version_}{\.{\\eTeXversion} primitive@>
primitive_aleph("Alephminorversion",last_item,Aleph_minor_version_code,0);
@!@:eTeX_minor_version_}{\.{\\Alephminorversion} primitive@>
primitive_aleph("Omegaminorversion",last_item,Omega_minor_version_code,0);
@!@:eTeX_minor_version_}{\.{\\Omegaminorversion} primitive@>
primitive_etex("eTeXminorversion",last_item,eTeX_minor_version_code,0);
@!@:eTeX_minor_version_}{\.{\\eTeXminorversion} primitive@>
primitive_aleph("Alephrevision",convert,Aleph_revision_code,0);@/
@!@:eTeX_revision_}{\.{\\Alephrevision} primitive@>
primitive_aleph("Omegarevision",convert,Omega_revision_code,0);@/
@!@:eTeX_revision_}{\.{\\Omegarevision} primitive@>
primitive_etex("eTeXrevision",convert,eTeX_revision_code,0);@/
@!@:eTeX_revision_}{\.{\\eTeXrevision} primitive@>

@ @<Cases of `Scan the argument for command |c|'@>=
Aleph_revision_code: do_nothing;
Omega_revision_code: do_nothing;
eTeX_revision_code: do_nothing;

@ @<Cases of `Print the result of command |c|'@>=
Aleph_revision_code: print(Aleph_revision);
Omega_revision_code: print(Omega_revision);
eTeX_revision_code: print(eTeX_revision);

@ First we implement the additional \eTeX\ parameters in the table of
equivalents.

@<Generate all \eTeX...@>=
primitive_etex("everyeof",assign_toks,every_eof_loc,local_base);
@!@:every_eof_}{\.{\\everyeof} primitive@>
primitive_etex("tracingassigns",assign_int,int_base+tracing_assigns_code,int_base);@/
@!@:tracing_assigns_}{\.{\\tracingassigns} primitive@>
primitive_etex("tracinggroups",assign_int,int_base+tracing_groups_code,int_base);@/
@!@:tracing_groups_}{\.{\\tracinggroups} primitive@>
primitive_etex("tracingifs",assign_int,int_base+tracing_ifs_code,int_base);@/
@!@:tracing_ifs_}{\.{\\tracingifs} primitive@>
primitive_etex("tracingscantokens",assign_int,int_base+tracing_scan_tokens_code,int_base);@/
@!@:tracing_scan_tokens_}{\.{\\tracingscantokens} primitive@>
primitive_etex("tracingnesting",assign_int,int_base+tracing_nesting_code,int_base);@/
@!@:tracing_nesting_}{\.{\\tracingnesting} primitive@>
primitive_etex("predisplaydirection", assign_int,int_base+pre_display_direction_code,int_base);@/
@!@:pre_display_direction_}{\.{\\predisplaydirection} primitive@>
primitive_etex("lastlinefit",assign_int,int_base+last_line_fit_code,int_base);@/
@!@:last_line_fit_}{\.{\\lastlinefit} primitive@>
primitive_etex("savingvdiscards",assign_int,int_base+saving_vdiscards_code,int_base);@/
@!@:saving_vdiscards_}{\.{\\savingvdiscards} primitive@>
primitive_etex("savinghyphcodes",assign_int,int_base+saving_hyph_codes_code,int_base);@/
@!@:saving_hyph_codes_}{\.{\\savinghyphcodes} primitive@>
primitive_luatex("suppressfontnotfounderror",assign_int,int_base+suppress_fontnotfound_error_code,int_base);@/
@!@:suppress_fontnotfound_error_code_}{\.{\\suppressfontnotfounderror} primitive@>
primitive_luatex("suppresslongerror",assign_int,int_base+suppress_long_error_code,int_base);@/
@!@:suppress_long_error_code_}{\.{\\suppresslongerror} primitive@>
primitive_luatex("suppressifcsnameerror",assign_int,int_base+suppress_ifcsname_error_code,int_base);@/
@!@:suppress_ifcsname_error_code_}{\.{\\suppressifcsnameerror} primitive@>
primitive_luatex("suppressoutererror",assign_int,int_base+suppress_outer_error_code,int_base);@/
@!@:suppress_outer_error_code_}{\.{\\suppressoutererror} primitive@>
primitive_luatex("synctex",assign_int,int_base+synctex_code,int_base);@/
@!@:synctex_}{\.{\\synctex} primitive@>

@ @d every_eof==equiv(every_eof_loc)

@ @<Cases for |print_param|@>=
tracing_assigns_code:print_esc("tracingassigns");
tracing_groups_code:print_esc("tracinggroups");
tracing_ifs_code:print_esc("tracingifs");
tracing_scan_tokens_code:print_esc("tracingscantokens");
tracing_nesting_code:print_esc("tracingnesting");
pre_display_direction_code:print_esc("predisplaydirection");
last_line_fit_code:print_esc("lastlinefit");
saving_vdiscards_code:print_esc("savingvdiscards");
saving_hyph_codes_code:print_esc("savinghyphcodes");
suppress_fontnotfound_error_code:print_esc("suppressfontnotfounderror");
suppress_long_error_code:print_esc("suppresslongerror");
suppress_outer_error_code:print_esc("suppressoutererror");
synctex_code:print_esc("synctex");

@ In order to handle \.{\\everyeof} we need an array |eof_seen| of
boolean variables.

@<Glob...@>=
@!eof_seen : array[1..max_in_open] of boolean; {has eof been seen?}

@ The |print_group| procedure prints the current level of grouping and
the name corresponding to |cur_group|.

@<Declare \eTeX\ procedures for tr...@>=
procedure print_group(@!e:boolean);
label exit;
begin case cur_group of
  bottom_level: begin print("bottom level"); return;
    end;
  simple_group,semi_simple_group:
    begin if cur_group=semi_simple_group then print("semi ");
    print("simple");
    end;
  hbox_group,adjusted_hbox_group:
    begin if cur_group=adjusted_hbox_group then print("adjusted ");
    print("hbox");
    end;
  vbox_group: print("vbox");
  vtop_group: print("vtop");
  align_group,no_align_group:
    begin if cur_group=no_align_group then print("no ");
    print("align");
    end;
  output_group: print("output");
  disc_group: print("disc");
  insert_group: print("insert");
  vcenter_group: print("vcenter");
  math_group,math_choice_group,math_shift_group,math_left_group:
    begin print("math");
    if cur_group=math_choice_group then print(" choice")
    else if cur_group=math_shift_group then print(" shift")
    else if cur_group=math_left_group then print(" left");
    end;
  end; {there are no other cases}
print(" group (level "); print_int(qo(cur_level)); print_char(")");
if saved(-1)<>0 then
  begin if e then print(" entered at line ") else print(" at line ");
  print_int(saved(-1));
  end;
exit:end;

@ The |group_trace| procedure is called when a new level of grouping
begins (|e=false|) or ends (|e=true|) with |saved(-1)| containing the
line number.

@<Declare \eTeX\ procedures for tr...@>=
@!stat procedure group_trace(@!e:boolean);
begin begin_diagnostic; print_char("{");
if e then print("leaving ") else print("entering ");
print_group(e); print_char("}"); end_diagnostic(false);
end;
tats

@ The \.{\\currentgrouplevel} and \.{\\currentgrouptype} commands return
the current level of grouping and the type of the current group
respectively.

@d current_group_level_code=eTeX_int+1 {code for \.{\\currentgrouplevel}}
@d current_group_type_code=eTeX_int+2 {code for \.{\\currentgrouptype}}

@<Generate all \eTeX...@>=
primitive_etex("currentgrouplevel",last_item,current_group_level_code,0);
@!@:current_group_level_}{\.{\\currentgrouplevel} primitive@>
primitive_etex("currentgrouptype",last_item,current_group_type_code,0);
@!@:current_group_type_}{\.{\\currentgrouptype} primitive@>

@ The \.{\\currentiflevel}, \.{\\currentiftype}, and
\.{\\currentifbranch} commands return the current level of conditionals
and the type and branch of the current conditional.

@d current_if_level_code=eTeX_int+3 {code for \.{\\currentiflevel}}
@d current_if_type_code=eTeX_int+4 {code for \.{\\currentiftype}}
@d current_if_branch_code=eTeX_int+5 {code for \.{\\currentifbranch}}

@<Generate all \eTeX...@>=
primitive_etex("currentiflevel",last_item,current_if_level_code,0);
@!@:current_if_level_}{\.{\\currentiflevel} primitive@>
primitive_etex("currentiftype",last_item,current_if_type_code,0);
@!@:current_if_type_}{\.{\\currentiftype} primitive@>
primitive_etex("currentifbranch",last_item,current_if_branch_code,0);
@!@:current_if_branch_}{\.{\\currentifbranch} primitive@>

@ The \.{\\fontcharwd}, \.{\\fontcharht}, \.{\\fontchardp}, and
\.{\\fontcharic} commands return information about a character in a
font.

@d font_char_wd_code=eTeX_dim {code for \.{\\fontcharwd}}
@d font_char_ht_code=eTeX_dim+1 {code for \.{\\fontcharht}}
@d font_char_dp_code=eTeX_dim+2 {code for \.{\\fontchardp}}
@d font_char_ic_code=eTeX_dim+3 {code for \.{\\fontcharic}}

@<Generate all \eTeX...@>=
primitive_omega("charwd",last_item,font_char_wd_code,0);
primitive_etex("fontcharwd",last_item,font_char_wd_code,0);
@!@:font_char_wd_}{\.{\\fontcharwd} primitive@>
primitive_omega("charht",last_item,font_char_ht_code,0);
primitive_etex("fontcharht",last_item,font_char_ht_code,0);
@!@:font_char_ht_}{\.{\\fontcharht} primitive@>
primitive_omega("chardp",last_item,font_char_dp_code,0);
primitive_etex("fontchardp",last_item,font_char_dp_code,0);
@!@:font_char_dp_}{\.{\\fontchardp} primitive@>
primitive_omega("charit",last_item,font_char_ic_code,0);
primitive_etex("fontcharic",last_item,font_char_ic_code,0);
@!@:font_char_ic_}{\.{\\fontcharic} primitive@>

@ The \.{\\parshapedimen}, \.{\\parshapeindent}, and \.{\\parshapelength}
commands return the indent and length parameters of the current
\.{\\parshape} specification.

@d par_shape_length_code=eTeX_dim+4 {code for \.{\\parshapelength}}
@d par_shape_indent_code=eTeX_dim+5 {code for \.{\\parshapeindent}}
@d par_shape_dimen_code=eTeX_dim+6 {code for \.{\\parshapedimen}}

@<Generate all \eTeX...@>=
primitive_etex("parshapelength",last_item,par_shape_length_code,0);
@!@:par_shape_length_}{\.{\\parshapelength} primitive@>
primitive_etex("parshapeindent",last_item,par_shape_indent_code,0);
@!@:par_shape_indent_}{\.{\\parshapeindent} primitive@>
primitive_etex("parshapedimen",last_item,par_shape_dimen_code,0);
@!@:par_shape_dimen_}{\.{\\parshapedimen} primitive@>

@ The \.{\\showgroups} command displays all currently active grouping
levels.

@d show_groups=4 { \.{\\showgroups} }

@<Generate all \eTeX...@>=
primitive_etex("showgroups",xray,show_groups,0);
@!@:show_groups_}{\.{\\showgroups} primitive@>

@ @<Cases for |show_whatever|@>=
show_groups: begin begin_diagnostic; show_save_groups;
  end;

@ @<Types...@>=
@!save_pointer=0..save_size; {index into |save_stack|}

@ The modifications of \TeX\ required for the display produced by the
|show_save_groups| procedure were first discussed by Donald~E. Knuth in
{\sl TUGboat\/} {\bf 11}, 165--170 and 499--511, 1990.
@^Knuth, Donald Ervin@>

In order to understand a group type we also have to know its mode.
Since unrestricted horizontal modes are not associated with grouping,
they are skipped when traversing the semantic nest.

@<Declare \eTeX\ procedures for use...@>=
procedure show_save_groups;
label found1,found2,found,done;
var p:0..nest_size; {index into |nest|}
@!m:integer; {mode}
@!v:save_pointer; {saved value of |save_ptr|}
@!l:quarterword; {saved value of |cur_level|}
@!c:group_code; {saved value of |cur_group|}
@!a:-1..1; {to keep track of alignments}
@!i:integer;
@!j:quarterword;
@!s:str_number;
begin p:=nest_ptr; nest[p]:=cur_list; {put the top level into the array}
v:=save_ptr; l:=cur_level; c:=cur_group;
save_ptr:=cur_boundary; decr(cur_level);@/
a:=1; s:="";
print_nl(""); print_ln;
loop@+begin print_nl("### "); print_group(true);
  if cur_group=bottom_level then goto done;
  repeat m:=nest[p].mode_field;
  if p>0 then decr(p) else m:=vmode;
  until m<>hmode;
  print(" (");
  case cur_group of
    simple_group: begin incr(p); goto found2;
      end;
    hbox_group,adjusted_hbox_group: s:="hbox";
    vbox_group: s:="vbox";
    vtop_group: s:="vtop";
    align_group: if a=0 then
        begin if m=-vmode then s:="halign" else s:="valign";
        a:=1; goto found1;
        end
      else  begin if a=1 then print("align entry") else print_esc("cr");
        if p>=a then p:=p-a;
        a:=0; goto found;
        end;
    no_align_group:
      begin incr(p); a:=-1; print_esc("noalign"); goto found2;
      end;
    output_group:
      begin print_esc("output"); goto found;
      end;
    math_group: goto found2;
    disc_group,math_choice_group:
      begin if cur_group=disc_group then print_esc("discretionary")
      else print_esc("mathchoice");
      for i:=1 to 3 do if i<=saved(-2) then print("{}");
      goto found2;
      end;
    insert_group:
      begin if saved(-2)=output_box then print_esc("vadjust")
      else  begin print_esc("insert"); print_int(saved(-2));
        end;
      goto found2;
      end;
    vcenter_group: begin s:="vcenter"; goto found1;
      end;
    semi_simple_group: begin incr(p); print_esc("begingroup"); goto found;
      end;
    math_shift_group:
      begin if m=mmode then print_char("$")
      else if nest[p].mode_field=mmode then
        begin print_cmd_chr(eq_no,saved(-2)); goto found;
        end;
      print_char("$"); goto found;
      end;
    math_left_group:
      begin if subtype(nest[p+1].eTeX_aux_field)=left_noad_side then print_esc("left")
      else print_esc("middle");
      goto found;
      end;
    end; {there are no other cases}
  @<Show the box context@>;
  found1: print_esc(s); @<Show the box packaging info@>;
  found2: print_char("{");
  found: print_char(")"); decr(cur_level);
  cur_group:=save_level(save_ptr); save_ptr:=save_index(save_ptr)
  end;
done: save_ptr:=v; cur_level:=l; cur_group:=c;
end;

@ @<Show the box packaging info@>=
if saved(-2)<>0 then
  begin print_char(" ");
  if saved(-3)=exactly then print("to") else print("spread");
  print_scaled(saved(-2)); print("pt");
  end

@ @<Show the box context@>=
i:=saved(-4);
if i<>0 then begin
  if i<box_flag then
    begin if abs(nest[p].mode_field)=vmode then j:=hmove else j:=vmove;
    if i>0 then print_cmd_chr(j,0) else print_cmd_chr(j,1);
    print_scaled(abs(i)); print("pt");
    end
  else if i<ship_out_flag then
    begin if i>=global_box_flag then
      begin print_esc("global"); i:=i-(global_box_flag-box_flag);
      end;
    print_esc("setbox"); print_int(i-box_flag); print_char("=");
    end
  else print_cmd_chr(leader_ship,i-(leader_flag-a_leaders));
  end

@ The \.{\\showtokens} command displays a token list.

@d show_tokens=5 { \.{\\showtokens} , must be odd! }

@<Generate all \eTeX...@>=
primitive_etex("showtokens",xray,show_tokens,0);
@!@:show_tokens_}{\.{\\showtokens} primitive@>

@ The \.{\\unexpanded} primitive prevents expansion of tokens much as
the result from \.{\\the} applied to a token variable.  The
\.{\\detokenize} primitive converts a token list into a list of
character tokens much as if the token list were written to a file.  We
use the fact that the command modifiers for \.{\\unexpanded} and
\.{\\detokenize} are odd whereas those for \.{\\the} and \.{\\showthe}
are even.

@<Generate all \eTeX...@>=
primitive_etex("unexpanded",the,1,0);@/
@!@:unexpanded_}{\.{\\unexpanded} primitive@>
primitive_etex("detokenize",the,show_tokens,0);@/
@!@:detokenize_}{\.{\\detokenize} primitive@>

@ The \.{\\showifs} command displays all currently active conditionals.

@d show_ifs=6 { \.{\\showifs} }

@<Generate all \eTeX...@>=
primitive_etex("showifs",xray,show_ifs,0);
@!@:show_ifs_}{\.{\\showifs} primitive@>

@
@d print_if_line(#)==if #<>0 then
  begin print(" entered on line "); print_int(#);
  end

@<Cases for |show_whatever|@>=
show_ifs: begin begin_diagnostic; print_nl(""); print_ln;
  if cond_ptr=null then
    begin print_nl("### "); print("no active conditionals");
    end
  else  begin p:=cond_ptr; n:=0;
    repeat incr(n); p:=vlink(p);@+until p=null;
    p:=cond_ptr; t:=cur_if; l:=if_line; m:=if_limit;
    repeat print_nl("### level "); print_int(n); print(": ");
    print_cmd_chr(if_test,t);
    if m=fi_code then print_esc("else");
    print_if_line(l);
    decr(n); t:=if_limit_subtype(p); l:=if_line_field(p); m:=if_limit_type(p); p:=vlink(p);
    until p=null;
    end;
  end;

@ The \.{\\interactionmode} primitive allows to query and set the
interaction mode.

@<Generate all \eTeX...@>=
primitive_etex("interactionmode",set_page_int,2,0);
@!@:interaction_mode_}{\.{\\interactionmode} primitive@>

@ @<Declare \eTeX\ procedures for use...@>=
procedure@?new_interaction; forward;@t\2@>

@ @<Cases for |alter_integer|@>=
else if c=2 then
  begin if (cur_val<batch_mode)or(cur_val>error_stop_mode) then
    begin print_err('Bad interaction mode');
@.Bad interaction mode@>
    help2('Modes are 0=batch, 1=nonstop, 2=scroll, and',
    '3=errorstop. Proceed, and I''ll ignore this case.');
    int_error(cur_val);
    end
  else  begin cur_chr:=cur_val; new_interaction;
    end;
  end

@ The |scan_tokens| feature of \eTeX\ defines the \.{\\scantokens}
primitive.

@<Generate all \eTeX...@>=
primitive_etex("scantokens",input,2,0);
@!@:scan_tokens_}{\.{\\scantokens} primitive@>
primitive_luatex("scantextokens",input,3,0);
@!@:scan_tex_tokens_}{\.{\\scantextokens} primitive@>

@ @<Generate all \eTeX...@>=
primitive_etex("readline",read_to_cs,1,0);@/
@!@:read_line_}{\.{\\readline} primitive@>

@ @<Handle \.{\\readline} and |goto done|@>=
if j=1 then
  begin while iloc<=ilimit do {current line not yet finished}
    begin cur_chr:=buffer[iloc]; incr(iloc);
    if cur_chr=" " then cur_tok:=space_token
    @+else cur_tok:=cur_chr+other_token;
    store_new_token(cur_tok);
    end;
  goto done;
  end

@ @<Generate all \eTeX...@>=
primitive_etex("unless",expand_after,1,0);@/
@!@:unless_}{\.{\\unless} primitive@>
primitive_etex("ifdefined",if_test,if_def_code,0);
@!@:if_defined_}{\.{\\ifdefined} primitive@>
primitive_etex("ifcsname",if_test,if_cs_code,0);
@!@:if_cs_name_}{\.{\\ifcsname} primitive@>
primitive_etex("iffontchar",if_test,if_font_char_code,0);
@!@:if_font_char_}{\.{\\iffontchar} primitive@>
primitive_pdftex("ifincsname",if_test,if_in_csname_code,0);
@!@:if_in_csname_}{\.{\\ifincsname} primitive@>
primitive_luatex("ifabsnum",if_test,if_abs_num_code,0);
@!@:if_abs_num_}{\.{\\ifabsnum} primitive@>
primitive_luatex("ifabsdim",if_test,if_abs_dim_code,0);
@!@:if_abs_dim_}{\.{\\ifabsdim} primitive@>
primitive_pdftex("ifpdfabsnum",if_test,if_abs_num_code,0);
@!@:if_abs_num_}{\.{\\ifpdfabsnum} primitive@>
primitive_pdftex("ifpdfabsdim",if_test,if_abs_dim_code,0);
@!@:if_abs_dim_}{\.{\\ifpdfabsdim} primitive@>

@ The |protected| feature of \eTeX\ defines the \.{\\protected} prefix
command for macro definitions.  Such macros are protected against
expansions when lists of expanded tokens are built, e.g., for \.{\\edef}
or during \.{\\write}.

@<Generate all \eTeX...@>=
primitive_etex("protected",prefix,8,0);
@!@:protected_}{\.{\\protected} primitive@>

@ A group entered (or a conditional started) in one file may end in a
different file.  Such slight anomalies, although perfectly legitimate,
may cause errors that are difficult to locate.  In order to be able to
give a warning message when such anomalies occur, \eTeX\ uses the
|grp_stack| and |if_stack| arrays to record the initial |cur_boundary|
and |cond_ptr| values for each input file.

@<Glob...@>=
@!grp_stack : array[0..max_in_open] of save_pointer; {initial |cur_boundary|}
@!if_stack : array[0..max_in_open] of pointer; {initial |cond_ptr|}

@ When a group ends that was apparently entered in a different input
file, the |group_warning| procedure is invoked in order to update the
|grp_stack|.  If moreover \.{\\tracingnesting} is positive we want to
give a warning message.  The situation is, however, somewhat complicated
by two facts:  (1)~There may be |grp_stack| elements without a
corresponding \.{\\input} file or \.{\\scantokens} pseudo file (e.g.,
error insertions from the terminal); and (2)~the relevant information is
recorded in the |name_field| of the |input_stack| only loosely
synchronized with the |in_open| variable indexing |grp_stack|.

@<Declare \eTeX\ procedures for tr...@>=
procedure group_warning;
var i:0..max_in_open; {index into |grp_stack|}
@!w:boolean; {do we need a warning?}
begin base_ptr:=input_ptr; input_stack[base_ptr]:=cur_input;
  {store current state}
i:=in_open; w:=false;
while (grp_stack[i]=cur_boundary)and(i>0) do
  begin @<Set variable |w| to indicate if this case should be reported@>;
  grp_stack[i]:=save_index(save_ptr); decr(i);
  end;
if w then
  begin print_nl("Warning: end of "); print_group(true);
@.Warning: end of...@>
  print(" of a different file"); print_ln;
  if tracing_nesting>1 then show_context;
  if history=spotless then history:=warning_issued;
  end;
end;

@ This code scans the input stack in order to determine the type of the
current input file.

@<Set variable |w| to...@>=
if tracing_nesting>0 then
  begin while (input_stack[base_ptr].state_field=token_list)or@|
    (input_stack[base_ptr].index_field>i) do decr(base_ptr);
  if input_stack[base_ptr].name_field>17 then w:=true;
  end

@ When a conditional ends that was apparently started in a different
input file, the |if_warning| procedure is invoked in order to update the
|if_stack|.  If moreover \.{\\tracingnesting} is positive we want to
give a warning message (with the same complications as above).

@<Declare \eTeX\ procedures for tr...@>=
procedure if_warning;
var i:0..max_in_open; {index into |if_stack|}
@!w:boolean; {do we need a warning?}
begin base_ptr:=input_ptr; input_stack[base_ptr]:=cur_input;
  {store current state}
i:=in_open; w:=false;
while if_stack[i]=cond_ptr do
  begin @<Set variable |w| to...@>;
  if_stack[i]:=vlink(cond_ptr); decr(i);
  end;
if w then
  begin print_nl("Warning: end of "); print_cmd_chr(if_test,cur_if);
@.Warning: end of...@>
  print_if_line(if_line); print(" of a different file"); print_ln;
  if tracing_nesting>1 then show_context;
  if history=spotless then history:=warning_issued;
  end;
end;

@ Conversely, the |file_warning| procedure is invoked when a file ends
and some groups entered or conditionals started while reading from that
file are still incomplete.

@<Declare \eTeX\ procedures for tr...@>=
procedure file_warning;
var p:pointer; {saved value of |save_ptr| or |cond_ptr|}
@!l:quarterword; {saved value of |cur_level| or |if_limit|}
@!c:quarterword; {saved value of |cur_group| or |cur_if|}
@!i:integer; {saved value of |if_line|}
begin
p:=save_ptr; l:=cur_level; c:=cur_group; save_ptr:=cur_boundary;
while grp_stack[in_open]<>save_ptr do
  begin decr(cur_level);
  print_nl("Warning: end of file when ");
@.Warning: end of file when...@>
  print_group(true); print(" is incomplete");@/
  cur_group:=save_level(save_ptr); save_ptr:=save_index(save_ptr)
  end;
save_ptr:=p; cur_level:=l; cur_group:=c; {restore old values}
p:=cond_ptr; l:=if_limit; c:=cur_if; i:=if_line;
while if_stack[in_open]<>cond_ptr do
  begin print_nl("Warning: end of file when ");
@.Warning: end of file when...@>
  print_cmd_chr(if_test,cur_if);
  if if_limit=fi_code then print_esc("else");
  print_if_line(if_line); print(" is incomplete");@/
  if_line:=if_line_field(cond_ptr); cur_if:=if_limit_subtype(cond_ptr);
  if_limit:=if_limit_type(cond_ptr); cond_ptr:=vlink(cond_ptr);
  end;
cond_ptr:=p; if_limit:=l; cur_if:=c; if_line:=i; {restore old values}
print_ln;
if tracing_nesting>1 then show_context;
if history=spotless then history:=warning_issued;
end;

@ Here are the additional \eTeX\ primitives for expressions.

@<Generate all \eTeX...@>=
primitive_etex("numexpr",last_item,eTeX_expr-int_val_level+int_val_level,0);
@!@:num_expr_}{\.{\\numexpr} primitive@>
primitive_etex("dimexpr",last_item,eTeX_expr-int_val_level+dimen_val_level,0);
@!@:dim_expr_}{\.{\\dimexpr} primitive@>
primitive_etex("glueexpr",last_item,eTeX_expr-int_val_level+glue_val_level,0);
@!@:glue_expr_}{\.{\\glueexpr} primitive@>
primitive_etex("muexpr",last_item,eTeX_expr-int_val_level+mu_val_level,0);
@!@:mu_expr_}{\.{\\muexpr} primitive@>

@ The \.{\\gluestretch}, \.{\\glueshrink}, \.{\\gluestretchorder}, and
\.{\\glueshrinkorder} commands return the stretch and shrink components
and their orders of ``infinity'' of a glue specification.

@d glue_stretch_order_code=eTeX_int+6 {code for \.{\\gluestretchorder}}
@d glue_shrink_order_code=eTeX_int+7 {code for \.{\\glueshrinkorder}}
@d glue_stretch_code=eTeX_dim+7 {code for \.{\\gluestretch}}
@d glue_shrink_code=eTeX_dim+8 {code for \.{\\glueshrink}}

@<Generate all \eTeX...@>=
primitive_etex("gluestretchorder",last_item,glue_stretch_order_code,0);
@!@:glue_stretch_order_}{\.{\\gluestretchorder} primitive@>
primitive_etex("glueshrinkorder",last_item,glue_shrink_order_code,0);
@!@:glue_shrink_order_}{\.{\\glueshrinkorder} primitive@>
primitive_etex("gluestretch",last_item,glue_stretch_code,0);
@!@:glue_stretch_}{\.{\\gluestretch} primitive@>
primitive_etex("glueshrink",last_item,glue_shrink_code,0);
@!@:glue_shrink_}{\.{\\glueshrink} primitive@>

@ The \.{\\mutoglue} and \.{\\gluetomu} commands convert ``math'' glue
into normal glue and vice versa; they allow to manipulate math glue with
\.{\\gluestretch} etc.

@d mu_to_glue_code=eTeX_glue {code for \.{\\mutoglue}}
@d glue_to_mu_code=eTeX_mu {code for \.{\\gluetomu}}

@<Generate all \eTeX...@>=
primitive_etex("mutoglue",last_item,mu_to_glue_code,0);
@!@:mu_to_glue_}{\.{\\mutoglue} primitive@>
primitive_etex("gluetomu",last_item,glue_to_mu_code,0);
@!@:glue_to_mu_}{\.{\\gluetomu} primitive@>

@ @<Glob...@>=
@!last_line_fill:pointer; {the |par_fill_skip| glue node of the new paragraph}

@ The \.{\\pagediscards} and \.{\\splitdiscards} commands share the
command code |un_vbox| with \.{\\unvbox} and \.{\\unvcopy}, they are
distinguished by their |chr_code| values |last_box_code| and
|vsplit_code|.  These |chr_code| values are larger than |box_code| and
|copy_code|.

@<Generate all \eTeX...@>=
primitive_etex("pagediscards",un_vbox,last_box_code,0);@/
@!@:page_discards_}{\.{\\pagediscards} primitive@>
primitive_etex("splitdiscards",un_vbox,vsplit_code,0);@/
@!@:split_discards_}{\.{\\splitdiscards} primitive@>

@ @<Handle saved items and |goto done|@>=
begin vlink(tail):=disc_ptr[cur_chr]; disc_ptr[cur_chr]:=null;
goto done;
end

@ The \.{\\interlinepenalties}, \.{\\clubpenalties}, \.{\\widowpenalties},
and \.{\\displaywidowpenalties} commands allow to define arrays of
penalty values to be used instead of the corresponding single values.

@d inter_line_penalties_ptr==equiv(inter_line_penalties_loc)
@d club_penalties_ptr==equiv(club_penalties_loc)
@d widow_penalties_ptr==equiv(widow_penalties_loc)
@d display_widow_penalties_ptr==equiv(display_widow_penalties_loc)

@<Generate all \eTeX...@>=
primitive_etex("interlinepenalties",set_etex_shape,inter_line_penalties_loc,etex_pen_base);@/
@!@:inter_line_penalties_}{\.{\\interlinepenalties} primitive@>
primitive_etex("clubpenalties",set_etex_shape,club_penalties_loc,etex_pen_base);@/
@!@:club_penalties_}{\.{\\clubpenalties} primitive@>
primitive_etex("widowpenalties",set_etex_shape,widow_penalties_loc,etex_pen_base);@/
@!@:widow_penalties_}{\.{\\widowpenalties} primitive@>
primitive_etex("displaywidowpenalties",set_etex_shape,display_widow_penalties_loc,etex_pen_base);@/
@!@:display_widow_penalties_}{\.{\\displaywidowpenalties} primitive@>

@ The lua interface needs some extra pascal functions. The functions
themselves are quite boring, but they are handy because otherwise this
internal stuff has to be accessed from C directly, where lots of the
pascal defines are not available.

@p function get_tex_dimen_register (j:integer):scaled;
begin
  get_tex_dimen_register := dimen(j);
end;

function set_tex_dimen_register (j:integer;v:scaled):integer;
var a:small_number;
begin  {return non-nil for error}
if global_defs>0 then  a:=4 else a:=0;
word_define(j+scaled_base,v);
set_tex_dimen_register := 0;
end;

function get_tex_skip_register (j:integer):halfword;
begin
  get_tex_skip_register := skip(j);
end;

function set_tex_skip_register (j:integer;v:halfword):integer;
var a:small_number;
begin  {return non-nil for error}
  if global_defs>0 then  a:=4 else a:=0;
  if type(v) <> glue_spec_node then
    set_tex_skip_register := 1
  else begin
    word_define(j+skip_base,v);
    set_tex_skip_register := 0;
  end;
end;

function get_tex_count_register (j:integer):scaled;
begin
  get_tex_count_register := count(j);
end;

function set_tex_count_register (j:integer;v:scaled):integer;
var a:small_number;
begin  {return non-nil for error}
  if global_defs>0 then  a:=4 else a:=0;
  word_define(j+count_base,v);
  set_tex_count_register := 0;
end;

function get_tex_attribute_register (j:integer):scaled;
begin
  get_tex_attribute_register := attribute(j);
end;

function set_tex_attribute_register (j:integer;v:scaled):integer;
var a:small_number;
begin  {return non-nil for error}
if global_defs>0 then  a:=4 else a:=0;
if (j)>max_used_attr then max_used_attr:=(j);
attr_list_cache:=cache_disabled;
word_define(j+attribute_base,v);
set_tex_attribute_register := 0;
end;

function get_tex_toks_register (j:integer):str_number;
var s:str_number;
begin
  s:="";
  if toks(j) <> min_halfword then begin
        s := tokens_to_string(toks(j));
  end;
  get_tex_toks_register := s;
end;

function set_tex_toks_register (j:integer;s:str_number):integer;
var s_pool_ptr:pool_pointer;
  ref:pointer;
  a:small_number;
  junk:pointer;
begin
  set_tex_toks_register := 0;
  s_pool_ptr := pool_ptr;
  pool_ptr := str_start_macro(s+1);
  ref := get_avail;
  junk := str_toks(str_start_macro(s));
  pool_ptr := s_pool_ptr;
  set_token_ref_count(ref,0);
  set_token_link(ref, link(temp_token_head));
  if global_defs>0 then  a:=4 else a:=0;
  define(j+toks_base,call,ref);
  flush_str(s);
end;

function get_tex_box_register (j:integer):integer;
begin
  get_tex_box_register := box(j);
end;

function set_tex_box_register (j:integer;v:scaled):integer;
var a:small_number;
begin  {return non-nil for error}
if global_defs>0 then  a:=4 else a:=0;
define(j+box_base,box_ref,v);
set_tex_box_register := 0;
end;


function get_tex_box_width (j:integer):scaled;
var q:pointer;
begin
 q := box(j);
 get_tex_box_width := 0;
 if q <> null then
    get_tex_box_width := width(q);
end;

function set_tex_box_width (j:integer;v:scaled):integer;
var q:pointer;
begin
  q := box(j);
  set_tex_box_width := 0;
  if q <> null then
    width(q) := v
  else
    set_tex_box_width := 1;
end;

function get_tex_box_height (j:integer):scaled;
var q:pointer;
begin
 q := box(j);
 get_tex_box_height := 0;
 if q <> null then
    get_tex_box_height := height(q);
end;

function set_tex_box_height (j:integer;v:scaled):integer;
var q:pointer;
begin
  q := box(j);
  set_tex_box_height := 0;
  if q <> null then
    height(q) := v
  else
    set_tex_box_height := 1;
end;

function get_tex_box_depth (j:integer):scaled;
var q:pointer;
begin
 q := box(j);
 get_tex_box_depth := 0;
 if q <> null then
    get_tex_box_depth := depth(q);
end;

function set_tex_box_depth (j:integer;v:scaled):integer;
var q:pointer;
begin
  q := box(j);
  set_tex_box_depth := 0;
  if q <> null then
    depth(q) := v
  else
    set_tex_box_depth := 1;
end;

@* \[54] $\Omega$ changes.

@
@<Create a buffer with character |cur_chr| and the following
  characters (if~any) and then apply the current active OCP filter
  to this buffer@>=
begin
run_ocp;
goto big_switch;
end;

@ @<Put each...@>=
primitive_omega("ocp", def_ocp, 0,0);
primitive_omega("externalocp", def_ocp, 1,0);
primitive_omega("ocplist", def_ocp_list, 0,0);
primitive_omega("pushocplist", push_ocp_list, 0,0);
primitive_omega("popocplist", pop_ocp_list, 0,0);
primitive_omega("clearocplists", clear_ocp_lists, 0,0);
primitive_omega("addbeforeocplist", ocp_list_op, add_before_op,0);
primitive_omega("addafterocplist", ocp_list_op, add_after_op,0);
primitive_omega("removebeforeocplist", ocp_list_op, remove_before_op,0);
primitive_omega("removeafterocplist", ocp_list_op, remove_after_op,0);
primitive_omega("ocptracelevel", ocp_trace_level, 0,0);
equiv(ocp_trace_level_base):=0;

@ @<Assignments@>=
set_ocp: begin
  print_err('To use ocps, use the '); print_esc("pushocplist");
  print(" primitive");print_ln
  end;
def_ocp: new_ocp(a);
set_ocp_list: begin
  print_err('To use ocp lists, use the ');
  print_esc("pushocplist"); print(" primitive");print_ln
  end;
def_ocp_list: new_ocp_list(a);
push_ocp_list: do_push_ocp_list(a);
pop_ocp_list: do_pop_ocp_list(a);
clear_ocp_lists: do_clear_ocp_lists(a);
ocp_list_op: begin
  print_err('To build ocp lists, use the ');
  print_esc("ocplist"); print(" primitive"); print_ln
  end;
ocp_trace_level: begin scan_optional_equals; scan_int;
  if cur_val<>0 then cur_val:=1;
  define(ocp_trace_level_base, data, cur_val);
  end;


@* \[54/SyncTeX] The {\sl Synchronize \TeX nology}.
This section is devoted to the {\sl Synchronize \TeX nology}
- or simply {\sl Sync\TeX} - used to synchronize between input and output.
This section explains how synchronization basics are implemented.
Before we enter into more technical details,
let us recall in a few words what is synchronization.

\TeX\ typesetting system clearly separates the input and the output material,
and synchronization will provide a new link between both that can help
text editors and viewers to work together.
More precisely, forwards synchronization is the ability,
given a location in the input source file,
to find what is the corresponding place in the output.
Backwards synchronization just performs the opposite:
given a location in the output,
retrieve the corresponding material in the input source file.

For better code management and maintainance, we adopt a naming convention.
Throughout this program, code related to the {\sl Synchronize \TeX nology} is tagged
with the ``{\sl synctex}'' key word. Any code extract where {\sl Sync\TeX} plays
its part, either explicitly or implicitly, (should) contain the string ``{\sl synctex}''.
This naming convention also holds for external files.
Moreover, all the code related to {\sl Sync\TeX} is gathered in this section,
except the definitions.

@ Enabling synchronization should be performed from the command line,
|synctexoption| is used for that purpose.
This global integer variable is declared here but it is not used here.
This is just a placeholder where the command line controller will put
the {\sl Sync\TeX} related options, and the {\sl Sync\TeX} controller will read them.

@ @<Glob...@>=
@!synctexoption:integer;

@ A convenient primitive is provided:
\.{\\synctex=1} in the input source file enables synchronization whereas
\.{\\synctex=0} disables it.
Its memory address is |synctex_code|.
It is initialized by the {\sl Sync\TeX} controller to the command-line option if given.
The controller may filter some reserved bits.

@ In order to give the {\sl Sync\TeX} controller read and write access to
the contents of the \.{\\synctex} primitive, we declare |synctexoffset|,
such that |mem[synctexoffset]| and \.{\\synctex} correspond to
the same memory storage. |synctexoffset| is initialized to
the correct value when quite everything is initialized.

@ @<Glob...@>=
@!synctexoffset:integer; {holds the true value of |synctex_code|}

@ @<Initialize whatever...@>=
synctexoffset:=int_base+synctex_code;

@ @<Initialize synctex primitive@>=
synctex_init_command;

@ Synchronization is achieved with the help of an auxiliary file named
`\.{{\sl jobname}.synctex}' ({\sl jobname} is the contents of the
\.{\\jobname} macro), where a {\sl Sync\TeX} controller implemented
in the external |synctex.c| file will store geometrical information.
This {\sl Sync\TeX} controller will take care of every technical details
concerning the {\sl Sync\TeX} file, we will only focus on the messages
the controller will receive from the \TeX\ program.

The most accurate synchronization information should allow to map
any character of the input source file to the corresponding location
in the output, if relevant.
Ideally, the synchronization information of the input material consists of
the file name, the line and column numbers of every character.
The synchronization information in the output is simply the page number and
either point coordinates, or box dimensions and position.
The problem is that the mapping between these informations is only known at
ship out time, which means that we must keep track of the input
synchronization information until the pages ship out.

As \TeX\ only knows about file names and line numbers,
but forgets the column numbers, we only consider a
restricted input synchronization information called {\sl Sync\TeX\ information}.
It consists of a unique file name identifier, the {\sl Sync\TeX\ file tag},
and the line number.

Keeping track of such information,
should be different whether characters or nodes are involved.
Actually, only certain nodes are involved in {\sl Sync\TeX},
we call them {\sl synchronized nodes}.
Synchronized nodes store the {\sl Sync\TeX} information in their last two words:
the first one contains a {\sl Sync\TeX\ file tag} uniquely identifying
the input file, and the second one contains the current line number,
as returned by the \.{\\inputlineno} primitive.
The |synctex_field_size| macro contains the necessary size to store
the {\sl Sync\TeX} information in a node.

When declaring the size of a new node, it is recommanded to use the following
convention: if the node is synchronized, use a definition similar to
|my_synchronized_node_size|={\sl xxx}+|synctex_field_size|.
Moreover, one should expect that the {\sl Sync\TeX} information is always stored
in the last two words of a synchronized node.

@ By default, every node with a sufficiently big size is initialized
at creation time in the |get_node| routine with the current
{\sl Sync\TeX} information, whether or not the node is synchronized.
One purpose is to set this information very early in order to minimize code
dependencies, including forthcoming extensions.
Another purpose is to avoid the assumption that every node type has a dedicated getter,
where initialization should take place. Actually, it appears that some nodes are created
using directly the |get_node| routine and not the dedicated constructor.
And finally, initializing the node at only one place is less error prone.

@ Instead of storing the input file name, it is better to store just an identifier.
Each time \TeX\ opens a new file, it notifies the {\sl Sync\TeX} controller with
a |synctex_start_input| message.
This controller will create a new {\sl Sync\TeX} file tag and
will update the current input state record accordingly.
If the input comes from the terminal or a pseudo file, the |synctex_tag| is set to 0.
It results in automatically disabling synchronization for material
input from the terminal or pseudo files.

@ @<Close {\sl Sync\TeX} file and write status@>=
synctex_terminate(log_opened); {Let the {\sl Sync\TeX} controller close its files.}

@ Synchronized nodes are boxes, math, kern and glue nodes.
Other nodes should be synchronized too, in particular math noads.
\TeX\ assumes that math, kern and glue nodes have the same size,
this is why both are synchronized.
{\sl In fine}, only horizontal lists are really used in {\sl Sync\TeX},
but all box nodes are considered the same with respect to synchronization,
because a box node type is allowed to change at execution time.

@ {\sl Nota Bene:}
The {\sl Sync\TeX} code is very close to the memory model.
It is not connected to any other part of the code,
except for memory management. It is possible to neutralize the {\sl Sync\TeX} code
rather simply. The first step is to define a null |synctex_field_size|.
The second step is to comment out the code in ``Initialize bigger nodes...'' and every
``Copy ... {\sl Sync\TeX} information''.
The last step will be to comment out the |synctex_tag_field| related code in the
definition of |synctex_tag| and the various ``Prepare ... {\sl Sync\TeX} information''.
Then all the remaining code should be just harmless.
The resulting program would behave exactly the same as if absolutely no {\sl Sync\TeX}
related code was there, including memory management.
Of course, all this assumes that {\sl Sync\TeX} is turned off from the command line.
@^synctex@>
@^synchronization@>

@* \[54] System-dependent changes.
This section should be replaced, if necessary, by any special
modifications of the program
that are necessary to make \TeX\ work at a particular installation.
It is usually best to design your change file so that all changes to
previous sections preserve the section numbering; then everybody's version
will be consistent with the published program. More extensive changes,
which introduce new sections, can be inserted here; then only the index
itself will get a new section number.
@^system dependencies@>

@* \[55] Index.
Here is where you can find all uses of each identifier in the program,
with underlined entries pointing to where the identifier was defined.
If the identifier is only one letter long, however, you get to see only
the underlined entries. {\sl All references are to section numbers instead of
page numbers.}

This index also lists error messages and other aspects of the program
that you might want to look up some day. For example, the entry
for ``system dependencies'' lists all sections that should receive
special attention from people who are installing \TeX\ in a new
operating environment. A list of various things that can't happen appears
under ``this can't happen''. Approximately 40 sections are listed under
``inner loop''; these account for about 60\pct! of \TeX's running time,
exclusive of input and output.
