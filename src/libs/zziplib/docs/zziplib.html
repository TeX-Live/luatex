<html><head><title>zziplibautodoc documentation </title></head>
<body>

<h1>zziplib <small><small><i>- 0.13.47</i></small></small></h1>
<table border=0 cellspacing=2 cellpadding=0><tr valign="top">
  <td valign="top"><code>int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#__zzip_fetch_disk_trailer">
                       <code>__zzip_fetch_disk_trailer</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>int fd</nobr>,
<nobr>zzip_off_t filesize</nobr>,
<nobr>struct _disk_trailer * _zzip_restrict trailer</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>uint32_t </code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#__zzip_get32">
                       <code>__zzip_get32</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>unsigned char * s</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>uint16_t </code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#__zzip_get16">
                       <code>__zzip_get16</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>unsigned char * s</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>uint64_t </code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#__zzip_get64">
                       <code>__zzip_get64</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>unsigned char * s</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>void </code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#__zzip_set32">
                       <code>__zzip_set32</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>unsigned char * s</nobr>,
<nobr>uint32_t v</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>void </code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#__zzip_set16">
                       <code>__zzip_set16</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>unsigned char * s</nobr>,
<nobr>uint16_t v</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>void </code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#__zzip_set64">
                       <code>__zzip_set64</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>unsigned char * s</nobr>,
<nobr>uint64_t v</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#__zzip_parse_root_directory">
                       <code>__zzip_parse_root_directory</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>int fd</nobr>,
<nobr>struct _disk_trailer * trailer</nobr>,
<nobr>struct zzip_dir_hdr ** hdr_return</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#__zzip_try_open">
                       <code>__zzip_try_open</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>int filemode</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_closedir">
                       <code>zzip_closedir</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip_char_t*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_compr_str">
                       <code>zzip_compr_str</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>int compr</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_DIR*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_createdir">
                       <code>zzip_createdir</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_DIR*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_alloc_ext_io">
                       <code>zzip_dir_alloc_ext_io</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_strings_t* ext</nobr>,
<nobr>const zzip_plugin_io_t io</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>ZZIP_DIR*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_alloc">
                       <code>zzip_dir_alloc</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_strings_t* fileext</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_DIR*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_creat">
                       <code>zzip_dir_creat</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>ZZIP_DIR*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_creat_ext_io">
                       <code>zzip_dir_creat_ext_io</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_DIR * 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_fdopen">
                       <code>zzip_dir_fdopen</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>int fd</nobr>,
<nobr>zzip_error_t * errcode_p</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>ZZIP_DIR * 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_fdopen_ext_io">
                       <code>zzip_dir_fdopen_ext_io</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>int fd</nobr>,
<nobr>zzip_error_t * errcode_p</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>const zzip_plugin_io_t io</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_free">
                       <code>zzip_dir_free</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR * dir</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_close">
                       <code>zzip_dir_close</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR * dir</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_DIR* 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_open">
                       <code>zzip_dir_open</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>zzip_error_t* e</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>ZZIP_DIR* 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_open_ext_io">
                       <code>zzip_dir_open_ext_io</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>zzip_error_t* e</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_read">
                       <code>zzip_dir_read</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR * dir</nobr>,
<nobr>ZZIP_DIRENT * d</nobr> )</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_stat">
                       <code>zzip_dir_stat</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR * dir</nobr>,
<nobr>zzip_char_t* name</nobr>,
<nobr>ZZIP_STAT * zs</nobr>,
<nobr>int flags</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int </code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_file_stat">
                       <code>zzip_file_stat</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE* file</nobr>,
<nobr>ZZIP_STAT* zs</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int </code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_fstat">
                       <code>zzip_fstat</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE* file</nobr>,
<nobr>ZZIP_STAT* zs</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_DIR * 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dirhandle">
                       <code>zzip_dirhandle</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE * fp</nobr>)</code>
   
</td>

</tr><tr valign="top">
  <td valign="top"><code>int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dirfd">
                       <code>zzip_dirfd</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>
   
</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip_byte_t*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_entry_to_data">
                       <code>zzip_disk_entry_to_data</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>struct zzip_disk_entry* entry</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>struct zzip_file_header*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_entry_to_file_header">
                       <code>zzip_disk_entry_to_file_header</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>struct zzip_disk_entry* entry</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip__new__ char*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_entry_strdup_name">
                       <code>zzip_disk_entry_strdup_name</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>struct zzip_disk_entry* entry</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip__new__ char*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_entry_strdup_comment">
                       <code>zzip_disk_entry_strdup_comment</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>struct zzip_disk_entry* entry</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>struct zzip_disk_entry*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_findfile">
                       <code>zzip_disk_findfile</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>char* filename</nobr>,
<nobr>struct zzip_disk_entry* after</nobr>,
<nobr>zzip_strcmp_fn_t compare</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>struct zzip_disk_entry*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_findfirst">
                       <code>zzip_disk_findfirst</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>struct zzip_disk_entry*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_findnext">
                       <code>zzip_disk_findnext</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>struct zzip_disk_entry* entry</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>struct zzip_disk_entry*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_findmatch">
                       <code>zzip_disk_findmatch</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>char* filespec</nobr>,
<nobr>struct zzip_disk_entry* after</nobr>,
<nobr>zzip_fnmatch_fn_t compare</nobr>,
<nobr>int flags</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_DISK_FILE*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_fopen">
                       <code>zzip_disk_fopen</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>char* filename</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_DISK_FILE*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_entry_fopen">
                       <code>zzip_disk_entry_fopen</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>ZZIP_DISK_ENTRY* entry</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip_size_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_fread">
                       <code>zzip_disk_fread</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>void* ptr</nobr>,
<nobr>zzip_size_t sized</nobr>,
<nobr>zzip_size_t nmemb</nobr>,
<nobr>ZZIP_DISK_FILE* file</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_fclose">
                       <code>zzip_disk_fclose</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK_FILE* file</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_feof">
                       <code>zzip_disk_feof</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK_FILE* file</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_DISK*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_mmap">
                       <code>zzip_disk_mmap</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>int fd</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_init">
                       <code>zzip_disk_init</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>void* buffer</nobr>,
<nobr>zzip_size_t buflen</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_DISK*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_new">
                       <code>zzip_disk_new</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>void</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_munmap">
                       <code>zzip_disk_munmap</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>ZZIP_DISK* zzip__new__
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_open">
                       <code>zzip_disk_open</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>char* filename</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_disk_close">
                       <code>zzip_disk_close</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip_off_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_data_offset">
                       <code>zzip_entry_data_offset</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_ENTRY* entry</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>static zzip_off_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_fread_file_header">
                       <code>zzip_entry_fread_file_header</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_ENTRY* entry</nobr>,
<nobr>struct zzip_file_header* file_header</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip__new__ char*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_strdup_name">
                       <code>zzip_entry_strdup_name</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_ENTRY* entry</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_ENTRY*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_findfile">
                       <code>zzip_entry_findfile</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>FILE* disk</nobr>,
<nobr>char* filename</nobr>,
<nobr>ZZIP_ENTRY* _zzip_restrict entry</nobr>,
<nobr>zzip_strcmp_fn_t compare</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_ENTRY*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_findfirst">
                       <code>zzip_entry_findfirst</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>FILE* disk</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_ENTRY*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_findnext">
                       <code>zzip_entry_findnext</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_ENTRY* _zzip_restrict entry</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_free">
                       <code>zzip_entry_free</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_ENTRY* entry</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_ENTRY*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_findmatch">
                       <code>zzip_entry_findmatch</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>FILE* disk</nobr>,
<nobr>char* filespec</nobr>,
<nobr>ZZIP_ENTRY* _zzip_restrict entry</nobr>,
<nobr>zzip_fnmatch_fn_t compare</nobr>,
<nobr>int flags</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_ENTRY_FILE*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_fopen">
                       <code>zzip_entry_fopen</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_ENTRY* entry</nobr>,
<nobr>int takeover</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_ENTRY_FILE*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_ffile">
                       <code>zzip_entry_ffile</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>FILE* disk</nobr>,
<nobr>char* filename</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip_size_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_fread">
                       <code>zzip_entry_fread</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>void* ptr</nobr>,
<nobr>zzip_size_t sized</nobr>,
<nobr>zzip_size_t nmemb</nobr>,
<nobr>ZZIP_ENTRY_FILE* file</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_fclose">
                       <code>zzip_entry_fclose</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_ENTRY_FILE* file</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_entry_feof">
                       <code>zzip_entry_feof</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_ENTRY_FILE* file</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_errno">
                       <code>zzip_errno</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>int errcode</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_error">
                       <code>zzip_error</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR * dir</nobr>)</code>
   
</td>

</tr><tr valign="top">
  <td valign="top"><code>void 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_seterror">
                       <code>zzip_seterror</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR * dir</nobr>,
<nobr>int errcode</nobr>)</code>
   
</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_fclose">
                       <code>zzip_fclose</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE * fp</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_close">
                       <code>zzip_close</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE* fp</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_file_close">
                       <code>zzip_file_close</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE * fp</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_FILE*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_file_creat">
                       <code>zzip_file_creat</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR* dir</nobr>,
<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_file_mkdir">
                       <code>zzip_file_mkdir</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR* dir</nobr>,
<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_FILE * 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_file_open">
                       <code>zzip_file_open</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR * dir</nobr>,
<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip_ssize_t 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_file_read">
                       <code>zzip_file_read</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE * fp</nobr>,
<nobr>char * buf</nobr>,
<nobr>zzip_size_t len</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_file_real">
                       <code>zzip_file_real</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE* fp</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_dir_real">
                       <code>zzip_dir_real</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>void*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_realdir">
                       <code>zzip_realdir</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_realfd">
                       <code>zzip_realfd</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE* fp</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_FILE*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_fopen">
                       <code>zzip_fopen</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>zzip_char_t* mode</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>ZZIP_FILE*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_freopen">
                       <code>zzip_freopen</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>zzip_char_t* mode</nobr>,
<nobr>ZZIP_FILE* stream</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>static int 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_inflate_init">
                       <code>zzip_inflate_init</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE * fp</nobr>,
<nobr>struct zzip_dir_hdr* hdr</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int </code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_init_io">
                       <code>zzip_init_io</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_plugin_io_handlers_t io</nobr>,
<nobr>int flags</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip_plugin_io_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_get_default_io">
                       <code>zzip_get_default_io</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr></nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_MEM_DISK*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_mem_disk_fdopen">
                       <code>zzip_mem_disk_fdopen</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>int fd</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>long
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_mem_disk_load">
                       <code>zzip_mem_disk_load</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_MEM_DISK* dir</nobr>,
<nobr>ZZIP_DISK* disk</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_MEM_DISK*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_mem_disk_open">
                       <code>zzip_mem_disk_open</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>char* filename</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip__new__ ZZIP_MEM_ENTRY*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_mem_entry_new">
                       <code>zzip_mem_entry_new</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>ZZIP_DISK_ENTRY* entry</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int inline
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_mkdir">
                       <code>zzip_mkdir</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>ZZIP_FILE* inline
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_creat">
                       <code>zzip_creat</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>void inline
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_mkfifo">
                       <code>zzip_mkfifo</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>void inline
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_sync">
                       <code>zzip_sync</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>void</nobr>)</code>
 
</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_FILE*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_open">
                       <code>zzip_open</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>int o_flags</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>ZZIP_FILE*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_open_ext_io">
                       <code>zzip_open_ext_io</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>int o_flags</nobr>,
<nobr>int o_modes</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>ZZIP_FILE*
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_open_shared_io">
                       <code>zzip_open_shared_io</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE* stream</nobr>,
<nobr>zzip_char_t* filename</nobr>,
<nobr>int o_flags</nobr>,
<nobr>int o_modes</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_DIR* 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_opendir">
                       <code>zzip_opendir</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* filename</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>ZZIP_DIR* 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_opendir_ext_io">
                       <code>zzip_opendir_ext_io</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>int o_modes</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip_ssize_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_read">
                       <code>zzip_read</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE * fp</nobr>,
<nobr>char * buf</nobr>,
<nobr>zzip_size_t len</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip_size_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_fread">
                       <code>zzip_fread</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>void *ptr</nobr>,
<nobr>zzip_size_t size</nobr>,
<nobr>zzip_size_t nmemb</nobr>,
<nobr>ZZIP_FILE *file</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>ZZIP_DIRENT* 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_readdir">
                       <code>zzip_readdir</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR * dir</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>int
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_rewind">
                       <code>zzip_rewind</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE *fp</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>void 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_rewinddir">
                       <code>zzip_rewinddir</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR * dir</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip_off_t 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_telldir">
                       <code>zzip_telldir</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>void
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_seekdir">
                       <code>zzip_seekdir</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR* dir</nobr>,
<nobr>zzip_off_t offset</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip_off_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_seek">
                       <code>zzip_seek</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE * fp</nobr>,
<nobr>zzip_off_t offset</nobr>,
<nobr>int whence</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip_char_t* 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_strerror">
                       <code>zzip_strerror</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>int errcode</nobr>)</code>

</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip_char_t* 
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_strerror_of">
                       <code>zzip_strerror_of</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip_off_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_tell">
                       <code>zzip_tell</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE * fp</nobr>)</code>

</td>
</tr>
<tr valign="top">
  <td valign="top"><code>zzip_ssize_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_write">
                       <code>zzip_write</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE* file</nobr>,
<nobr>const void* ptr</nobr>,
<nobr>zzip_size_t len</nobr>)</code>
 
</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip_ssize_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_file_write">
                       <code>zzip_file_write</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>ZZIP_FILE* file</nobr>,
<nobr>const void* ptr</nobr>,
<nobr>zzip_size_t len</nobr>)</code>
 
</td>

</tr><tr valign="top">
  <td valign="top"><code>zzip_size_t
</code></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top"><a href="#zzip_fwrite">
                       <code>zzip_fwrite</code>  </a></td>
  <td valign="top">&nbsp;&nbsp;</td>
  <td valign="top">
 <code>(<nobr>const void* ptr</nobr>,
<nobr>zzip_size_t len</nobr>,
<nobr>zzip_size_t multiply</nobr>,
<nobr>ZZIP_FILE* file</nobr>)</code>
 
</td>
</tr>

</table>
<h3>Documentation</h3>

<dl>
<dt><a name="__zzip_fetch_disk_trailer" />
  <code>int 
</code>
  <br /><b><code>__zzip_fetch_disk_trailer</code></b>
   &nbsp; <code>
 <code>(<nobr>int fd</nobr>,
<nobr>zzip_off_t filesize</nobr>,
<nobr>struct _disk_trailer * _zzip_restrict trailer</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/zip.c)

</em></para><p>
 <br />  <function>The __zzip_fetch_disk_trailer function</function> is used by <a href="#zzip_file_open"><code>zzip_file_open</code></a>. It tries to find
 <br />  the zip's central directory info that is usually a few
 <br />  bytes off the end of the file.
 
</p>
<p align="right"><small>(../../zzip/zip.c)</small></p></dd>
<dt><a name="__zzip_get32" /> <a name="__zzip_get16" /> <a name="__zzip_get64" /> <a name="__zzip_set32" /> <a name="__zzip_set16" /> <a name="__zzip_set64" />
  <code>uint32_t </code>
  <br /><b><code>__zzip_get32</code></b>
   &nbsp; <code>
 <code>(<nobr>unsigned char * s</nobr>)</code>

</code>

<br />  <code>uint16_t </code>
  <br /><b><code>__zzip_get16</code></b>
   &nbsp; <code>
 <code>(<nobr>unsigned char * s</nobr>)</code>

</code>

<br />  <code>uint64_t </code>
  <br /><b><code>__zzip_get64</code></b>
   &nbsp; <code>
 <code>(<nobr>unsigned char * s</nobr>)</code>

</code>

<br />  <code>void </code>
  <br /><b><code>__zzip_set32</code></b>
   &nbsp; <code>
 <code>(<nobr>unsigned char * s</nobr>,
<nobr>uint32_t v</nobr>)</code>

</code>

<br />  <code>void </code>
  <br /><b><code>__zzip_set16</code></b>
   &nbsp; <code>
 <code>(<nobr>unsigned char * s</nobr>,
<nobr>uint16_t v</nobr>)</code>

</code>

<br />  <code>void </code>
  <br /><b><code>__zzip_set64</code></b>
   &nbsp; <code>
 <code>(<nobr>unsigned char * s</nobr>,
<nobr>uint64_t v</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/fetch.c)

</em></para><p>
 <br />  Make 32 bit value in host byteorder from little-endian mapped octet-data
 <br />  (works also on machines which SIGBUS on misaligned data access (eg. 68000))
 
</p>
<p>
 <br />  <function>The __zzip_get16 function</function> does the same for a 16 bit value.
 
</p>
<p>
 <br />  <function>The __zzip_get64 function</function> does the same for an off64_t value.
 
</p>
<p>
 <br />  <function>The __zzip_set32 function</function> pushes a 32bit value at the specified address
 
</p>
<p>
 <br />  <function>The __zzip_set16 function</function> does the same for a 16 bit value.
 
</p>
<p>
 <br />  <function>The __zzip_set64 function</function> pushes a off64_t value at the specified address
 
</p>
<p align="right"><small>(../../zzip/fetch.c)</small></p></dd>
<dt><a name="__zzip_parse_root_directory" />
  <code>int 
</code>
  <br /><b><code>__zzip_parse_root_directory</code></b>
   &nbsp; <code>
 <code>(<nobr>int fd</nobr>,
<nobr>struct _disk_trailer * trailer</nobr>,
<nobr>struct zzip_dir_hdr ** hdr_return</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/zip.c)

</em></para><p>
 <br />  <function>The __zzip_parse_root_directory function</function> is used by <a href="#zzip_file_open"><code>zzip_file_open</code></a>, it is usually called after
 <br />  <code>__zzip_find_disk_trailer</code>. It will parse the zip's central directory
 <br />  information and create a zziplib private directory table in
 <br />  memory.
 
</p>
<p align="right"><small>(../../zzip/zip.c)</small></p></dd>
<dt><a name="__zzip_try_open" />
  <code>int
</code>
  <br /><b><code>__zzip_try_open</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>int filemode</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/zip.c)

</em></para><p>
 <br />  will attach a .zip extension and tries to open it
 <br />  the with <code>open</code>(2). This is a helper function for
 <br />  <a href="#zzip_dir_open"><code>zzip_dir_open</code></a>, <a href="#zzip_opendir"><code>zzip_opendir</code></a> and <a href="#zzip_open"><code>zzip_open</code></a>.
 
</p>
<p align="right"><small>(../../zzip/zip.c)</small></p></dd>
<dt><a name="zzip_closedir" />
  <code>int
</code>
  <br /><b><code>zzip_closedir</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/dir.c)

</em></para><p>
 <br />  <function>The zzip_closedir function</function> is the equivalent of <code>closedir</code>(3) for a realdir or zipfile.

</p><p>

   <function>The zzip_closedir function</function> is magic - if the given arg-ZZIP_DIR
 <br />  is a real directory, it will call the real <code>closedir</code>(3) and then
 <br />  free the wrapping ZZIP_DIR structure. Otherwise it will divert 
 <br />  to <a href="#zzip_dir_close"><code>zzip_dir_close</code></a> which will free the ZZIP_DIR structure.
 
</p>
<p align="right"><small>(../../zzip/dir.c)</small></p></dd>
<dt><a name="zzip_compr_str" />
  <code>zzip_char_t*
</code>
  <br /><b><code>zzip_compr_str</code></b>
   &nbsp; <code>
 <code>(<nobr>int compr</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/info.c)

</em></para><p>
 <br />  return static const string of the known compression methods, 
 <br />  otherwise just "zipped" is returned
 
</p>
<p align="right"><small>(../../zzip/info.c)</small></p></dd>
<dt><a name="zzip_createdir" />
  <code>ZZIP_DIR*
</code>
  <br /><b><code>zzip_createdir</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; create a new archive area for writing


</em></para><p>

</p><p>

   <function>The zzip_createdir function</function> will create a new archive area. This may either be a
 <br />  a new zip archive or a new directory in the filesystem. The returned 
 <br />  parameter is a new "zzip dir" handle that should be saved to a variable 
 <br />  so it can be used a base argument for <a href="#zzip_file_mkdir"><code>zzip_file_mkdir</code></a> and 
 <br />  <a href="#zzip_file_creat"><code>zzip_file_creat</code></a> calls.  The returned handle wraps both possibilities,
 <br />  it can be representing a zip central directory that must be
 <br />  saved to disk using <a href="#zzip_closedir"><code>zzip_closedir</code></a> or it is just a handle for the
 <br />  name of the real directory that still must be run through 
 <br />  <a href="#zzip_closedir"><code>zzip_closedir</code></a> to release the wrapper around the directory name.

</p><p>

   The magic is pushed through the o_mode argument. Using a mode that
 <br />  has no group-write bit set (S_IWGRP = 0040) then the file is
 <br />  created as a zip directory. Note that this is unabridged of any
 <br />  umask value in the system where the argument to <function>the zzip_createdir function</function> could
 <br />  be 0775 but with an umask of 0755 it turns out as 0755 for a real
 <br />  directory. Using 0755 directly would not create it as a real directory
 <br />  but as a zip archive handle.

</p><p>

   <function>The zzip_createdir function</function> is not yet implemented, check for #def ZZIP_NO_CREAT
 <br />  Write-support will extend <a href="#zzip_closedir"><code>zzip_closedir</code></a> with semantics to finalize the
 <br />  zip-archive by writing the zip-trailer and closing the archive file.

</p><p>

   Returns null on error and sets errno. Remember, according to posix
 <br />  the <code>creat</code>(2) call is equivalent to 
 <pre>  open (path, O_WRONLY | O_CREAT | O_TRUNC, o_mode) </pre> 
 <br />  so any previous zip-archive will be overwritten unconditionally and
 <br />  EEXIST errors from <code>mkdir</code>(2) are suppressed. (fixme: delete the
 <br />  given subtree? like suggested by O_TRUNC? not done so far!)
 
</p>
<p align="right"><small>(../../zzip/write.c)</small></p></dd>
<dt><a name="zzip_dir_alloc_ext_io" /> <a name="zzip_dir_alloc" />
  <code>ZZIP_DIR*
</code>
  <br /><b><code>zzip_dir_alloc_ext_io</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_strings_t* ext</nobr>,
<nobr>const zzip_plugin_io_t io</nobr>)</code>

</code>

<br />  <code>ZZIP_DIR*
</code>
  <br /><b><code>zzip_dir_alloc</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_strings_t* fileext</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/zip.c)

</em></para><p>
 <br />  allocate a new ZZIP_DIR handle and do basic 
 <br />  initializations before usage by <a href="#zzip_dir_fdopen"><code>zzip_dir_fdopen</code></a>
 <br />  <a href="#zzip_dir_open"><code>zzip_dir_open</code></a> <a href="#zzip_file_open"><code>zzip_file_open</code></a> or through
 <br />  <a href="#zzip_open"><code>zzip_open</code></a>
 <br />  (ext==null flags uses { ".zip" , ".ZIP" } )
 <br />  (io ==null flags use of posix io defaults)
 
</p>
<p>
 <br />  <function>the zzip_dir_alloc function</function> is obsolete - it was generally used for implementation
 <br />  and exported to let other code build on it. It is now advised to
 <br />  use <a href="#zzip_dir_alloc_ext_io"><code>zzip_dir_alloc_ext_io</code></a> now on explicitly, just set that second
 <br />  argument to zero to achieve the same functionality as the old style.
 
</p>
<p align="right"><small>(../../zzip/zip.c)</small></p></dd>
<dt><a name="zzip_dir_creat" /> <a name="zzip_dir_creat_ext_io" />
  <code>ZZIP_DIR*
</code>
  <br /><b><code>zzip_dir_creat</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</code>

<br />  <code>ZZIP_DIR*
</code>
  <br /><b><code>zzip_dir_creat_ext_io</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; create a new zip archive for writing


</em></para><p>

</p><p>

   <function>The zzip_dir_creat function</function> will create a new zip archive. The returned parameter 
 <br />  is a new "zzip dir" handle that should be saved to a variable so it
 <br />  can be used a base argument for <a href="#zzip_mkdir"><code>zzip_mkdir</code></a> and <a href="#zzip_creat"><code>zzip_creat</code></a> calls.
 <br />  The returned handle represents a zip central directory that must be
 <br />  saved to disk using <a href="#zzip_closedir"><code>zzip_closedir</code></a>.

</p><p>

   Returns null on error and sets errno. Remember, according to posix
 <br />  the <code>creat</code>(2) call is equivalent to 
 <pre>  open (path, O_WRONLY | O_CREAT | O_TRUNC, o_mode) </pre> 
 <br />  so any previous zip-archive will be overwritten unconditionally and
 <br />  EEXIST errors from <code>mkdir</code>(2) are suppressed. (fixme: delete the
 <br />  given subtree? like suggested by O_TRUNC? not done so far!)
 
</p>
<p>

</p><p>

   If the third argument "ext" has another special meaning here, as it
 <br />  is used to ensure that a given zip-file is created with the first entry 
 <br />  of the ext-list appended as an extension unless the file-path already 
 <br />  ends with a file-extension registered in the list. Therefore {"",0} 
 <br />  matches all files and creates them as zip-archives under the given 
 <br />  nonmodified name. (Some magic here? If the path ends in the path
 <br />  separator then make a real directory even in the presence of ext-list?)

</p><p>

   <function>The zzip_dir_creat_ext_io function</function> is not yet implemented, check for #def ZZIP_NO_CREAT
 <br />  Write-support will extend <a href="#zzip_closedir"><code>zzip_closedir</code></a> with semantics to finalize the
 <br />  zip-archive by writing the zip-trailer and closing the archive file.
 
</p>
<p align="right"><small>(../../zzip/write.c)</small></p></dd>
<dt><a name="zzip_dir_fdopen" /> <a name="zzip_dir_fdopen_ext_io" />
  <code>ZZIP_DIR * 
</code>
  <br /><b><code>zzip_dir_fdopen</code></b>
   &nbsp; <code>
 <code>(<nobr>int fd</nobr>,
<nobr>zzip_error_t * errcode_p</nobr>)</code>

</code>

<br />  <code>ZZIP_DIR * 
</code>
  <br /><b><code>zzip_dir_fdopen_ext_io</code></b>
   &nbsp; <code>
 <code>(<nobr>int fd</nobr>,
<nobr>zzip_error_t * errcode_p</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>const zzip_plugin_io_t io</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/zip.c)

</em></para><p>
 <br />  used by the <a href="#zzip_dir_open"><code>zzip_dir_open</code></a> and zzip_opendir(2) call. Opens the
 <br />  zip-archive as specified with the fd which points to an
 <br />  already openend file. <function>The zzip_dir_fdopen function</function> then search and parse
 <br />  the zip's central directory.

</p><p>

   NOTE: refcount is zero, so an _open/_close pair will also delete 
 <br />        this _dirhandle 
 
</p>
<p>
 <br />  <function>the zzip_dir_fdopen_ext_io function</function> uses explicit ext and io instead of the internal 
 <br />  defaults, setting these to zero is equivalent to <a href="#zzip_dir_fdopen"><code>zzip_dir_fdopen</code></a>
 
</p>
<p align="right"><small>(../../zzip/zip.c)</small></p></dd>
<dt><a name="zzip_dir_free" /> <a name="zzip_dir_close" />
  <code>int 
</code>
  <br /><b><code>zzip_dir_free</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR * dir</nobr>)</code>

</code>

<br />  <code>int 
</code>
  <br /><b><code>zzip_dir_close</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR * dir</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/zip.c)

</em></para><p>
 <br />  will free the zzip_dir handle unless there are still 
 <br />  zzip_files attached (that may use its cache buffer).
 <br />  This is the inverse of <a href="#zzip_dir_alloc"><code>zzip_dir_alloc</code></a> , and both
 <br />  are helper functions used implicitly in other zzipcalls
 <br />  e.g. <a href="#zzip_dir_close"><code>zzip_dir_close</code></a> = zzip_close 

</p><p>

   returns zero on sucess
 <br />  returns the refcount when files are attached.
 
</p>
<p><small><code>zzip_dir_close</code></small> -
 <br />  It will also <code>free</code>(2) the <code>ZZIP_DIR</code>-handle given. 
 <br />  the counterpart for <a href="#zzip_dir_open"><code>zzip_dir_open</code></a>
 <br />  see also <a href="#zzip_dir_free"><code>zzip_dir_free</code></a>
 
</p>
<p align="right"><small>(../../zzip/zip.c)</small></p></dd>
<dt><a name="zzip_dir_open" /> <a name="zzip_dir_open_ext_io" /> <a name="zzip_dir_read" />
  <code>ZZIP_DIR* 
</code>
  <br /><b><code>zzip_dir_open</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>zzip_error_t* e</nobr>)</code>

</code>

<br />  <code>ZZIP_DIR* 
</code>
  <br /><b><code>zzip_dir_open_ext_io</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>zzip_error_t* e</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_dir_read</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR * dir</nobr>,
<nobr>ZZIP_DIRENT * d</nobr> )</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/zip.c)

</em></para><p>
 <br />  Opens the zip-archive (if available).
 <br />  the two ext_io arguments will default to use posix io and 
 <br />  a set of default fileext that can atleast add .zip ext itself.
 
</p>
<p>
 <br />  <function>the zzip_dir_open_ext_io function</function> uses explicit ext and io instead of the internal 
 <br />  defaults. Setting these to zero is equivalent to <a href="#zzip_dir_open"><code>zzip_dir_open</code></a>
 
</p>
<p><small><code>zzip_dir_read</code></small> -
 <br />  fills the dirent-argument with the values and 
 <br />  increments the read-pointer of the dir-argument.

</p><p>

   returns 0 if there no entry (anymore).
 
</p>
<p align="right"><small>(../../zzip/zip.c)</small></p></dd>
<dt><a name="zzip_dir_stat" /> <a name="zzip_file_stat" /> <a name="zzip_fstat" />
  <code>int 
</code>
  <br /><b><code>zzip_dir_stat</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR * dir</nobr>,
<nobr>zzip_char_t* name</nobr>,
<nobr>ZZIP_STAT * zs</nobr>,
<nobr>int flags</nobr>)</code>

</code>

<br />  <code>int </code>
  <br /><b><code>zzip_file_stat</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE* file</nobr>,
<nobr>ZZIP_STAT* zs</nobr>)</code>

</code>

<br />  <code>int </code>
  <br /><b><code>zzip_fstat</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE* file</nobr>,
<nobr>ZZIP_STAT* zs</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/stat.c)

</em></para><p>
 <br />  obtain information about a filename in an opened zip-archive without 
 <br />  opening that file first. Mostly used to obtain the uncompressed 
 <br />  size of a file inside a zip-archive. see <a href="#zzip_dir_open"><code>zzip_dir_open</code></a>.
 
</p>
<p>
 <br />  <function>The zzip_file_stat function</function> will obtain information about a opened file _within_ a 
 <br />  zip-archive. The file is supposed to be open (otherwise -1 is returned). 
 <br />  The st_size stat-member contains the uncompressed size. The optional 
 <br />  d_name is never set here. 
 
</p>
<p>
 <br />  <function>The zzip_fstat function</function> will obtain information about a opened file which may be
 <br />  either real/zipped. The file is supposed to be open (otherwise -1 is 
 <br />  returned). The st_size stat-member contains the uncompressed size. 
 <br />  The optional d_name is never set here. For a real file, we do set the
 <br />  d_csize := st_size and d_compr := 0 for meaningful defaults.
 
</p>
<p align="right"><small>(../../zzip/stat.c)</small></p></dd>
<dt><a name="zzip_dirhandle" /> <a name="zzip_dirfd" />
  <code>ZZIP_DIR * 
</code>
  <br /><b><code>zzip_dirhandle</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE * fp</nobr>)</code>
   
</code>

<br />  <code>int 
</code>
  <br /><b><code>zzip_dirfd</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>
   
</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/info.c)

</em></para><p>
 <br />  <function>The zzip_dirhandle function</function> will just return fp<small>-&gt;</small>dir 

</p><p>

   If a ZZIP_FILE is contained within a zip-file that one will be a valid
 <br />  pointer, otherwise a NULL is returned and the ZZIP_FILE wraps a real file.
 
</p>
<p>
 <br />   <function>The zzip_dirfd function</function> will just return dir<small>-&gt;</small>fd 

</p><p>

   If a ZZIP_DIR does point to a zipfile then the file-descriptor of that
 <br />  zipfile is returned, otherwise a NULL is returned and the ZZIP_DIR wraps 
 <br />  a real directory DIR (if you have dirent on your system).
 
</p>
<p align="right"><small>(../../zzip/info.c)</small></p></dd>
<dt><a name="zzip_disk_entry_to_data" /> <a name="zzip_disk_entry_to_file_header" /> <a name="zzip_disk_entry_strdup_name" /> <a name="zzip_disk_entry_strdup_comment" />
  <code>zzip_byte_t*
</code>
  <br /><b><code>zzip_disk_entry_to_data</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>struct zzip_disk_entry* entry</nobr>)</code>

</code>

<br />  <code>struct zzip_file_header*
</code>
  <br /><b><code>zzip_disk_entry_to_file_header</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>struct zzip_disk_entry* entry</nobr>)</code>

</code>

<br />  <code>zzip__new__ char*
</code>
  <br /><b><code>zzip_disk_entry_strdup_name</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>struct zzip_disk_entry* entry</nobr>)</code>

</code>

<br />  <code>zzip__new__ char*
</code>
  <br /><b><code>zzip_disk_entry_strdup_comment</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>struct zzip_disk_entry* entry</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; helper functions for (mmapped) zip access api


</em></para><p>

</p><p>

   <function>The zzip_disk_entry_to_data function</function> augments the other zzip_disk_entry_* helpers: here we move 
 <br />  a disk_entry pointer (as returned by _find* functions) into a pointer to
 <br />  the data block right after the file_header. Only disk<small>-&gt;</small>buffer would be
 <br />  needed to perform the seek but we check the mmapped range end as well.
 
</p>
<p>
 <br />  <function>The zzip_disk_entry_to_file_header function</function> does half the job of <a href="#zzip_disk_entry_to_data"><code>zzip_disk_entry_to_data</code></a> where it
 <br />  can augment with <code>zzip_file_header_to_data</code> helper from format/fetch.h
 
</p>
<p>
 <br />  <function>The zzip_disk_entry_strdup_name function</function> is a big helper despite its little name: in a zip file the
 <br />  encoded filenames are usually NOT zero-terminated but for common usage
 <br />  with libc we need it that way. Secondly, the filename SHOULD be present
 <br />  in the zip central directory but if not then we fallback to the filename
 <br />  given in the file_header of each compressed data portion.
 
</p>
<p>
 <br />  <function>The zzip_disk_entry_strdup_comment function</function> is similar creating a reference to a zero terminated
 <br />  string but it can only exist in the zip central directory entry.
 
</p>
<p align="right"><small>(../../zzip/mmapped.c)</small></p></dd>
<dt><a name="zzip_disk_findfile" /> <a name="zzip_disk_findfirst" /> <a name="zzip_disk_findnext" /> <a name="zzip_disk_findmatch" />
  <code>struct zzip_disk_entry*
</code>
  <br /><b><code>zzip_disk_findfile</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>char* filename</nobr>,
<nobr>struct zzip_disk_entry* after</nobr>,
<nobr>zzip_strcmp_fn_t compare</nobr>)</code>

</code>

<br />  <code>struct zzip_disk_entry*
</code>
  <br /><b><code>zzip_disk_findfirst</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>)</code>

</code>

<br />  <code>struct zzip_disk_entry*
</code>
  <br /><b><code>zzip_disk_findnext</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>struct zzip_disk_entry* entry</nobr>)</code>

</code>

<br />  <code>struct zzip_disk_entry*
</code>
  <br /><b><code>zzip_disk_findmatch</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>char* filespec</nobr>,
<nobr>struct zzip_disk_entry* after</nobr>,
<nobr>zzip_fnmatch_fn_t compare</nobr>,
<nobr>int flags</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; search for files in the (mmapped) zip central directory


</em></para><p>

</p><p>

   <function>The zzip_disk_findfile function</function> is given a filename as an additional argument, to find the 
 <br />  disk_entry matching a given filename. The compare-function is usually 
 <br />  strcmp or strcasecmp or perhaps strcoll, if null then strcmp is used. 
 <br />  - use null as argument for "after"-entry when searching the first 
 <br />  matching entry, otherwise the last returned value if you look for other
 <br />  entries with a special "compare" function (if null then a doubled search
 <br />  is rather useless with this variant of _findfile).
 
</p>
<p>

</p><p>

   <function>The zzip_disk_findfirst function</function> is the first call of all the zip access functions here.
 <br />  It contains the code to find the first entry of the zip central directory. 
 <br />  Here we require the mmapped block to represent a real zip file where the
 <br />  disk_trailer is _last_ in the file area, so that its position would be at 
 <br />  a fixed offset from the end of the file area if not for the comment field 
 <br />  allowed to be of variable length (which needs us to do a little search
 <br />  for the disk_tailer). However, in this simple implementation we disregard 
 <br />  any disk_trailer info telling about multidisk archives, so we just return
 <br />  a pointer to the zip central directory.

</p><p>

   For an actual means, we are going to search backwards from the end 
 <br />  of the mmaped block looking for the PK-magic signature of a 
 <br />  disk_trailer. If we see one then we check the rootseek value to
 <br />  find the first disk_entry of the root central directory. If we find
 <br />  the correct PK-magic signature of a disk_entry over there then we 
 <br />  assume we are done and we are going to return a pointer to that label.

</p><p>

   The return value is a pointer to the first zzip_disk_entry being checked
 <br />  to be within the bounds of the file area specified by the arguments. If
 <br />  no disk_trailer was found then null is returned, and likewise we only 
 <br />  accept a disk_trailer with a seekvalue that points to a disk_entry and 
 <br />  both parts have valid PK-magic parts. Beyond some sanity check we try to
 <br />  catch a common brokeness with zip archives that still allows us to find
 <br />  the start of the zip central directory.
 
</p>
<p>

</p><p>

   <function>The zzip_disk_findnext function</function> takes an existing disk_entry in the central root directory
 <br />  (e.g. from zzip_disk_findfirst) and returns the next entry within in
 <br />  the given bounds of the mmapped file area.
 
</p>
<p>

</p><p>

   <function>The zzip_disk_findmatch function</function> uses a compare-function with an additional argument
 <br />  and it is called just like fnmatch(3) from POSIX.2 AD:1993), i.e.
 <br />  the argument filespec first and the ziplocal filename second with
 <br />  the integer-flags put in as third to the indirect call. If the
 <br />  platform has fnmatch available then null-compare will use that one
 <br />  and otherwise we fall back to mere strcmp, so if you need fnmatch
 <br />  searching then please provide an implementation somewhere else.
 <br />  - use null as argument for "after"-entry when searching the first 
 <br />  matching entry, or the last disk_entry return-value to find the
 <br />  next entry matching the given filespec.
 
</p>
<p align="right"><small>(../../zzip/mmapped.c)</small></p></dd>
<dt><a name="zzip_disk_fopen" /> <a name="zzip_disk_entry_fopen" /> <a name="zzip_disk_fread" /> <a name="zzip_disk_fclose" /> <a name="zzip_disk_feof" />
  <code>zzip__new__ ZZIP_DISK_FILE*
</code>
  <br /><b><code>zzip_disk_fopen</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>char* filename</nobr>)</code>

</code>

<br />  <code>zzip__new__ ZZIP_DISK_FILE*
</code>
  <br /><b><code>zzip_disk_entry_fopen</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>ZZIP_DISK_ENTRY* entry</nobr>)</code>

</code>

<br />  <code>zzip_size_t
</code>
  <br /><b><code>zzip_disk_fread</code></b>
   &nbsp; <code>
 <code>(<nobr>void* ptr</nobr>,
<nobr>zzip_size_t sized</nobr>,
<nobr>zzip_size_t nmemb</nobr>,
<nobr>ZZIP_DISK_FILE* file</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_disk_fclose</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK_FILE* file</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_disk_feof</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK_FILE* file</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; openening a file part wrapped within a (mmapped) zip archive


</em></para><p>

</p><p>

   <function>The zzip_disk_fopen function</function> opens a file found by name, so it does a search into
 <br />  the zip central directory with <a href="#zzip_disk_findfile"><code>zzip_disk_findfile</code></a> and whatever
 <br />  is found first is given to <a href="#zzip_disk_entry_fopen"><code>zzip_disk_entry_fopen</code></a>
 
</p>
<p>

</p><p>

   the ZZIP_DISK_FILE* is rather simple in just encapsulating the
 <br />  arguments given to <function>the zzip_disk_entry_fopen function</function> plus a zlib deflate buffer.
 <br />  Note that the ZZIP_DISK pointer does already contain the full
 <br />  mmapped file area of a zip disk, so open()ing a file part within
 <br />  that area happens to be a lookup of its bounds and encoding. That
 <br />  information is memorized on the ZZIP_DISK_FILE so that subsequent
 <br />  _read() operations will be able to get the next data portion or
 <br />  return an eof condition for that file part wrapped in the zip archive.
 
</p>
<p>

</p><p>

   <function>The zzip_disk_fread function</function> reads more bytes into the output buffer specified as
 <br />  arguments. The return value is null on eof or error, the stdio-like
 <br />  interface can not distinguish between these so you need to check
 <br />  with <a href="#zzip_disk_feof"><code>zzip_disk_feof</code></a> for the difference.
 
</p>
<p>
 <br />  <function>The zzip_disk_fclose function</function> releases any zlib decoder info needed for decompression
 <br />  and dumps the ZZIP_DISK_FILE* then.
 
</p>
<p>

</p><p>

   <function>The zzip_disk_feof function</function> allows to distinguish an error from an eof condition. 
 <br />  Actually, if we found an error but we did already reach eof then we
 <br />  just keep on saying that it was an eof, so the app can just continue.
 
</p>
<p align="right"><small>(../../zzip/mmapped.c)</small></p></dd>
<dt><a name="zzip_disk_mmap" /> <a name="zzip_disk_init" /> <a name="zzip_disk_new" /> <a name="zzip_disk_munmap" /> <a name="zzip_disk_open" /> <a name="zzip_disk_close" />
  <code>zzip__new__ ZZIP_DISK*
</code>
  <br /><b><code>zzip_disk_mmap</code></b>
   &nbsp; <code>
 <code>(<nobr>int fd</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_disk_init</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>void* buffer</nobr>,
<nobr>zzip_size_t buflen</nobr>)</code>

</code>

<br />  <code>zzip__new__ ZZIP_DISK*
</code>
  <br /><b><code>zzip_disk_new</code></b>
   &nbsp; <code>
 <code>(<nobr>void</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_disk_munmap</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>)</code>

</code>

<br />  <code>ZZIP_DISK* zzip__new__
</code>
  <br /><b><code>zzip_disk_open</code></b>
   &nbsp; <code>
 <code>(<nobr>char* filename</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_disk_close</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; turn a filehandle into a mmapped zip disk archive handle


</em></para><p>

</p><p>

   <function>The zzip_disk_mmap function</function> uses the given file-descriptor to detect the length of the 
 <br />  file and calls the system <code>mmap</code>(2) to put it in main memory. If it is
 <br />  successful then a newly allocated ZZIP_DISK* is returned with 
 <br />  disk<small>-&gt;</small>buffer pointing to the mapview of the zipdisk content.
 
</p>
<p>
 <br />  <function>The zzip_disk_init function</function> does primary initialization of a disk-buffer struct.
 
</p>
<p>
 <br />  <function>The zzip_disk_new function</function> allocates a new disk-buffer with <code>malloc</code>(3)
 
</p>
<p>
 <br />  <function>The zzip_disk_munmap function</function> is the inverse of <a href="#zzip_disk_mmap"><code>zzip_disk_mmap</code></a> and using the system
 <br />  munmap(2) on the buffer area and <code>free</code>(3) on the ZZIP_DISK structure.
 
</p>
<p>

</p><p>

   <function>The zzip_disk_open function</function> opens the given archive by name and turn the filehandle 
 <br />  to  <a href="#zzip_disk_mmap"><code>zzip_disk_mmap</code></a> for bringing it to main memory. If it can not
 <br />  be <code>mmap</code>(2)'ed then we slurp the whole file into a newly <code>malloc</code>(2)'ed
 <br />  memory block. Only if that fails too then we return null. Since handling
 <br />  of disk<small>-&gt;</small>buffer is ambigous it should not be snatched away please.
 
</p>
<p>

</p><p>

   <function>The zzip_disk_close function</function> will release all data needed to access a (mmapped)
 <br />  zip archive, including any malloc()ed blocks, sharedmem mappings
 <br />  and it dumps the handle struct as well.
 
</p>
<p align="right"><small>(../../zzip/mmapped.c)</small></p></dd>
<dt><a name="zzip_entry_data_offset" /> <a name="zzip_entry_fread_file_header" /> <a name="zzip_entry_strdup_name" />
  <code>zzip_off_t
</code>
  <br /><b><code>zzip_entry_data_offset</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_ENTRY* entry</nobr>)</code>

</code>

<br />  <code>static zzip_off_t
</code>
  <br /><b><code>zzip_entry_fread_file_header</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_ENTRY* entry</nobr>,
<nobr>struct zzip_file_header* file_header</nobr>)</code>

</code>

<br />  <code>zzip__new__ char*
</code>
  <br /><b><code>zzip_entry_strdup_name</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_ENTRY* entry</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; helper functions for (fseeko) zip access api


</em></para><p>

</p><p>

   <function>The zzip_entry_data_offset function</function>s returns the seekval offset of the data portion of the
 <br />  file referenced by the given zzip_entry. It requires an intermediate
 <br />  check of the file_header structure (i.e. it reads it from disk). After 
 <br />  this call, the contained diskfile readposition is already set to the 
 <br />  data_offset returned here. On error -1 is returned.
 
</p>
<p>
 <br />  <function>The zzip_entry_fread_file_header function</function>s read the correspoding struct zzip_file_header from 
 <br />  the zip disk of the given "entry". The returned off_t points to the
 <br />  end of the file_header where the current fseek pointer has stopped.
 <br />  This is used to immediatly parse out any filename/extras block following
 <br />  the file_header. The return value is null on error.
 
</p>
<p>
 <br />  <function>The zzip_entry_strdup_name function</function> is a big helper despite its little name: in a zip file the
 <br />  encoded filenames are usually NOT zero-terminated but for common usage
 <br />  with libc we need it that way. Secondly, the filename SHOULD be present
 <br />  in the zip central directory but if not then we fallback to the filename
 <br />  given in the file_header of each compressed data portion.
 
</p>
<p align="right"><small>(../../zzip/fseeko.c)</small></p></dd>
<dt><a name="zzip_entry_findfile" /> <a name="zzip_entry_findfirst" /> <a name="zzip_entry_findnext" /> <a name="zzip_entry_free" /> <a name="zzip_entry_findmatch" />
  <code>zzip__new__ ZZIP_ENTRY*
</code>
  <br /><b><code>zzip_entry_findfile</code></b>
   &nbsp; <code>
 <code>(<nobr>FILE* disk</nobr>,
<nobr>char* filename</nobr>,
<nobr>ZZIP_ENTRY* _zzip_restrict entry</nobr>,
<nobr>zzip_strcmp_fn_t compare</nobr>)</code>

</code>

<br />  <code>zzip__new__ ZZIP_ENTRY*
</code>
  <br /><b><code>zzip_entry_findfirst</code></b>
   &nbsp; <code>
 <code>(<nobr>FILE* disk</nobr>)</code>

</code>

<br />  <code>zzip__new__ ZZIP_ENTRY*
</code>
  <br /><b><code>zzip_entry_findnext</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_ENTRY* _zzip_restrict entry</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_entry_free</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_ENTRY* entry</nobr>)</code>

</code>

<br />  <code>zzip__new__ ZZIP_ENTRY*
</code>
  <br /><b><code>zzip_entry_findmatch</code></b>
   &nbsp; <code>
 <code>(<nobr>FILE* disk</nobr>,
<nobr>char* filespec</nobr>,
<nobr>ZZIP_ENTRY* _zzip_restrict entry</nobr>,
<nobr>zzip_fnmatch_fn_t compare</nobr>,
<nobr>int flags</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; search for files in the (fseeko) zip central directory


</em></para><p>

</p><p>

   <function>The zzip_entry_findfile function</function> is given a filename as an additional argument, to find the 
 <br />  disk_entry matching a given filename. The compare-function is usually 
 <br />  strcmp or strcasecmp or perhaps strcoll, if null then strcmp is used. 
 <br />  - use null as argument for "old"-entry when searching the first 
 <br />  matching entry, otherwise the last returned value if you look for other
 <br />  entries with a special "compare" function (if null then a doubled search
 <br />  is rather useless with this variant of _findfile). If no further entry is
 <br />  found then null is returned and any "old"-entry gets already free()d.
 
</p>
<p>

</p><p>

   <function>The zzip_entry_findfirst function</function> is the first call of all the zip access functions here.
 <br />  It contains the code to find the first entry of the zip central directory. 
 <br />  Here we require the stdio handle to represent a real zip file where the
 <br />  disk_trailer is _last_ in the file area, so that its position would be at 
 <br />  a fixed offset from the end of the file area if not for the comment field 
 <br />  allowed to be of variable length (which needs us to do a little search
 <br />  for the disk_tailer). However, in this simple implementation we disregard
 <br />  any disk_trailer info telling about multidisk archives, so we just return
 <br />  a pointer to the first entry in the zip central directory of that file.

</p><p>

   For an actual means, we are going to search backwards from the end 
 <br />  of the mmaped block looking for the PK-magic signature of a 
 <br />  disk_trailer. If we see one then we check the rootseek value to
 <br />  find the first disk_entry of the root central directory. If we find
 <br />  the correct PK-magic signature of a disk_entry over there then we 
 <br />  assume we are done and we are going to return a pointer to that label.

</p><p>

   The return value is a pointer to the first zzip_disk_entry being checked
 <br />  to be within the bounds of the file area specified by the arguments. If
 <br />  no disk_trailer was found then null is returned, and likewise we only 
 <br />  accept a disk_trailer with a seekvalue that points to a disk_entry and 
 <br />  both parts have valid PK-magic parts. Beyond some sanity check we try to
 <br />  catch a common brokeness with zip archives that still allows us to find
 <br />  the start of the zip central directory.
 
</p>
<p>

</p><p>

   <function>The zzip_entry_findnext function</function> takes an existing "entry" in the central root directory
 <br />  (e.g. from zzip_entry_findfirst) and moves it to point to the next entry.
 <br />  On error it returns 0, otherwise the old entry. If no further match is
 <br />  found then null is returned and the entry already free()d. If you want
 <br />  to stop searching for matches before that case then please call 
 <br />  <a href="#zzip_entry_free"><code>zzip_entry_free</code></a> on the cursor struct ZZIP_ENTRY.
 
</p>
<p>
 <br />  <function>the zzip_entry_free function</function> releases the malloc()ed areas needed for zzip_entry, the
 <br />  pointer is invalid afterwards. <function>The zzip_entry_free function</function> has #define synonyms of
 <br />  zzip_entry_findlast(), zzip_entry_findlastfile(), zzip_entry_findlastmatch()
 
</p>
<p>

</p><p>

   <function>The zzip_entry_findmatch function</function> uses a compare-function with an additional argument
 <br />  and it is called just like fnmatch(3) from POSIX.2 AD:1993), i.e.
 <br />  the argument filespec first and the ziplocal filename second with
 <br />  the integer-flags put in as third to the indirect call. If the
 <br />  platform has fnmatch available then null-compare will use that one
 <br />  and otherwise we fall back to mere strcmp, so if you need fnmatch
 <br />  searching then please provide an implementation somewhere else.
 <br />  - use null as argument for "after"-entry when searching the first 
 <br />  matching entry, or the last disk_entry return-value to find the
 <br />  next entry matching the given filespec. If no further entry is
 <br />  found then null is returned and any "old"-entry gets already free()d.
 
</p>
<p align="right"><small>(../../zzip/fseeko.c)</small></p></dd>
<dt><a name="zzip_entry_fopen" /> <a name="zzip_entry_ffile" /> <a name="zzip_entry_fread" /> <a name="zzip_entry_fclose" /> <a name="zzip_entry_feof" />
  <code>zzip__new__ ZZIP_ENTRY_FILE*
</code>
  <br /><b><code>zzip_entry_fopen</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_ENTRY* entry</nobr>,
<nobr>int takeover</nobr>)</code>

</code>

<br />  <code>zzip__new__ ZZIP_ENTRY_FILE*
</code>
  <br /><b><code>zzip_entry_ffile</code></b>
   &nbsp; <code>
 <code>(<nobr>FILE* disk</nobr>,
<nobr>char* filename</nobr>)</code>

</code>

<br />  <code>zzip_size_t
</code>
  <br /><b><code>zzip_entry_fread</code></b>
   &nbsp; <code>
 <code>(<nobr>void* ptr</nobr>,
<nobr>zzip_size_t sized</nobr>,
<nobr>zzip_size_t nmemb</nobr>,
<nobr>ZZIP_ENTRY_FILE* file</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_entry_fclose</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_ENTRY_FILE* file</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_entry_feof</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_ENTRY_FILE* file</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; open a file within a zip disk for reading


</em></para><p>

</p><p>

   <function>The zzip_entry_fopen function</function> does take an "entry" argument and copies it (or just takes
 <br />  it over as owner) to a new ZZIP_ENTRY_FILE handle structure. That
 <br />  structure contains also a zlib buffer for decoding. <function>The zzip_entry_fopen function</function> does
 <br />  seek to the file_header of the given "entry" and validates it for the
 <br />  data buffer following it. We do also prefetch some data from the data
 <br />  buffer thereby trying to match the disk pagesize for faster access later.
 <br />  The <a href="#zzip_entry_fread"><code>zzip_entry_fread</code></a> will then read in chunks of pagesizes which is
 <br />  the size of the internal readahead buffer. If an error occurs then null
 <br />  is returned.
 
</p>
<p>

</p><p>

   <function>The zzip_entry_ffile function</function> opens a file found by name, so it does a search into
 <br />  the zip central directory with <a href="#zzip_entry_findfile"><code>zzip_entry_findfile</code></a> and whatever
 <br />  is found first is given to <a href="#zzip_entry_fopen"><code>zzip_entry_fopen</code></a>
 
</p>
<p>

</p><p>

   <function>The zzip_entry_fread function</function> reads more bytes into the output buffer specified as
 <br />  arguments. The return value is null on eof or error, the stdio-like
 <br />  interface can not distinguish between these so you need to check
 <br />  with <a href="#zzip_entry_feof"><code>zzip_entry_feof</code></a> for the difference.
 
</p>
<p>
 <br />  <function>The zzip_entry_fclose function</function> releases any zlib decoder info needed for decompression
 <br />  and dumps the ZZIP_ENTRY_FILE struct then.
 
</p>
<p>

</p><p>

   <function>The zzip_entry_feof function</function> allows to distinguish an error from an eof condition. 
 <br />  Actually, if we found an error but we did already reach eof then we
 <br />  just keep on saying that it was an eof, so the app can just continue.
 
</p>
<p align="right"><small>(../../zzip/fseeko.c)</small></p></dd>
<dt><a name="zzip_errno" />
  <code>int
</code>
  <br /><b><code>zzip_errno</code></b>
   &nbsp; <code>
 <code>(<nobr>int errcode</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/err.c)

</em></para><p>
 <br />  map the error code to a system error code. This is used
 <br />  for the drop-in replacement functions to return a value
 <br />  that can be interpreted correctly by code sections that
 <br />  are unaware of the fact they their <code>open</code>(2) call had been
 <br />  diverted to a file inside a zip-archive.
 
</p>
<p align="right"><small>(../../zzip/err.c)</small></p></dd>
<dt><a name="zzip_error" /> <a name="zzip_seterror" />
  <code>int 
</code>
  <br /><b><code>zzip_error</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR * dir</nobr>)</code>
   
</code>

<br />  <code>void 
</code>
  <br /><b><code>zzip_seterror</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR * dir</nobr>,
<nobr>int errcode</nobr>)</code>
   
</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/info.c)

</em></para><p>
 <br />   just returns dir<small>-&gt;</small>errcode of the ZZIP_DIR handle 
 <br />   see: <a href="#zzip_dir_open"><code>zzip_dir_open</code></a>, <code>zzip_diropen</code>, <a href="#zzip_readdir"><code>zzip_readdir</code></a>, <a href="#zzip_dir_read"><code>zzip_dir_read</code></a>
 
</p>
<p>
 <br />   <function>The zzip_seterror function</function> just does dir<small>-&gt;</small>errcode = errcode 
 
</p>
<p align="right"><small>(../../zzip/info.c)</small></p></dd>
<dt><a name="zzip_fclose" /> <a name="zzip_close" />
  <code>int 
</code>
  <br /><b><code>zzip_fclose</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE * fp</nobr>)</code>

</code>

<br />  <code>int 
</code>
  <br /><b><code>zzip_close</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE* fp</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />  <function>The zzip_fclose function</function> closes the given ZZIP_FILE handle. 

</p><p>

   If the ZZIP_FILE wraps a normal stat'fd then it is just that int'fd 
 <br />  that is being closed and the otherwise empty ZZIP_FILE gets freed.
 
</p>
<p><small><code>zzip_close</code></small> -
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_file_close" />
  <code>int 
</code>
  <br /><b><code>zzip_file_close</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE * fp</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />  the direct function of <a href="#zzip_close"><code>zzip_close</code></a>(fp). it will cleanup the
 <br />  inflate-portion of <code>zlib</code> and free the structure given.

</p><p>

   it is called quite from the error-cleanup parts
 <br />  of the various <code>_open</code> functions. 

</p><p>

   the .refcount is decreased and if zero the fp<small>-&gt;</small>dir is closed just as well.
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_file_creat" /> <a name="zzip_file_mkdir" />
  <code>ZZIP_FILE*
</code>
  <br /><b><code>zzip_file_creat</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR* dir</nobr>,
<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_file_mkdir</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR* dir</nobr>,
<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; start next file entry in a zip archive


</em></para><p>

</p><p>

   <function>The zzip_file_creat function</function> will create a new file within a zzip archive, the
 <br />  one given as the primary argument and additionally to the posix
 <br />  creat(2) - just like zzip_mkdir has an additional argument over
 <br />  the posix mkdir(2) spec. For <function>the zzip_file_creat function</function> the primary parameter
 <br />  can be null as well thereby creating a real file instead of a new
 <br />  one inside the zip-archive otherwise given. If the primary parameter is
 <br />  not null but wraps a real directory then all new files are also real.

</p><p>

   <function>The zzip_file_creat function</function> is not yet implemented, check for #def ZZIP_NO_CREAT

</p><p>

   Returns NULL on an error setting errno, and opening a file _within_ 
 <br />  a zip archive using O_RDONLY (and similar stuff) will surely lead to 
 <br />  an error.
 
</p>
<p>

</p><p>

   <function>The zzip_file_mkdir function</function> has an additional primary argument over the posix
 <br />  mkdir(2) - if it is null then <function>the zzip_file_mkdir function</function> behaves just like
 <br />  posix mkdir(2). The zzip_dir argument can be set to the result
 <br />  of a <a href="#zzip_createdir"><code>zzip_createdir</code></a> which allows for some magic that the
 <br />  given directory name is created as an entry in the zip archive.

</p><p>

   If the given dir name argument is not within the basepath of 
 <br />  the zip central directory then a real directory is created.
 <br />  Any EEXIST errors are not suppressed unlike with <a href="#zzip_createdir"><code>zzip_createdir</code></a>

</p><p>

   Standard usage accepts a global/threaded/modular ZZIP_DIR pointer
 <br />  for all zip archive operations like in:
 <pre>  ZZIP_DIR* zip = zzip_createdir (sysconfpath, 0755, zip);  
   zzip_file_mkdir (zip, filepath[i], 0755);  
   ZZIP_FILE* file = zzip_file_creat (zip, filename[i], 0644);  
   zzip_write (file, buf, len);  
   zzip_close (file); file = 0;  
   zzip_closedir (zip); zip = 0; </pre> 

</p><p>

   compare with <a href="#zzip_mkdir"><code>zzip_mkdir</code></a> inline macro which allows to
 <br />  collapse the examples script to
 <pre>  #define zzip_savefile myproject_saveconfig  
   #include &lt;zzip/zzip.h&gt;  
   ZZIP_DIR* zzip_savefile = zzip_createdir (sysconfpath, 0755);  
   zzip_mkdir (filepath[i], 0755);  
   ZZIP_FILE* file = zzip_creat(filepath[i], 0644);  
   zzip_write (file, buf, len);  
   zzip_close (file); file = 0;  
   zzip_closedir (zip_savefile); </pre> 
 
</p>
<p align="right"><small>(../../zzip/write.c)</small></p></dd>
<dt><a name="zzip_file_open" />
  <code>ZZIP_FILE * 
</code>
  <br /><b><code>zzip_file_open</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR * dir</nobr>,
<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />  open an <code>ZZIP_FILE</code> from an already open <code>ZZIP_DIR</code> handle. Since
 <br />  we have a chance to reuse a cached <code>buf32k</code> and <code>ZZIP_FILE</code> memchunk
 <br />  this is the best choice to unpack multiple files.

</p><p>

   Note: the zlib supports 2..15 bit windowsize, hence we provide a 32k
 <br />        memchunk here... just to be safe.
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_file_read" />
  <code>zzip_ssize_t 
</code>
  <br /><b><code>zzip_file_read</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE * fp</nobr>,
<nobr>char * buf</nobr>,
<nobr>zzip_size_t len</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />  <function>The zzip_file_read function</function>s read data from zip-contained file.

</p><p>

   It works like <code>read</code>(2) and will fill the given buffer with bytes from
 <br />  the opened file. It will return the number of bytes read, so if the <code>EOF</code>
 <br />  is encountered you will be prompted with the number of bytes actually read.

</p><p>

   This is the routines that needs the <code>buf32k</code> buffer, and it would have
 <br />  need for much more polishing but it does already work quite well.

</p><p>

   Note: the 32K buffer is rather big. The original inflate-algorithm
 <br />        required just that but the latest zlib would work just fine with
 <br />        a smaller buffer.
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_file_real" /> <a name="zzip_dir_real" /> <a name="zzip_realdir" /> <a name="zzip_realfd" />
  <code>int
</code>
  <br /><b><code>zzip_file_real</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE* fp</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_dir_real</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>

</code>

<br />  <code>void*
</code>
  <br /><b><code>zzip_realdir</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>

</code>

<br />  <code>int
</code>
  <br /><b><code>zzip_realfd</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE* fp</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/info.c)

</em></para><p>
 <br />  <function>The zzip_file_real function</function> checks if the ZZIP_FILE-handle is wrapping 
 <br />  a real file or a zip-contained file. 
 <br />  Returns 1 for a stat'able file, and 0 for a file inside a zip-archive.
 
</p>
<p>
 <br />  <function>The zzip_dir_real function</function> checks if the ZZIP_DIR-handle is wrapping 
 <br />  a real directory or a zip-archive. 
 <br />  Returns 1 for a stat'able directory, and 0 for a handle to zip-archive.
 
</p>
<p>
 <br />  <function>The zzip_realdir function</function> returns the posix DIR* handle (if one exists).
 <br />  Check before with <a href="#zzip_dir_real"><code>zzip_dir_real</code></a> if the
 <br />  the ZZIP_DIR points to a real directory.
 
</p>
<p>
 <br />  <function>The zzip_realfd function</function> returns the posix file descriptor (if one exists).
 <br />  Check before with <a href="#zzip_file_real"><code>zzip_file_real</code></a> if the
 <br />  the ZZIP_FILE points to a real file.
 
</p>
<p align="right"><small>(../../zzip/info.c)</small></p></dd>
<dt><a name="zzip_fopen" /> <a name="zzip_freopen" />
  <code>ZZIP_FILE*
</code>
  <br /><b><code>zzip_fopen</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>zzip_char_t* mode</nobr>)</code>

</code>

<br />  <code>ZZIP_FILE*
</code>
  <br /><b><code>zzip_freopen</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>zzip_char_t* mode</nobr>,
<nobr>ZZIP_FILE* stream</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />  <function>The zzip_fopen function</function> will <code>fopen</code>(3) a real/zipped file.

</p><p>

   It has some magic functionality builtin - it will first try to open
 <br />  the given <em>filename</em> as a normal file. If it does not
 <br />  exist, the given path to the filename (if any) is split into
 <br />  its directory-part and the file-part. A ".zip" extension is
 <br />  then added to the directory-part to create the name of a
 <br />  zip-archive. That zip-archive (if it exists) is being searched
 <br />  for the file-part, and if found a zzip-handle is returned. 

</p><p>

   Note that if the file is found in the normal fs-directory the
 <br />  returned structure is mostly empty and the <a href="#zzip_read"><code>zzip_read</code></a> call will
 <br />  use the libc <code>read</code> to obtain data. Otherwise a <a href="#zzip_file_open"><code>zzip_file_open</code></a> 
 <br />  is performed and any error mapped to <code>errno</code>(3).

</p><p>

   unlike the posix-wrapper <a href="#zzip_open"><code>zzip_open</code></a> the mode-argument is
 <br />  a string which allows for more freedom to support the extra
 <br />  zzip modes called ZZIP_CASEINSENSITIVE and ZZIP_IGNOREPATH.
 <br />  Currently, this <a href="#zzip_fopen"><code>zzip_fopen</code></a> call will convert the following
 <br />  characters in the mode-string into their corrsponding mode-bits: 
 <br />   <ul><li><code> "r" : O_RDONLY : </code> read-only
 <br />  </li><li><code> "b" : O_BINARY : </code> binary (win32 specific)
 <br />  </li><li><code> "f" : O_NOCTTY : </code> no char device (unix)
 <br />  </li><li><code> "i" : ZZIP_CASELESS : </code> inside zip file
 <br />  </li><li><code> "*" : ZZIP_NOPATHS : </code> inside zip file only
 <br />  </ul> all other modes will be ignored for zip-contained entries
 <br />  but they are transferred for compatibility and portability,
 <br />  including these extra sugar bits:
 <br />   <ul><li><code> "x" : O_EXCL :</code> fail if file did exist
 <br />  </li><li><code> "s" : O_SYNC :</code> synchronized access
 <br />  </li><li><code> "n" : O_NONBLOCK :</code> nonblocking access
 <br />  </li><li><code> "z#" : compression level :</code> for zlib
 <br />  </li><li><code> "g#" : group access :</code> unix access bits
 <br />  </li><li><code> "u#" : owner access :</code> unix access bits
 <br />  </li><li><code> "o#" : world access :</code> unix access bits
 <br />  </ul>... the access bits are in traditional unix bit format
 <br />  with 7 = read/write/execute, 6 = read/write, 4 = read-only.

</p><p>

   The default access mode is 0664, and the compression level
 <br />  is ignored since the lib can not yet write zip files, otherwise
 <br />  it would be the initialisation value for the zlib deflateInit
 <br />  where 0 = no-compression, 1 = best-speed, 9 = best-compression.
 
</p>
<p>

</p><p>

   <function>The zzip_freopen function</function> receives an additional argument pointing to
 <br />  a ZZIP_FILE* being already in use. If this extra argument is
 <br />  null then <function>the zzip_freopen function</function> is identical with calling <a href="#zzip_fopen"><code>zzip_fopen</code></a>

</p><p>

   Per default, the old file stream is closed and only the internal
 <br />  structures associated with it are kept. These internal structures
 <br />  may be reused for the return value, and this is a lot quicker when
 <br />  the filename matches a zipped file that is incidently in the very
 <br />  same zip arch as the old filename wrapped in the stream struct.

</p><p>

   That's simply because the zip arch's central directory does not 
 <br />  need to be read again. As an extension for <function>the zzip_freopen function</function>, if the 
 <br />  mode-string contains a "q" then the old stream is not closed but
 <br />  left untouched, instead it is only given as a hint that a new
 <br />  file handle may share/copy the zip arch structures of the old file
 <br />  handle if that is possible, i.e when they are in the same zip arch.
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_inflate_init" />
  <code>static int 
</code>
  <br /><b><code>zzip_inflate_init</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE * fp</nobr>,
<nobr>struct zzip_dir_hdr* hdr</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />   call <code>inflateInit</code> and setup fp's iterator variables, 
 <br />   used by lowlevel <code>_open</code> functions.
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_init_io" /> <a name="zzip_get_default_io" />
  <code>int </code>
  <br /><b><code>zzip_init_io</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_plugin_io_handlers_t io</nobr>,
<nobr>int flags</nobr>)</code>

</code>

<br />  <code>zzip_plugin_io_t
</code>
  <br /><b><code>zzip_get_default_io</code></b>
   &nbsp; <code>
 <code>(<nobr></nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/plugin.c)

</em></para><p>
 <br />  <function>The zzip_init_io function</function> initializes the users handler struct to default values 
 <br />  being the posix io functions in default configured environments.
 
</p>
<p>
 <br />  <function>The zzip_get_default_io function</function> returns a zzip_plugin_io_t handle to static defaults
 <br />  wrapping the posix io file functions for actual file access.
 
</p>
<p align="right"><small>(../../zzip/plugin.c)</small></p></dd>
<dt><a name="zzip_mem_disk_fdopen" />
  <code>zzip__new__ ZZIP_MEM_DISK*
</code>
  <br /><b><code>zzip_mem_disk_fdopen</code></b>
   &nbsp; <code>
 <code>(<nobr>int fd</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; create new diskdir handle. 


</em></para><p>
 <br />   wraps underlying zzip_disk_open. 
</p>
<p align="right"><small>(../../zzip/memdisk.c)</small></p></dd>
<dt><a name="zzip_mem_disk_load" />
  <code>long
</code>
  <br /><b><code>zzip_mem_disk_load</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_MEM_DISK* dir</nobr>,
<nobr>ZZIP_DISK* disk</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; parse central dir.


</em></para><p>
 <br />   creates an internal copy of each entry converted to the local platform.
 <br />   returns: number of entries, or -1 on error (setting errno)
 
</p>
<p align="right"><small>(../../zzip/memdisk.c)</small></p></dd>
<dt><a name="zzip_mem_disk_open" />
  <code>zzip__new__ ZZIP_MEM_DISK*
</code>
  <br /><b><code>zzip_mem_disk_open</code></b>
   &nbsp; <code>
 <code>(<nobr>char* filename</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; create new diskdir handle. 


</em></para><p>
 <br />   wraps underlying zzip_disk_open. 
</p>
<p align="right"><small>(../../zzip/memdisk.c)</small></p></dd>
<dt><a name="zzip_mem_entry_new" />
  <code>zzip__new__ ZZIP_MEM_ENTRY*
</code>
  <br /><b><code>zzip_mem_entry_new</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DISK* disk</nobr>,
<nobr>ZZIP_DISK_ENTRY* entry</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; convert a zip disk entry to internal format.


</em></para><p>
 <br />  creates a new item parsing the information out of the various places
 <br />  in the zip archive. This is a good place to extend functionality if
 <br />  you have a project with extra requirements as you can push more bits
 <br />  right into the diskdir_entry for later usage in higher layers.
 <br />  returns: new item, or null on error (setting errno)
 
</p>
<p align="right"><small>(../../zzip/memdisk.c)</small></p></dd>
<dt><a name="zzip_mkdir" /> <a name="zzip_creat" />
  <code>int inline
</code>
  <br /><b><code>zzip_mkdir</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</code>

<br />  <code>ZZIP_FILE* inline
</code>
  <br /><b><code>zzip_creat</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp; create a zipped file/directory            


</em></para><p>

</p><p>

   <function>The zzip_mkdir function</function> creates a directory entry in the default zip-archive. 
 <br />  If you did  not specify a "#define zzip_savefile somevar" 
 <br />  then the default zip-archive is null and all directories are 
 <br />  created as real directories in the filesystem. <function>The zzip_mkdir function</function> is 
 <br />  really a preprocessor macro or preferably an inline function
 <br />   around <a href="#zzip_file_mkdir"><code>zzip_file_mkdir</code></a>, there is no such symbol generated 
 <br />  into the library. The prototype is modelled after the posix 
 <br />  <code>mkdir</code>(2) call.
 <pre>  #ifndef zzip_savefile  
   #define zzip_savefile 0  
   #endif  
   #define zzip_mkdir(name,mode) \ - </pre> 
         zzip_file_mkdir(zzip_savefile,name,mode)

</p><p>

</p>
<p>

</p><p>

   <function>The zzip_creat function</function> creates a file in the default zip-archive. 
 <br />  If you did not specify a "#define zzip_savefile somevar" 
 <br />  then the default zip-archive is null and all files are created 
 <br />  as real files. <function>The zzip_creat function</function> is really a preprocessor macro 
 <br />  or preferably an inline function around <a href="#zzip_file_creat"><code>zzip_file_creat</code></a>, 
 <br />  there is no such symbol generated into the library. The prototype
 <br />  is modelled after the posix <code>creat</code>(2) call.
 <pre>  #ifndef zzip_savefile  
   #define zzip_savefile 0  
   #endif  
   #define zzip_creat(name,mode) \ - </pre> 
         zzip_file_creat(zzip_savefile,name,mode)
 
</p>
<p align="right"><small>(../../zzip/write.c)</small></p></dd>
<dt><a name="zzip_mkfifo" /> <a name="zzip_sync" />
  <code>void inline
</code>
  <br /><b><code>zzip_mkfifo</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* name</nobr>,
<nobr>int o_mode</nobr>)</code>

</code>

<br />  <code>void inline
</code>
  <br /><b><code>zzip_sync</code></b>
   &nbsp; <code>
 <code>(<nobr>void</nobr>)</code>
 
</code>
<dt>
<dd>
<para><em> &nbsp; start writing to the magic zzip_savefile   


</em></para><p>

</p><p>

   open a zip archive for writing via the magic zzip_savefile macro
 <br />  variable. The name and mode are given to <a href="#zzip_createdir"><code>zzip_createdir</code></a> and
 <br />  the result is stored into <code>zzip_savefile</code> - if the <code>zzip_savefile</code>
 <br />  did already have a zzip_dir handle then it is automatically 
 <br />  finalized with <a href="#zzip_sync"><code>zzip_sync</code></a> and the handle closed and the
 <br />  zzip_savefile variable reused for the new zip archive just started
 <br />  with this call. - <function>The zzip_mkfifo function</function> is really a preprocessor macro 
 <br />  or preferably an inline function around <code>zzip_dir_create</code>, there 
 <br />  is no such symbol generated into the library.
 <pre>  #ifndef zzip_savefile  
   #define zzip_savefile 0  
   #endif  
   #define zzip_start(name,mode,ext) \ - </pre> 
       { if (zzip_savefile) zzip_closedir(zzip_savefile); \ -
          zzip_savefile = zzip_createdir(name,mode,ext); }
 <br />  <function>The zzip_mkfifo function</function> returns null on error or a zzip_dir handle on
 <br />  success. It is perfectly okay to continue with a null in the
 <br />  zzip_savefile variable since it makes subsequent calls to
 <br />  <a href="#zzip_creat"><code>zzip_creat</code></a> and <a href="#zzip_mkdir"><code>zzip_mkdir</code></a> to run as <code>creat</code>(2) / <code>mkdir</code>(2) 
 <br />  on the real filesystem.
 
</p>
<p>

</p><p>

   finalize a zip archive thereby writing the central directory to
 <br />  the end of the file. If it was a real directory then we do just
 <br />  nothing - even that the prototype of the call itself is modelled 
 <br />  to be similar to the posix <code>sync</code>(2) call. <function>The zzip_sync function</function> is 
 <br />  really a preprocessor macro or preferably an inline function
 <br />  around <a href="#zzip_closedir"><code>zzip_closedir</code></a>, there is no such symbol generated 
 <br />  into the library.
 <pre>  #ifndef zzip_savefile  
   #define zzip_savefile 0  
   #endif  
   #define zzip_sync(name,mode) \ - </pre> 
       { zzip_closedir(zzip_savefile); zzip_savefile = 0; }

</p><p>

</p>
<p align="right"><small>(../../zzip/write.c)</small></p></dd>
<dt><a name="zzip_open" /> <a name="zzip_open_ext_io" /> <a name="zzip_open_shared_io" />
  <code>ZZIP_FILE*
</code>
  <br /><b><code>zzip_open</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>int o_flags</nobr>)</code>

</code>

<br />  <code>ZZIP_FILE*
</code>
  <br /><b><code>zzip_open_ext_io</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>int o_flags</nobr>,
<nobr>int o_modes</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</code>

<br />  <code>ZZIP_FILE*
</code>
  <br /><b><code>zzip_open_shared_io</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE* stream</nobr>,
<nobr>zzip_char_t* filename</nobr>,
<nobr>int o_flags</nobr>,
<nobr>int o_modes</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />  <function>The zzip_open function</function> will <code>open</code>(2) a real/zipped file

</p><p>

   It has some magic functionality builtin - it will first try to open
 <br />  the given <em>filename</em> as a normal file. If it does not
 <br />  exist, the given path to the filename (if any) is split into
 <br />  its directory-part and the file-part. A ".zip" extension is
 <br />  then added to the directory-part to create the name of a
 <br />  zip-archive. That zip-archive (if it exists) is being searched
 <br />  for the file-part, and if found a zzip-handle is returned. 

</p><p>

   Note that if the file is found in the normal fs-directory the
 <br />  returned structure is mostly empty and the <a href="#zzip_read"><code>zzip_read</code></a> call will
 <br />  use the libc <code>read</code> to obtain data. Otherwise a <a href="#zzip_file_open"><code>zzip_file_open</code></a> 
 <br />  is performed and any error mapped to <code>errno</code>(3).

</p><p>

   There was a possibility to transfer zziplib-specific openmodes
 <br />  through o_flags but you should please not use them anymore and
 <br />  look into <a href="#zzip_open_ext_io"><code>zzip_open_ext_io</code></a> to submit them down. <function>The zzip_open function</function>
 <br />  is shallow in that it just extracts the zzipflags and calls <ul><li><code>
 <br />  zzip_open_ext_io(filename, o_flags, zzipflags|0664, 0, 0) </code></li></ul>
 <br />  you must stop using this extra functionality (not well known
 <br />  anyway) since zzip_open might be later usable to open files
 <br />  for writing in which case the _EXTRAFLAGS will get in conflict.

</p><p>

   compare with  <code>open</code>(2) and <a href="#zzip_fopen"><code>zzip_fopen</code></a>
 
</p>
<p>

</p><p>

   <function>The zzip_open_ext_io function</function> uses explicit ext and io instead of the internal 
 <br />  defaults, setting them to zero is equivalent to <a href="#zzip_open"><code>zzip_open</code></a>

</p><p>

   note that the two flag types have been split into an o_flags
 <br />  (for fcntl-like openflags) and o_modes where the latter shall
 <br />  carry the zzip_flags and possibly accessmodes for unix filesystems.
 <br />  Since this version of zziplib can not write zipfiles, it is not
 <br />  yet used for anything else than zzip-specific modeflags.
 
</p>
<p>

</p><p>

   <function>The zzip_open_shared_io function</function> takes an extra stream argument - if a handle has been
 <br />  then ext/io can be left null and the new stream handle will pick up 
 <br />  the ext/io. This should be used only in specific environment however 
 <br />  since <a href="#zzip_file_real"><code>zzip_file_real</code></a> does not store any ext-sequence.

</p><p>

   The benefit for <function>the zzip_open_shared_io function</function> comes in when the old file handle
 <br />  was openened from a file within a zip archive. When the new file
 <br />  is in the same zip archive then the internal zzip_dir structures
 <br />  will be shared. It is even quicker, as no check needs to be done
 <br />  anymore trying to guess the zip archive place in the filesystem,
 <br />  here we just check whether the zip archive's filepath is a prefix
 <br />  part of the filename to be opened. 

</p><p>

   Note that <function>the zzip_open_shared_io function</function> is also used by <a href="#zzip_freopen"><code>zzip_freopen</code></a> that
 <br />  will unshare the old handle, thereby possibly closing the handle.
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_opendir" /> <a name="zzip_opendir_ext_io" />
  <code>ZZIP_DIR* 
</code>
  <br /><b><code>zzip_opendir</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* filename</nobr>)</code>

</code>

<br />  <code>ZZIP_DIR* 
</code>
  <br /><b><code>zzip_opendir_ext_io</code></b>
   &nbsp; <code>
 <code>(<nobr>zzip_char_t* filename</nobr>,
<nobr>int o_modes</nobr>,
<nobr>zzip_strings_t* ext</nobr>,
<nobr>zzip_plugin_io_t io</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/dir.c)

</em></para><p>
 <br />  <function>The zzip_opendir function</function> is the equivalent of <code>opendir</code>(3) for a realdir or zipfile.

</p><p>

   <function>The zzip_opendir function</function> has some magic - if the given argument-path
 <br />  is a directory, it will wrap a real <code>opendir</code>(3) into the ZZIP_DIR
 <br />  structure. Otherwise it will divert to <a href="#zzip_dir_open"><code>zzip_dir_open</code></a> which 
 <br />  can also attach a ".zip" extension if needed to find the archive.

</p><p>

   the error-code is mapped to <code>errno</code>(3).
 
</p>
<p>
 <br />  <function>The zzip_opendir_ext_io function</function> uses explicit ext and io instead of the internal 
 <br />  defaults, setting them to zero is equivalent to <a href="#zzip_opendir"><code>zzip_opendir</code></a>
 
</p>
<p align="right"><small>(../../zzip/dir.c)</small></p></dd>
<dt><a name="zzip_read" /> <a name="zzip_fread" />
  <code>zzip_ssize_t
</code>
  <br /><b><code>zzip_read</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE * fp</nobr>,
<nobr>char * buf</nobr>,
<nobr>zzip_size_t len</nobr>)</code>

</code>

<br />  <code>zzip_size_t
</code>
  <br /><b><code>zzip_fread</code></b>
   &nbsp; <code>
 <code>(<nobr>void *ptr</nobr>,
<nobr>zzip_size_t size</nobr>,
<nobr>zzip_size_t nmemb</nobr>,
<nobr>ZZIP_FILE *file</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />  <function>The zzip_read function</function> will read(2) data from a real/zipped file.

</p><p>

   the replacement for <code>read</code>(2) will fill the given buffer with bytes from
 <br />  the opened file. It will return the number of bytes read, so if the EOF
 <br />  is encountered you will be prompted with the number of bytes actually read.

</p><p>

   If the file-handle is wrapping a stat'able file then it will actually just
 <br />  perform a normal <code>read</code>(2)-call, otherwise <a href="#zzip_file_read"><code>zzip_file_read</code></a> is called
 <br />  to decompress the data stream and any error is mapped to <code>errno</code>(3).
 
</p>
<p><small><code>zzip_fread</code></small> -
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_readdir" />
  <code>ZZIP_DIRENT* 
</code>
  <br /><b><code>zzip_readdir</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR * dir</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/dir.c)

</em></para><p>
 <br />  <function>The zzip_readdir function</function> is the equivalent of a <code>readdir</code>(2) for a realdir 
 <br />  or a zipfile referenced by the ZZIP_DIR returned from <a href="#zzip_opendir"><code>zzip_opendir</code></a>.

</p><p>

   The ZZIP_DIR handle (as returned by <a href="#zzip_opendir"><code>zzip_opendir</code></a>) contains a few more 
 <br />  entries than being copied into the ZZIP_DIRENT. The only valid fields in
 <br />  a ZZIP_DIRENT are d_name (the file name), d_compr (compression), d_csize
 <br />  (compressed size), st_size (uncompressed size).
 
</p>
<p align="right"><small>(../../zzip/dir.c)</small></p></dd>
<dt><a name="zzip_rewind" />
  <code>int
</code>
  <br /><b><code>zzip_rewind</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE *fp</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />  <function>The zzip_rewind function</function> will rewind a real/zipped file. 

</p><p>

   It seeks to the beginning of this file's data in the zip, 
 <br />  or the beginning of the file for a stat'fd.
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_rewinddir" /> <a name="zzip_telldir" /> <a name="zzip_seekdir" />
  <code>void 
</code>
  <br /><b><code>zzip_rewinddir</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR * dir</nobr>)</code>

</code>

<br />  <code>zzip_off_t 
</code>
  <br /><b><code>zzip_telldir</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>

</code>

<br />  <code>void
</code>
  <br /><b><code>zzip_seekdir</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR* dir</nobr>,
<nobr>zzip_off_t offset</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/dir.c)

</em></para><p>
 <br />  <function>The zzip_rewinddir function</function> is the equivalent of a <code>rewinddir</code>(2) for a realdir or
 <br />  the zipfile in place of a directory. The ZZIP_DIR handle returned from
 <br />  <a href="#zzip_opendir"><code>zzip_opendir</code></a> has a flag saying realdir or zipfile. As for a zipfile,
 <br />  the filenames will include the filesubpath, so take care.
 
</p>
<p>
 <br />  <function>The zzip_telldir function</function> is the equivalent of <code>telldir</code>(2) for a realdir or zipfile.
 
</p>
<p>
 <br />  <function>The zzip_seekdir function</function> is the equivalent of <code>seekdir</code>(2) for a realdir or zipfile.
 
</p>
<p align="right"><small>(../../zzip/dir.c)</small></p></dd>
<dt><a name="zzip_seek" />
  <code>zzip_off_t
</code>
  <br /><b><code>zzip_seek</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE * fp</nobr>,
<nobr>zzip_off_t offset</nobr>,
<nobr>int whence</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />  <function>The zzip_seek function</function> will perform a <code>lseek</code>(2) operation on a real/zipped file

</p><p>

   It will try to seek to the offset specified by offset, relative to whence, 
 <br />  which is one of SEEK_SET, SEEK_CUR or SEEK_END.

</p><p>

   If the file-handle is wrapping a stat'able file then it will actually just
 <br />  perform a normal <code>lseek</code>(2)-call. Otherwise the relative offset
 <br />  is calculated, negative offsets are transformed into positive ones
 <br />  by rewinding the file, and then data is read until the offset is
 <br />  reached.  This can make the function terribly slow, but this is
 <br />  how gzio implements it, so I'm not sure there is a better way
 <br />  without using the internals of the algorithm.
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_strerror" /> <a name="zzip_strerror_of" />
  <code>zzip_char_t* 
</code>
  <br /><b><code>zzip_strerror</code></b>
   &nbsp; <code>
 <code>(<nobr>int errcode</nobr>)</code>

</code>

<br />  <code>zzip_char_t* 
</code>
  <br /><b><code>zzip_strerror_of</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_DIR* dir</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/err.c)

</em></para><p>
 <br />  returns the static string for the given error code. The
 <br />  error code can be either a normal system error (a
 <br />  positive error code will flag this), it can be <code>libz</code>
 <br />  error code (a small negative error code will flag this)
 <br />  or it can be an error code from <code>libzzip</code>, which is an
 <br />  negative value lower than <code>ZZIP_ERROR</code>
 
</p>
<p>
 <br />  <function>The zzip_strerror_of function</function> fetches the errorcode from the <code>DIR</code>-handle and 
 <br />  runs it through <a href="#zzip_strerror"><code>zzip_strerror</code></a> to obtain the static string
 <br />  describing the error.
 
</p>
<p align="right"><small>(../../zzip/err.c)</small></p></dd>
<dt><a name="zzip_tell" />
  <code>zzip_off_t
</code>
  <br /><b><code>zzip_tell</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE * fp</nobr>)</code>

</code>
<dt>
<dd>
<para><em> &nbsp;(zzip/file.c)

</em></para><p>
 <br />  <function>The zzip_tell function</function> will <code>tell</code>(2) the current position in a real/zipped file

</p><p>

   It will return the current offset within the real/zipped file, 
 <br />  measured in uncompressed bytes for the zipped-file case.

</p><p>

   If the file-handle is wrapping a stat'able file then it will actually just
 <br />  perform a normal <code>tell</code>(2)-call, otherwise the offset is
 <br />  calculated from the amount of data left and the total uncompressed
 <br />  size;
 
</p>
<p align="right"><small>(../../zzip/file.c)</small></p></dd>
<dt><a name="zzip_write" /> <a name="zzip_file_write" /> <a name="zzip_fwrite" />
  <code>zzip_ssize_t
</code>
  <br /><b><code>zzip_write</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE* file</nobr>,
<nobr>const void* ptr</nobr>,
<nobr>zzip_size_t len</nobr>)</code>
 
</code>

<br />  <code>zzip_ssize_t
</code>
  <br /><b><code>zzip_file_write</code></b>
   &nbsp; <code>
 <code>(<nobr>ZZIP_FILE* file</nobr>,
<nobr>const void* ptr</nobr>,
<nobr>zzip_size_t len</nobr>)</code>
 
</code>

<br />  <code>zzip_size_t
</code>
  <br /><b><code>zzip_fwrite</code></b>
   &nbsp; <code>
 <code>(<nobr>const void* ptr</nobr>,
<nobr>zzip_size_t len</nobr>,
<nobr>zzip_size_t multiply</nobr>,
<nobr>ZZIP_FILE* file</nobr>)</code>
 
</code>
<dt>
<dd>
<para><em> &nbsp; write to zzip storage                     


</em></para><p>

</p><p>

   <function>The zzip_write function</function> will write data to a file descriptor. If the file
 <br />  descriptor represents a real file then it will be forwarded to
 <br />  call posix <code>write</code>(2) directly. If it is a descriptor for a
 <br />  file within a zip directory then the data will be "deflated"
 <br />  using <code>zlib</code>(3) and appended to the zip archive file.
 
</p>
<p>

</p><p>

   <function>The zzip_file_write function</function> will write data to a file descriptor inside a zip
 <br />  archive. The data will be "deflated" using <code>zlib</code>(3) compression
 <br />  and appended to the end of the zip archive file. Only one file
 <br />  descriptor may be open per zzip_dir archive handle (fifo-like).

</p><p>

   <function>The zzip_file_write function</function> is not yet implemented, check for #def ZZIP_NO_CREAT
 <br />  It returns immediately -1 and sets errno=EROFS for indication.
 
</p>
<p>
 <br />  <function>The zzip_fwrite function</function> is the stdc variant for writing and the arguments
 <br />  are forwarded to <a href="#zzip_write"><code>zzip_write</code></a> - the return value is floored to
 <br />  null as for STDC spec but there is no zzip_ferror call so far
 <br />  for the zziplib (later? is it actually needed?).

</p><p>

   <function>The zzip_fwrite function</function> is not yet implemented, check for #def ZZIP_NO_CREAT
 <br />  Write-support extends <a href="#zzip_close"><code>zzip_close</code></a> with semantics to write out a 
 <br />  file-trailer to the zip-archive leaving a name/offset marker in
 <br />  the (still-open) ZZIP_DIR handle.
 
</p>
<p align="right"><small>(../../zzip/write.c)</small></p></dd>
</dl>
</body></html>

